/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/vendor/Onix/js/codeEditor/code-editor/index.js":
/*!******************************************************************!*\
  !*** ./resources/vendor/Onix/js/codeEditor/code-editor/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CodeEditor\": () => (/* binding */ CodeEditor)\n/* harmony export */ });\n/* harmony import */ var split_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! split.js */ \"./node_modules/split.js/dist/split.es.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n//Original work Copyright (c) 2018, Duarte Henriques, https://github.com/portablemind/grapesjs-code-editor\n//Modified work Copyright (c) 2020, Brendon Ngirazi, \n//All rights reserved.\n\nvar CodeEditor = /*#__PURE__*/function () {\n  function CodeEditor(editor, opts) {\n    _classCallCheck(this, CodeEditor);\n\n    this.editor = editor;\n    this.$ = editor.$;\n    this.pfx = editor.getConfig('stylePrefix');\n    this.opts = opts;\n    this.canvas = this.findWithinEditor(\".\".concat(this.pfx, \"cv-canvas\"));\n    this.panelViews = opts.appendTo ? this.$(opts.appendTo) : this.findWithinEditor(\".\".concat(this.pfx, \"pn-\").concat(opts.panelId));\n    this.isShowing = true;\n  }\n\n  _createClass(CodeEditor, [{\n    key: \"findPanel\",\n    value: function findPanel() {\n      var pn = this.editor.Panels;\n      var id = this.opts.panelId;\n      var panel = pn.getPanel(id) || pn.addPanel({\n        id: id\n      });\n      return panel;\n    }\n  }, {\n    key: \"findWithinEditor\",\n    value: function findWithinEditor(selector) {\n      return this.$(selector, this.editor.getEl());\n    }\n  }, {\n    key: \"buildCodeEditor\",\n    value: function buildCodeEditor(type) {\n      var editor = this.editor,\n          opts = this.opts;\n      return editor.CodeManager.createViewer(_objectSpread({\n        codeName: type === 'html' ? 'htmlmixed' : 'css',\n        theme: 'hopscotch',\n        readOnly: 0,\n        autoBeautify: 1,\n        autoCloseTags: 1,\n        autoCloseBrackets: 1,\n        styleActiveLine: 1,\n        smartIndent: 1\n      }, opts.codeViewOptions));\n    }\n  }, {\n    key: \"buildSection\",\n    value: function buildSection(type, codeViewer) {\n      var $ = this.$,\n          pfx = this.pfx,\n          opts = this.opts;\n      var section = $('<section></section>');\n      var btnText = type === 'html' ? opts.htmlBtnText : opts.cssBtnText;\n      var cleanCssBtn = opts.cleanCssBtn && type === 'css' ? \"<button class=\\\"cp-delete-\".concat(type, \" \").concat(pfx, \"btn-prim\\\">\").concat(opts.cleanCssBtnText, \"</button>\") : '';\n      section.append($(\"\\n            <div class=\\\"codepanel-separator\\\">\\n                <div class=\\\"codepanel-label\\\">\".concat(type, \"</div>\\n                <div class=\\\"cp-btn-container\\\">\\n                    \").concat(cleanCssBtn, \"\\n                    <button class=\\\"cp-apply-\").concat(type, \" \").concat(pfx, \"btn-prim\\\">\").concat(btnText, \"</button>\\n                </div>\\n            </div>\")));\n      var codeViewerEl = codeViewer.getElement();\n      codeViewerEl.style.height = 'calc(100% - 30px)';\n      section.append(codeViewerEl);\n      this.codePanel.append(section);\n      return section.get(0);\n    }\n  }, {\n    key: \"buildCodePanel\",\n    value: function buildCodePanel() {\n      var _this = this;\n\n      var $ = this.$,\n          editor = this.editor;\n      var panel = this.opts.panelId ? this.findPanel() : 0;\n      this.codePanel = $('<div></div>');\n      this.codePanel.addClass('code-panel');\n      this.htmlCodeEditor = this.buildCodeEditor('html');\n      this.cssCodeEditor = this.buildCodeEditor('css');\n      var sections = [this.buildSection('html', this.htmlCodeEditor), this.buildSection('css', this.cssCodeEditor)];\n      panel && !this.opts.appendTo && panel.set('appendContent', this.codePanel).trigger('change:appendContent');\n      this.opts.appendTo && $(this.opts.appendTo).append(this.codePanel);\n      this.updateEditorContents();\n      this.codePanel.find('.cp-apply-html').on('click', this.updateHtml.bind(this));\n      this.codePanel.find('.cp-apply-css').on('click', this.updateCss.bind(this));\n      this.opts.cleanCssBtn && this.codePanel.find('.cp-delete-css').on('click', this.deleteSelectedCss.bind(this));\n      (0,split_js__WEBPACK_IMPORTED_MODULE_0__.default)(sections, {\n        direction: 'vertical',\n        sizes: [50, 50],\n        minSize: 100,\n        gutterSize: 1,\n        onDragEnd: this.refreshEditors.bind(this)\n      });\n      editor.on('component:update', function (model) {\n        return _this.updateEditorContents();\n      });\n    }\n  }, {\n    key: \"showCodePanel\",\n    value: function showCodePanel() {\n      this.isShowing = true;\n      this.updateEditorContents();\n      this.codePanel.css('display', 'block'); // make sure editor is aware of width change after the 300ms effect ends\n\n      setTimeout(this.refreshEditors.bind(this), 320);\n      this.panelViews.css('width', this.opts.openState.pn);\n      this.canvas.css('width', this.opts.openState.cv);\n    }\n  }, {\n    key: \"hideCodePanel\",\n    value: function hideCodePanel() {\n      if (this.codePanel) this.codePanel.css('display', 'none');\n      this.panelViews.css('width', this.opts.closedState.pn);\n      this.canvas.css('width', this.opts.closedState.cv);\n      this.isShowing = false;\n    }\n  }, {\n    key: \"refreshEditors\",\n    value: function refreshEditors() {\n      this.htmlCodeEditor.refresh();\n      this.cssCodeEditor.refresh();\n    }\n  }, {\n    key: \"updateHtml\",\n    value: function updateHtml() {\n      var editor = this.editor,\n          component = this.component;\n      var htmlCode = this.htmlCodeEditor.getContent().trim();\n      if (!htmlCode || htmlCode === this.previousHtmlCode) return;\n      this.previousHtmlCode = htmlCode;\n      var idStyles = '';\n      this.cssCodeEditor.getContent().split(/(?<=}\\n)/g).forEach(function (rule) {\n        if (/^#/.test(rule)) idStyles += rule;\n      });\n      htmlCode += \"<style>\".concat(idStyles, \"</style>\");\n      editor.select(component.replaceWith(htmlCode));\n    }\n  }, {\n    key: \"updateCss\",\n    value: function updateCss() {\n      var cssCode = this.cssCodeEditor.getContent().trim();\n      if (!cssCode || cssCode === this.previousCssCode) return;\n      this.parseRemove(cssCode);\n      this.previousCssCode = cssCode;\n      this.editor.Components.addComponent(\"<style>\".concat(cssCode, \"</style>\"));\n    }\n  }, {\n    key: \"deleteSelectedCss\",\n    value: function deleteSelectedCss() {\n      var _this2 = this;\n\n      var selections = this.cssCodeEditor.editor.getSelections();\n      selections.forEach(function (selection) {\n        return _this2.parseRemove(selection);\n      });\n      this.cssCodeEditor.editor.deleteH();\n    }\n  }, {\n    key: \"parseRemove\",\n    value: function parseRemove(removeCss) {\n      var _this3 = this;\n\n      var editor = this.editor;\n      var cssc = editor.CssComposer;\n      var allRules = cssc.getAll();\n      editor.Parser.parseCss(removeCss).forEach(function (p) {\n        var config = {\n          singleAtRule: p.singleAtRule,\n          atRuleType: p.atRuleType,\n          mediaText: p.mediaText,\n          state: p.state\n        };\n        p.selectors.length && p.selectors.forEach(function (selector) {\n          _this3.removeSelector(selector, allRules, cssc, config);\n        });\n        p.selectorsAdd && p.selectorsAdd.split(', ').forEach(function (selector) {\n          _this3.removeSelector(selector, allRules, cssc, config);\n        });\n      });\n    }\n  }, {\n    key: \"removeSelector\",\n    value: function removeSelector(rule, allRules, cssc) {\n      var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var singleAtRule = opts.singleAtRule,\n          atRuleType = opts.atRuleType,\n          mediaText = opts.mediaText,\n          state = opts.state;\n      var toRemove = allRules.filter(function (r) {\n        if (atRuleType && mediaText) return function (r) {\n          return r.get('atRuleType') == atRuleType && r.get('mediaText') == mediaText;\n        };else if (atRuleType && singleAtRule) return function (r) {\n          return r.get('atRuleType') == atRuleType && r.get('singleAtRule') == singleAtRule;\n        };else if (state) return r == cssc.getRule(\"\".concat(rule, \":\").concat(state));\n        return r == cssc.getRule(rule);\n      });\n      allRules.remove(toRemove);\n    }\n  }, {\n    key: \"updateEditorContents\",\n    value: function updateEditorContents() {\n      if (!this.isShowing) return;\n      this.component = this.editor.getSelected();\n\n      if (this.component) {\n        this.htmlCodeEditor.setContent(this.getComponentHtml(this.component));\n        this.cssCodeEditor.setContent(this.editor.CodeManager.getCode(this.component, 'css', {\n          cssc: this.editor.CssComposer\n        }));\n      }\n    }\n  }, {\n    key: \"getComponentHtml\",\n    value: function getComponentHtml(component) {\n      var pfx = this.pfx,\n          opts = this.opts;\n      var result = '';\n      var componentEl = component.getEl();\n      !opts.clearData && componentEl.classList.remove(\"\".concat(pfx, \"selected\"));\n      var html = opts.clearData ? component.toHTML() : componentEl.id === 'wrapper' ? componentEl.innerHTML : componentEl.outerHTML;\n      !opts.clearData && componentEl.classList.add(\"\".concat(pfx, \"selected\"));\n      result += html;\n      var js = opts.editJs ? component.getScriptString() : '';\n      result += js ? \"<script>\".concat(js, \"</script>\") : '';\n      return result;\n    }\n  }]);\n\n  return CodeEditor;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdmVuZG9yL09uaXgvanMvY29kZUVkaXRvci9jb2RlLWVkaXRvci9pbmRleC5qcz9hMmMxIl0sIm5hbWVzIjpbIkNvZGVFZGl0b3IiLCJlZGl0b3IiLCJvcHRzIiwiJCIsInBmeCIsImdldENvbmZpZyIsImNhbnZhcyIsImZpbmRXaXRoaW5FZGl0b3IiLCJwYW5lbFZpZXdzIiwiYXBwZW5kVG8iLCJwYW5lbElkIiwiaXNTaG93aW5nIiwicG4iLCJQYW5lbHMiLCJpZCIsInBhbmVsIiwiZ2V0UGFuZWwiLCJhZGRQYW5lbCIsInNlbGVjdG9yIiwiZ2V0RWwiLCJ0eXBlIiwiQ29kZU1hbmFnZXIiLCJjcmVhdGVWaWV3ZXIiLCJjb2RlTmFtZSIsInRoZW1lIiwicmVhZE9ubHkiLCJhdXRvQmVhdXRpZnkiLCJhdXRvQ2xvc2VUYWdzIiwiYXV0b0Nsb3NlQnJhY2tldHMiLCJzdHlsZUFjdGl2ZUxpbmUiLCJzbWFydEluZGVudCIsImNvZGVWaWV3T3B0aW9ucyIsImNvZGVWaWV3ZXIiLCJzZWN0aW9uIiwiYnRuVGV4dCIsImh0bWxCdG5UZXh0IiwiY3NzQnRuVGV4dCIsImNsZWFuQ3NzQnRuIiwiY2xlYW5Dc3NCdG5UZXh0IiwiYXBwZW5kIiwiY29kZVZpZXdlckVsIiwiZ2V0RWxlbWVudCIsInN0eWxlIiwiaGVpZ2h0IiwiY29kZVBhbmVsIiwiZ2V0IiwiZmluZFBhbmVsIiwiYWRkQ2xhc3MiLCJodG1sQ29kZUVkaXRvciIsImJ1aWxkQ29kZUVkaXRvciIsImNzc0NvZGVFZGl0b3IiLCJzZWN0aW9ucyIsImJ1aWxkU2VjdGlvbiIsInNldCIsInRyaWdnZXIiLCJ1cGRhdGVFZGl0b3JDb250ZW50cyIsImZpbmQiLCJvbiIsInVwZGF0ZUh0bWwiLCJiaW5kIiwidXBkYXRlQ3NzIiwiZGVsZXRlU2VsZWN0ZWRDc3MiLCJTcGxpdCIsImRpcmVjdGlvbiIsInNpemVzIiwibWluU2l6ZSIsImd1dHRlclNpemUiLCJvbkRyYWdFbmQiLCJyZWZyZXNoRWRpdG9ycyIsIm1vZGVsIiwiY3NzIiwic2V0VGltZW91dCIsIm9wZW5TdGF0ZSIsImN2IiwiY2xvc2VkU3RhdGUiLCJyZWZyZXNoIiwiY29tcG9uZW50IiwiaHRtbENvZGUiLCJnZXRDb250ZW50IiwidHJpbSIsInByZXZpb3VzSHRtbENvZGUiLCJpZFN0eWxlcyIsInNwbGl0IiwiZm9yRWFjaCIsInJ1bGUiLCJ0ZXN0Iiwic2VsZWN0IiwicmVwbGFjZVdpdGgiLCJjc3NDb2RlIiwicHJldmlvdXNDc3NDb2RlIiwicGFyc2VSZW1vdmUiLCJDb21wb25lbnRzIiwiYWRkQ29tcG9uZW50Iiwic2VsZWN0aW9ucyIsImdldFNlbGVjdGlvbnMiLCJzZWxlY3Rpb24iLCJkZWxldGVIIiwicmVtb3ZlQ3NzIiwiY3NzYyIsIkNzc0NvbXBvc2VyIiwiYWxsUnVsZXMiLCJnZXRBbGwiLCJQYXJzZXIiLCJwYXJzZUNzcyIsInAiLCJjb25maWciLCJzaW5nbGVBdFJ1bGUiLCJhdFJ1bGVUeXBlIiwibWVkaWFUZXh0Iiwic3RhdGUiLCJzZWxlY3RvcnMiLCJsZW5ndGgiLCJyZW1vdmVTZWxlY3RvciIsInNlbGVjdG9yc0FkZCIsInRvUmVtb3ZlIiwiZmlsdGVyIiwiciIsImdldFJ1bGUiLCJyZW1vdmUiLCJnZXRTZWxlY3RlZCIsInNldENvbnRlbnQiLCJnZXRDb21wb25lbnRIdG1sIiwiZ2V0Q29kZSIsInJlc3VsdCIsImNvbXBvbmVudEVsIiwiY2xlYXJEYXRhIiwiY2xhc3NMaXN0IiwiaHRtbCIsInRvSFRNTCIsImlubmVySFRNTCIsIm91dGVySFRNTCIsImFkZCIsImpzIiwiZWRpdEpzIiwiZ2V0U2NyaXB0U3RyaW5nIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRU8sSUFBTUEsVUFBYjtBQUNJLHNCQUFZQyxNQUFaLEVBQW9CQyxJQUFwQixFQUEwQjtBQUFBOztBQUN0QixTQUFLRCxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxTQUFLRSxDQUFMLEdB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QXZELENBQTlCO0FBR0g7QUFDSjtBQXhNTDtBQUFBO0FBQUEsV0EwTUksMEJBQWlCdkIsU0FBakIsRUFBNEI7QUFBQSxVQUNoQnhFLEdBRGdCLEdBQ0YsSUFERSxDQUNoQkEsR0FEZ0I7QUFBQSxVQUNYRixJQURXLEdBQ0YsSUFERSxDQUNYQSxJQURXO0FBRXhCLFVBQUl5SCxNQUFNLEdBQUcsRUFBYjtBQUNBLFVBQU1DLFdBQVcsR0FBR2hELFNBQVMsQ0FBQ3pELEtBQVYsRUFBcEI7QUFFQSxPQUFDakIsSUFBSSxDQUFDMkgsU0FBTixJQUFtQkQsV0FBVyxDQUFDRSxTQUFaLENBQXNCUixNQUF0QixXQUFnQ2xILEdBQWhDLGNBQW5CO0FBQ0EsVUFBTTJILElBQUksR0FBRzdILElBQUksQ0FBQzJILFNBQUwsR0FBaUJqRCxTQUFTLENBQUNvRCxNQUFWLEVBQWpCLEdBQ1JKLFdBQVcsQ0FBQzlHLEVBQVosS0FBbUIsU0FBbkIsR0FBK0I4RyxXQUFXLENBQUNLLFNBQTNDLEdBQXVETCxXQUFXLENBQUNNLFNBRHhFO0FBRUEsT0FBQ2hJLElBQUksQ0FBQzJILFNBQU4sSUFBbUJELFdBQVcsQ0FBQ0UsU0FBWixDQUFzQkssR0FBdEIsV0FBNkIvSCxHQUE3QixjQUFuQjtBQUNBdUgsWUFBTSxJQUFJSSxJQUFWO0FBRUEsVUFBTUssRUFBRSxHQUFHbEksSUFBSSxDQUFDbUksTUFBTCxHQUFjekQsU0FBUyxDQUFDMEQsZUFBVixFQUFkLEdBQTRDLEVBQXZEO0FBQ0FYLFlBQU0sSUFBSVMsRUFBRSxxQkFBY0EsRUFBZCxpQkFBOEIsRUFBMUM7QUFFQSxhQUFPVCxNQUFQO0FBQ0g7QUF6Tkw7O0FBQUE7QUFBQSIsImZpbGUiOiIuL3Jlc291cmNlcy92ZW5kb3IvT25peC9qcy9jb2RlRWRpdG9yL2NvZGUtZWRpdG9yL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy9PcmlnaW5hbCB3b3JrIENvcHlyaWdodCAoYykgMjAxOCwgRHVhcnRlIEhlbnJpcXVlcywgaHR0cHM6Ly9naXRodWIuY29tL3BvcnRhYmxlbWluZC9ncmFwZXNqcy1jb2RlLWVkaXRvclxyXG4vL01vZGlmaWVkIHdvcmsgQ29weXJpZ2h0IChjKSAyMDIwLCBCcmVuZG9uIE5naXJhemksIFxyXG4vL0FsbCByaWdodHMgcmVzZXJ2ZWQuXHJcblxyXG5pbXBvcnQgU3BsaXQgZnJvbSAnc3BsaXQuanMnO1xyXG5cclxuZXhwb3J0IGNsYXNzIENvZGVFZGl0b3Ige1xyXG4gICAgY29uc3RydWN0b3IoZWRpdG9yLCBvcHRzKSB7XHJcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XHJcbiAgICAgICAgdGhpcy4kID0gZWRpdG9yLiQ7XHJcbiAgICAgICAgdGhpcy5wZnggPSBlZGl0b3IuZ2V0Q29uZmlnKCdzdHlsZVByZWZpeCcpO1xyXG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XHJcbiAgICAgICAgdGhpcy5jYW52YXMgPSB0aGlzLmZpbmRXaXRoaW5FZGl0b3IoYC4ke3RoaXMucGZ4fWN2LWNhbnZhc2ApO1xyXG4gICAgICAgIHRoaXMucGFuZWxWaWV3cyA9IG9wdHMuYXBwZW5kVG8gPyB0aGlzLiQob3B0cy5hcHBlbmRUbykgOlxyXG4gICAgICAgICAgICB0aGlzLmZpbmRXaXRoaW5FZGl0b3IoYC4ke3RoaXMucGZ4fXBuLSR7b3B0cy5wYW5lbElkfWApO1xyXG4gICAgICAgIHRoaXMuaXNTaG93aW5nID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmaW5kUGFuZWwoKSB7XHJcbiAgICAgICAgY29uc3QgcG4gPSB0aGlzLmVkaXRvci5QYW5lbHM7XHJcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLm9wdHMucGFuZWxJZDtcclxuICAgICAgICBjb25zdCBwYW5lbCA9IHBuLmdldFBhbmVsKGlkKSB8fCBwbi5hZGRQYW5lbCh7IGlkIH0pO1xyXG4gICAgICAgIHJldHVybiBwYW5lbDtcclxuICAgIH1cclxuXHJcbiAgICBmaW5kV2l0aGluRWRpdG9yKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuJChzZWxlY3RvciwgdGhpcy5lZGl0b3IuZ2V0RWwoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgYnVpbGRDb2RlRWRpdG9yKHR5cGUpIHtcclxuICAgICAgICBjb25zdCB7IGVkaXRvciwgb3B0cyB9ID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIGVkaXRvci5Db2RlTWFuYWdlci5jcmVhdGVWaWV3ZXIoe1xyXG4gICAgICAgICAgICBjb2RlTmFtZTogdHlwZSA9PT0gJ2h0bWwnID8gJ2h0bWxtaXhlZCcgOiAnY3NzJyxcclxuICAgICAgICAgICAgdGhlbWU6ICdob3BzY290Y2gnLFxyXG4gICAgICAgICAgICByZWFkT25seTogMCxcclxuICAgICAgICAgICAgYXV0b0JlYXV0aWZ5OiAxLFxyXG4gICAgICAgICAgICBhdXRvQ2xvc2VUYWdzOiAxLFxyXG4gICAgICAgICAgICBhdXRvQ2xvc2VCcmFja2V0czogMSxcclxuICAgICAgICAgICAgc3R5bGVBY3RpdmVMaW5lOiAxLFxyXG4gICAgICAgICAgICBzbWFydEluZGVudDogMSxcclxuICAgICAgICAgICAgLi4ub3B0cy5jb2RlVmlld09wdGlvbnNcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBidWlsZFNlY3Rpb24odHlwZSwgY29kZVZpZXdlcikge1xyXG4gICAgICAgIGNvbnN0IHsgJCwgcGZ4LCBvcHRzIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHNlY3Rpb24gPSAkKCc8c2VjdGlvbj48L3NlY3Rpb24+Jyk7XHJcbiAgICAgICAgY29uc3QgYnRuVGV4dCA9IHR5cGUgPT09ICdodG1sJyA/IG9wdHMuaHRtbEJ0blRleHQgOiBvcHRzLmNzc0J0blRleHQ7XHJcbiAgICAgICAgY29uc3QgY2xlYW5Dc3NCdG4gPSAob3B0cy5jbGVhbkNzc0J0biAmJiB0eXBlID09PSAnY3NzJykgP1xyXG4gICAgICAgICAgICBgPGJ1dHRvbiBjbGFzcz1cImNwLWRlbGV0ZS0ke3R5cGV9ICR7cGZ4fWJ0bi1wcmltXCI+JHtvcHRzLmNsZWFuQ3NzQnRuVGV4dH08L2J1dHRvbj5gIDogJyc7XHJcbiAgICAgICAgc2VjdGlvbi5hcHBlbmQoJChgXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2RlcGFuZWwtc2VwYXJhdG9yXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29kZXBhbmVsLWxhYmVsXCI+JHt0eXBlfTwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNwLWJ0bi1jb250YWluZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICAke2NsZWFuQ3NzQnRufVxyXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJjcC1hcHBseS0ke3R5cGV9ICR7cGZ4fWJ0bi1wcmltXCI+JHtidG5UZXh0fTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PmApKTtcclxuICAgICAgICBjb25zdCBjb2RlVmlld2VyRWwgPSBjb2RlVmlld2VyLmdldEVsZW1lbnQoKTtcclxuICAgICAgICBjb2RlVmlld2VyRWwuc3R5bGUuaGVpZ2h0ID0gJ2NhbGMoMTAwJSAtIDMwcHgpJztcclxuICAgICAgICBzZWN0aW9uLmFwcGVuZChjb2RlVmlld2VyRWwpO1xyXG4gICAgICAgIHRoaXMuY29kZVBhbmVsLmFwcGVuZChzZWN0aW9uKTtcclxuICAgICAgICByZXR1cm4gc2VjdGlvbi5nZXQoMCk7XHJcbiAgICB9XHJcblxyXG4gICAgYnVpbGRDb2RlUGFuZWwoKSB7XHJcbiAgICAgICAgY29uc3QgeyAkLCBlZGl0b3IgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgcGFuZWwgPSB0aGlzLm9wdHMucGFuZWxJZCA/IHRoaXMuZmluZFBhbmVsKCkgOiAwO1xyXG4gICAgICAgIHRoaXMuY29kZVBhbmVsID0gJCgnPGRpdj48L2Rpdj4nKTtcclxuICAgICAgICB0aGlzLmNvZGVQYW5lbC5hZGRDbGFzcygnY29kZS1wYW5lbCcpO1xyXG5cclxuICAgICAgICB0aGlzLmh0bWxDb2RlRWRpdG9yID0gdGhpcy5idWlsZENvZGVFZGl0b3IoJ2h0bWwnKTtcclxuICAgICAgICB0aGlzLmNzc0NvZGVFZGl0b3IgPSB0aGlzLmJ1aWxkQ29kZUVkaXRvcignY3NzJyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNlY3Rpb25zID0gW3RoaXMuYnVpbGRTZWN0aW9uKCdodG1sJywgdGhpcy5odG1sQ29kZUVkaXRvciksXHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRTZWN0aW9uKCdjc3MnLCB0aGlzLmNzc0NvZGVFZGl0b3IpXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgcGFuZWwgJiYgIXRoaXMub3B0cy5hcHBlbmRUbyAmJlxyXG4gICAgICAgICAgICBwYW5lbC5zZXQoJ2FwcGVuZENvbnRlbnQnLCB0aGlzLmNvZGVQYW5lbCkudHJpZ2dlcignY2hhbmdlOmFwcGVuZENvbnRlbnQnKTtcclxuICAgICAgICB0aGlzLm9wdHMuYXBwZW5kVG8gJiYgJCh0aGlzLm9wdHMuYXBwZW5kVG8pLmFwcGVuZCh0aGlzLmNvZGVQYW5lbCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3JDb250ZW50cygpO1xyXG5cclxuICAgICAgICB0aGlzLmNvZGVQYW5lbC5maW5kKCcuY3AtYXBwbHktaHRtbCcpXHJcbiAgICAgICAgICAgIC5vbignY2xpY2snLCB0aGlzLnVwZGF0ZUh0bWwuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgIHRoaXMuY29kZVBhbmVsLmZpbmQoJy5jcC1hcHBseS1jc3MnKVxyXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgdGhpcy51cGRhdGVDc3MuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgIHRoaXMub3B0cy5jbGVhbkNzc0J0biAmJiB0aGlzLmNvZGVQYW5lbC5maW5kKCcuY3AtZGVsZXRlLWNzcycpXHJcbiAgICAgICAgICAgIC5vbignY2xpY2snLCB0aGlzLmRlbGV0ZVNlbGVjdGVkQ3NzLmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICBTcGxpdChzZWN0aW9ucywge1xyXG4gICAgICAgICAgICBkaXJlY3Rpb246ICd2ZXJ0aWNhbCcsXHJcbiAgICAgICAgICAgIHNpemVzOiBbNTAsIDUwXSxcclxuICAgICAgICAgICAgbWluU2l6ZTogMTAwLFxyXG4gICAgICAgICAgICBndXR0ZXJTaXplOiAxLFxyXG4gICAgICAgICAgICBvbkRyYWdFbmQ6IHRoaXMucmVmcmVzaEVkaXRvcnMuYmluZCh0aGlzKSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZWRpdG9yLm9uKCdjb21wb25lbnQ6dXBkYXRlJywgbW9kZWwgPT4gdGhpcy51cGRhdGVFZGl0b3JDb250ZW50cygpKTtcclxuICAgIH1cclxuXHJcbiAgICBzaG93Q29kZVBhbmVsKCkge1xyXG4gICAgICAgIHRoaXMuaXNTaG93aW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvckNvbnRlbnRzKCk7XHJcbiAgICAgICAgdGhpcy5jb2RlUGFuZWwuY3NzKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIGVkaXRvciBpcyBhd2FyZSBvZiB3aWR0aCBjaGFuZ2UgYWZ0ZXIgdGhlIDMwMG1zIGVmZmVjdCBlbmRzXHJcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnJlZnJlc2hFZGl0b3JzLmJpbmQodGhpcyksIDMyMCk7XHJcbiAgICAgICAgdGhpcy5wYW5lbFZpZXdzLmNzcygnd2lkdGgnLCB0aGlzLm9wdHMub3BlblN0YXRlLnBuKTtcclxuICAgICAgICB0aGlzLmNhbnZhcy5jc3MoJ3dpZHRoJywgdGhpcy5vcHRzLm9wZW5TdGF0ZS5jdik7XHJcbiAgICB9XHJcblxyXG4gICAgaGlkZUNvZGVQYW5lbCgpIHtcclxuICAgICAgICBpZiAodGhpcy5jb2RlUGFuZWwpIHRoaXMuY29kZVBhbmVsLmNzcygnZGlzcGxheScsICdub25lJyk7XHJcbiAgICAgICAgdGhpcy5wYW5lbFZpZXdzLmNzcygnd2lkdGgnLCB0aGlzLm9wdHMuY2xvc2VkU3RhdGUucG4pO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLmNzcygnd2lkdGgnLCB0aGlzLm9wdHMuY2xvc2VkU3RhdGUuY3YpO1xyXG4gICAgICAgIHRoaXMuaXNTaG93aW5nID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmVmcmVzaEVkaXRvcnMoKSB7XHJcbiAgICAgICAgdGhpcy5odG1sQ29kZUVkaXRvci5yZWZyZXNoKCk7XHJcbiAgICAgICAgdGhpcy5jc3NDb2RlRWRpdG9yLnJlZnJlc2goKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVIdG1sKCkge1xyXG4gICAgICAgIGNvbnN0IHsgZWRpdG9yLCBjb21wb25lbnQgfSA9IHRoaXM7XHJcbiAgICAgICAgbGV0IGh0bWxDb2RlID0gdGhpcy5odG1sQ29kZUVkaXRvci5nZXRDb250ZW50KCkudHJpbSgpO1xyXG4gICAgICAgIGlmICghaHRtbENvZGUgfHwgaHRtbENvZGUgPT09IHRoaXMucHJldmlvdXNIdG1sQ29kZSkgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNIdG1sQ29kZSA9IGh0bWxDb2RlO1xyXG5cclxuICAgICAgICBsZXQgaWRTdHlsZXMgPSAnJztcclxuICAgICAgICB0aGlzLmNzc0NvZGVFZGl0b3JcclxuICAgICAgICAgICAgLmdldENvbnRlbnQoKVxyXG4gICAgICAgICAgICAuc3BsaXQoLyg/PD19XFxuKS9nKVxyXG4gICAgICAgICAgICAuZm9yRWFjaChydWxlID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICgvXiMvLnRlc3QocnVsZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgaWRTdHlsZXMgKz0gcnVsZTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGh0bWxDb2RlICs9IGA8c3R5bGU+JHtpZFN0eWxlc308L3N0eWxlPmA7XHJcblxyXG4gICAgICAgIGVkaXRvci5zZWxlY3QoY29tcG9uZW50LnJlcGxhY2VXaXRoKGh0bWxDb2RlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlQ3NzKCkge1xyXG4gICAgICAgIGNvbnN0IGNzc0NvZGUgPSB0aGlzLmNzc0NvZGVFZGl0b3IuZ2V0Q29udGVudCgpLnRyaW0oKTtcclxuICAgICAgICBpZiAoIWNzc0NvZGUgfHwgY3NzQ29kZSA9PT0gdGhpcy5wcmV2aW91c0Nzc0NvZGUpIHJldHVybjtcclxuICAgICAgICB0aGlzLnBhcnNlUmVtb3ZlKGNzc0NvZGUpO1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNDc3NDb2RlID0gY3NzQ29kZTtcclxuICAgICAgICB0aGlzLmVkaXRvci5Db21wb25lbnRzLmFkZENvbXBvbmVudChgPHN0eWxlPiR7Y3NzQ29kZX08L3N0eWxlPmApO1xyXG4gICAgfVxyXG5cclxuICAgIGRlbGV0ZVNlbGVjdGVkQ3NzKCkge1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbnMgPSB0aGlzLmNzc0NvZGVFZGl0b3IuZWRpdG9yLmdldFNlbGVjdGlvbnMoKTtcclxuICAgICAgICBzZWxlY3Rpb25zLmZvckVhY2goc2VsZWN0aW9uID0+IHRoaXMucGFyc2VSZW1vdmUoc2VsZWN0aW9uKSk7XHJcbiAgICAgICAgdGhpcy5jc3NDb2RlRWRpdG9yLmVkaXRvci5kZWxldGVIKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcGFyc2VSZW1vdmUocmVtb3ZlQ3NzKSB7XHJcbiAgICAgICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgY3NzYyA9IGVkaXRvci5Dc3NDb21wb3NlclxyXG4gICAgICAgIGNvbnN0IGFsbFJ1bGVzID0gY3NzYy5nZXRBbGwoKTtcclxuICAgICAgICBlZGl0b3IuUGFyc2VyLnBhcnNlQ3NzKHJlbW92ZUNzcykuZm9yRWFjaChwID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29uZmlnID0ge1xyXG4gICAgICAgICAgICAgICAgc2luZ2xlQXRSdWxlOiBwLnNpbmdsZUF0UnVsZSxcclxuICAgICAgICAgICAgICAgIGF0UnVsZVR5cGU6IHAuYXRSdWxlVHlwZSxcclxuICAgICAgICAgICAgICAgIG1lZGlhVGV4dDogcC5tZWRpYVRleHQsXHJcbiAgICAgICAgICAgICAgICBzdGF0ZTogcC5zdGF0ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBwLnNlbGVjdG9ycy5sZW5ndGggJiZcclxuICAgICAgICAgICAgICAgIHAuc2VsZWN0b3JzLmZvckVhY2goc2VsZWN0b3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU2VsZWN0b3Ioc2VsZWN0b3IsIGFsbFJ1bGVzLCBjc3NjLCBjb25maWcpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHAuc2VsZWN0b3JzQWRkICYmXHJcbiAgICAgICAgICAgICAgICBwLnNlbGVjdG9yc0FkZC5zcGxpdCgnLCAnKS5mb3JFYWNoKHNlbGVjdG9yID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVNlbGVjdG9yKHNlbGVjdG9yLCBhbGxSdWxlcywgY3NzYywgY29uZmlnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZVNlbGVjdG9yKHJ1bGUsIGFsbFJ1bGVzLCBjc3NjLCBvcHRzID0ge30pIHtcclxuICAgICAgICBjb25zdCB7IHNpbmdsZUF0UnVsZSwgYXRSdWxlVHlwZSwgbWVkaWFUZXh0LCBzdGF0ZSB9ID0gb3B0cztcclxuICAgICAgICBjb25zdCB0b1JlbW92ZSA9IGFsbFJ1bGVzLmZpbHRlcihyID0+IHtcclxuICAgICAgICAgICAgaWYgKGF0UnVsZVR5cGUgJiYgbWVkaWFUZXh0KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHIgPT4gci5nZXQoJ2F0UnVsZVR5cGUnKSA9PSBhdFJ1bGVUeXBlICYmIHIuZ2V0KCdtZWRpYVRleHQnKSA9PSBtZWRpYVRleHQ7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGF0UnVsZVR5cGUgJiYgc2luZ2xlQXRSdWxlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHIgPT4gci5nZXQoJ2F0UnVsZVR5cGUnKSA9PSBhdFJ1bGVUeXBlICYmIHIuZ2V0KCdzaW5nbGVBdFJ1bGUnKSA9PSBzaW5nbGVBdFJ1bGU7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHIgPT0gY3NzYy5nZXRSdWxlKGAke3J1bGV9OiR7c3RhdGV9YCk7XHJcbiAgICAgICAgICAgIHJldHVybiByID09IGNzc2MuZ2V0UnVsZShydWxlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBhbGxSdWxlcy5yZW1vdmUodG9SZW1vdmUpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZUVkaXRvckNvbnRlbnRzKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1Nob3dpbmcpIHJldHVybjtcclxuXHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSB0aGlzLmVkaXRvci5nZXRTZWxlY3RlZCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmh0bWxDb2RlRWRpdG9yLnNldENvbnRlbnQodGhpcy5nZXRDb21wb25lbnRIdG1sKHRoaXMuY29tcG9uZW50KSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3NzQ29kZUVkaXRvci5zZXRDb250ZW50KHRoaXMuZWRpdG9yLkNvZGVNYW5hZ2VyLmdldENvZGUodGhpcy5jb21wb25lbnQsICdjc3MnLCB7XHJcbiAgICAgICAgICAgICAgICBjc3NjOiB0aGlzLmVkaXRvci5Dc3NDb21wb3NlclxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldENvbXBvbmVudEh0bWwoY29tcG9uZW50KSB7XHJcbiAgICAgICAgY29uc3QgeyBwZngsIG9wdHMgfSA9IHRoaXM7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xyXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudEVsID0gY29tcG9uZW50LmdldEVsKCk7XHJcblxyXG4gICAgICAgICFvcHRzLmNsZWFyRGF0YSAmJiBjb21wb25lbnRFbC5jbGFzc0xpc3QucmVtb3ZlKGAke3BmeH1zZWxlY3RlZGApO1xyXG4gICAgICAgIGNvbnN0IGh0bWwgPSBvcHRzLmNsZWFyRGF0YSA/IGNvbXBvbmVudC50b0hUTUwoKSA6XHJcbiAgICAgICAgICAgIChjb21wb25lbnRFbC5pZCA9PT0gJ3dyYXBwZXInID8gY29tcG9uZW50RWwuaW5uZXJIVE1MIDogY29tcG9uZW50RWwub3V0ZXJIVE1MKTtcclxuICAgICAgICAhb3B0cy5jbGVhckRhdGEgJiYgY29tcG9uZW50RWwuY2xhc3NMaXN0LmFkZChgJHtwZnh9c2VsZWN0ZWRgKTtcclxuICAgICAgICByZXN1bHQgKz0gaHRtbDtcclxuXHJcbiAgICAgICAgY29uc3QganMgPSBvcHRzLmVkaXRKcyA/IGNvbXBvbmVudC5nZXRTY3JpcHRTdHJpbmcoKSA6ICcnO1xyXG4gICAgICAgIHJlc3VsdCArPSBqcyA/IGA8c2NyaXB0PiR7anN9PC9zY3JpcHQ+YCA6ICcnO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/vendor/Onix/js/codeEditor/code-editor/index.js\n");

/***/ }),

/***/ "./resources/vendor/Onix/js/codeEditor/commands.js":
/*!*********************************************************!*\
  !*** ./resources/vendor/Onix/js/codeEditor/commands.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _code_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./code-editor */ \"./resources/vendor/Onix/js/codeEditor/code-editor/index.js\");\n/* harmony import */ var _consts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./consts */ \"./resources/vendor/Onix/js/codeEditor/consts.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function (editor, opts) {\n  var cm = editor.Commands;\n  var codeEditor = null;\n  cm.add(_consts__WEBPACK_IMPORTED_MODULE_1__.openCodeStr, {\n    run: function run(editor) {\n      !codeEditor && (codeEditor = new _code_editor__WEBPACK_IMPORTED_MODULE_0__.CodeEditor(editor, opts)) && codeEditor.buildCodePanel();\n      codeEditor.showCodePanel();\n    },\n    stop: function stop(editor) {\n      codeEditor && codeEditor.hideCodePanel();\n    }\n  });\n  cm.add(_consts__WEBPACK_IMPORTED_MODULE_1__.getObject, function (editor, sender) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return new _code_editor__WEBPACK_IMPORTED_MODULE_0__.CodeEditor(editor, _objectSpread(_objectSpread({}, options), opts));\n  });\n  cm.add(_consts__WEBPACK_IMPORTED_MODULE_1__.getConstuctor, function () {\n    return _code_editor__WEBPACK_IMPORTED_MODULE_0__.CodeEditor;\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdmVuZG9yL09uaXgvanMvY29kZUVkaXRvci9jb21tYW5kcy5qcz9lMjhhIl0sIm5hbWVzIjpbImVkaXRvciIsIm9wdHMiLCJjbSIsIkNvbW1hbmRzIiwiY29kZUVkaXRvciIsImFkZCIsIm9wZW5Db2RlU3RyIiwicnVuIiwiQ29kZUVkaXRvciIsImJ1aWxkQ29kZVBhbmVsIiwic2hvd0NvZGVQYW5lbCIsInN0b3AiLCJoaWRlQ29kZVBhbmVsIiwiZ2V0T2JqZWN0Iiwic2VuZGVyIiwib3B0aW9ucyIsImdldENvbnN0dWN0b3IiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFFQSxpRUFBZSxVQUFDQSxNQUFELEVBQVNDLElBQVQsRUFBa0I7QUFDN0IsTUFBTUMsRUFBRSxHQUFHRixNQUFNLENBQUNHLFFBQWxCO0FBQ0EsTUFBSUMsVUFBVSxHQUFHLElBQWpCO0FBRUFGLElBQUUsQ0FBQ0csR0FBSCxDQUFPQyxnREFBUCxFQUFvQjtBQUNoQkMsT0FBRyxFQUFFLGFBQUFQLE1BQU0sRUFBSTtBQUNYLE9BQUNJLFVBQUQsS0FBZ0JBLFVBQVUsR0FBRyxJQUFJSSxvREFBSixDQUFlUixNQUFmLEVBQXVCQyxJQUF2QixDQUE3QixLQUE4REcsVUFBVSxDQUFDSyxjQUFYLEVBQTlEO0FBQ0FMLGdCQUFVLENBQUNNLGFBQVg7QUFDSCxLQUplO0FBS2hCQyxRQUFJLEVBQUUsY0FBQVgsTUFBTSxFQUFJO0FBQ1pJLGdCQUFVLElBQUlBLFVBQVUsQ0FBQ1EsYUFBWCxFQUFkO0FBQ0g7QUFQZSxHQUFwQjtBQVVBVixJQUFFLENBQUNHLEdBQUgsQ0FBT1EsOENBQVAsRUFBa0IsVUFBQ2IsTUFBRCxFQUFTYyxNQUFULEVBQWtDO0FBQUEsUUFBakJDLE9BQWlCLHVFQUFQLEVBQU87QUFDaEQsV0FBTyxJQUFJUCxvREFBSixDQUFlUixNQUFmLGtDQUE0QmUsT0FBNUIsR0FBd0NkLElBQXhDLEVBQVA7QUFDSCxHQUZEO0FBSUFDLElBQUUsQ0FBQ0csR0FBSCxDQUFPVyxrREFBUCxFQUFzQixZQUFNO0FBQ3hCLFdBQU9SLG9EQUFQO0FBQ0gsR0FGRDtBQUdILENBckJEIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL3ZlbmRvci9Pbml4L2pzL2NvZGVFZGl0b3IvY29tbWFuZHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2RlRWRpdG9yIH0gZnJvbSAnLi9jb2RlLWVkaXRvcic7XHJcbmltcG9ydCB7IG9wZW5Db2RlU3RyLCBnZXRPYmplY3QsIGdldENvbnN0dWN0b3IgfSBmcm9tICcuL2NvbnN0cyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCAoZWRpdG9yLCBvcHRzKSA9PiB7XHJcbiAgICBjb25zdCBjbSA9IGVkaXRvci5Db21tYW5kcztcclxuICAgIGxldCBjb2RlRWRpdG9yID0gbnVsbDtcclxuXHJcbiAgICBjbS5hZGQob3BlbkNvZGVTdHIsIHtcclxuICAgICAgICBydW46IGVkaXRvciA9PiB7XHJcbiAgICAgICAgICAgICFjb2RlRWRpdG9yICYmIChjb2RlRWRpdG9yID0gbmV3IENvZGVFZGl0b3IoZWRpdG9yLCBvcHRzKSkgJiYgY29kZUVkaXRvci5idWlsZENvZGVQYW5lbCgpO1xyXG4gICAgICAgICAgICBjb2RlRWRpdG9yLnNob3dDb2RlUGFuZWwoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0b3A6IGVkaXRvciA9PiB7XHJcbiAgICAgICAgICAgIGNvZGVFZGl0b3IgJiYgY29kZUVkaXRvci5oaWRlQ29kZVBhbmVsKCk7XHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIGNtLmFkZChnZXRPYmplY3QsIChlZGl0b3IsIHNlbmRlciwgb3B0aW9ucyA9IHt9KSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2RlRWRpdG9yKGVkaXRvciwgeyAuLi5vcHRpb25zLCAuLi5vcHRzIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY20uYWRkKGdldENvbnN0dWN0b3IsICgpID0+IHtcclxuICAgICAgICByZXR1cm4gQ29kZUVkaXRvcjtcclxuICAgIH0pO1xyXG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/vendor/Onix/js/codeEditor/commands.js\n");

/***/ }),

/***/ "./resources/vendor/Onix/js/codeEditor/consts.js":
/*!*******************************************************!*\
  !*** ./resources/vendor/Onix/js/codeEditor/consts.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"openCodeStr\": () => (/* binding */ openCodeStr),\n/* harmony export */   \"getObject\": () => (/* binding */ getObject),\n/* harmony export */   \"getConstuctor\": () => (/* binding */ getConstuctor)\n/* harmony export */ });\nvar openCodeStr = 'open-code',\n    getObject = 'code-editor-object',\n    getConstuctor = 'code-editor-constructor';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdmVuZG9yL09uaXgvanMvY29kZUVkaXRvci9jb25zdHMuanM/MWI5ZiJdLCJuYW1lcyI6WyJvcGVuQ29kZVN0ciIsImdldE9iamVjdCIsImdldENvbnN0dWN0b3IiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFPLElBQ0hBLFdBQVcsR0FBRyxXQURYO0FBQUEsSUFFSEMsU0FBUyxHQUFHLG9CQUZUO0FBQUEsSUFHSEMsYUFBYSxHQUFHLHlCQUhiIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL3ZlbmRvci9Pbml4L2pzL2NvZGVFZGl0b3IvY29uc3RzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0XHJcbiAgICBvcGVuQ29kZVN0ciA9ICdvcGVuLWNvZGUnLFxyXG4gICAgZ2V0T2JqZWN0ID0gJ2NvZGUtZWRpdG9yLW9iamVjdCcsXHJcbiAgICBnZXRDb25zdHVjdG9yID0gJ2NvZGUtZWRpdG9yLWNvbnN0cnVjdG9yJzsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/vendor/Onix/js/codeEditor/consts.js\n");

/***/ }),

/***/ "./resources/vendor/Onix/js/codeEditor/grapeCodeEditor.js":
/*!****************************************************************!*\
  !*** ./resources/vendor/Onix/js/codeEditor/grapeCodeEditor.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _commands__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commands */ \"./resources/vendor/Onix/js/codeEditor/commands.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\nwindow.grapesjs.plugins.add('code-editor', function (editor) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var options = _objectSpread(_objectSpread({}, {\n    //Panel to append the code editor\n    panelId: 'views-container',\n    //Append to element instead of views-container\n    appendTo: '',\n    //State when open\n    openState: {\n      cv: '65%',\n      pn: '35%'\n    },\n    //State when closed\n    closedState: {\n      cv: '85%',\n      pn: '15%'\n    },\n    //Allow editing of javascript, set allowScripts to true for this to work\n    editJs: false,\n    //Remove component data eg data-gjs-type=\"...\"\n    clearData: false,\n    //Code viewer options\n    codeViewOptions: {},\n    //Used to remove css from the Selector Manager\n    cleanCssBtn: true,\n    //Save HTML button text\n    htmlBtnText: 'Apply',\n    //Save CSS button text\n    cssBtnText: 'Apply',\n    //Clean CSS button text\n    cleanCssBtnText: 'Delete'\n  }), opts); // Load commands\n\n\n  (0,_commands__WEBPACK_IMPORTED_MODULE_0__.default)(editor, options);\n}); // export default (editor, opts = {}) => {\n//     const options = {\n//         ...{\n//             //Panel to append the code editor\n//             panelId: 'views-container',\n//             //Append to element instead of views-container\n//             appendTo: '',\n//             //State when open\n//             openState: {\n//                 cv: '65%',\n//                 pn: '35%'\n//             },\n//             //State when closed\n//             closedState: {\n//                 cv: '85%',\n//                 pn: '15%'\n//             },\n//             //Allow editing of javascript, set allowScripts to true for this to work\n//             editJs: false,\n//             //Remove component data eg data-gjs-type=\"...\"\n//             clearData: false,\n//             //Code viewer options\n//             codeViewOptions: {},\n//             //Used to remove css from the Selector Manager\n//             cleanCssBtn: true,\n//             //Save HTML button text\n//             htmlBtnText: 'Apply',\n//             //Save CSS button text\n//             cssBtnText: 'Apply',\n//             //Clean CSS button text\n//             cleanCssBtnText: 'Delete'\n//         },\n//         ...opts\n//     };\n//     // Load commands\n//     commands(editor, options);\n// };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdmVuZG9yL09uaXgvanMvY29kZUVkaXRvci9ncmFwZUNvZGVFZGl0b3IuanM/ZWEyZiJdLCJuYW1lcyI6WyJ3aW5kb3ciLCJncmFwZXNqcyIsInBsdWdpbnMiLCJhZGQiLCJlZGl0b3IiLCJvcHRzIiwib3B0aW9ucyIsInBhbmVsSWQiLCJhcHBlbmRUbyIsIm9wZW5TdGF0ZSIsImN2IiwicG4iLCJjbG9zZWRTdGF0ZSIsImVkaXRKcyIsImNsZWFyRGF0YSIsImNvZGVWaWV3T3B0aW9ucyIsImNsZWFuQ3NzQnRuIiwiaHRtbEJ0blRleHQiLCJjc3NCdG5UZXh0IiwiY2xlYW5Dc3NCdG5UZXh0IiwiY29tbWFuZHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFJQUEsTUFBTSxDQUFDQyxRQUFQLENBQWdCQyxPQUFoQixDQUF3QkMsR0FBeEIsQ0FBNEIsYUFBNUIsRUFBMkMsVUFBQ0MsTUFBRCxFQUF1QjtBQUFBLE1BQWRDLElBQWMsdUVBQVAsRUFBTzs7QUFDOUQsTUFBTUMsT0FBTyxtQ0FDTjtBQUNDO0FBQ0FDLFdBQU8sRUFBRSxpQkFGVjtBQUdDO0FBQ0FDLFlBQVEsRUFBRSxFQUpYO0FBS0M7QUFDQUMsYUFBUyxFQUFFO0FBQ1BDLFFBQUUsRUFBRSxLQURHO0FBRVBDLFFBQUUsRUFBRTtBQUZHLEtBTlo7QUFVQztBQUNBQyxlQUFXLEVBQUU7QUFDVEYsUUFBRSxFQUFFLEtBREs7QUFFVEMsUUFBRSxFQUFFO0FBRkssS0FYZDtBQWVDO0FBQ0FFLFVBQU0sRUFBRSxLQWhCVDtBQWlCQztBQUNBQyxhQUFTLEVBQUUsS0FsQlo7QUFtQkM7QUFDQUMsbUJBQWUsRUFBRSxFQXBCbEI7QUFxQkM7QUFDQUMsZUFBVyxFQUFFLElBdEJkO0FBdUJDO0FBQ0FDLGVBQVcsRUFBRSxPQXhCZDtBQXlCQztBQUNBQyxjQUFVLEVBQUUsT0ExQmI7QUEyQkM7QUFDQUMsbUJBQWUsRUFBRTtBQTVCbEIsR0FETSxHQStCTmQsSUEvQk0sQ0FBYixDQUQ4RCxDQW1DOUQ7OztBQUNBZSxvREFBUSxDQUFDaEIsTUFBRCxFQUFTRSxPQUFULENBQVI7QUFDSCxDQXJDRCxFLENBdUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL3ZlbmRvci9Pbml4L2pzL2NvZGVFZGl0b3IvZ3JhcGVDb2RlRWRpdG9yLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNvbW1hbmRzIGZyb20gJy4vY29tbWFuZHMnO1xuXG5cblxud2luZG93LmdyYXBlc2pzLnBsdWdpbnMuYWRkKCdjb2RlLWVkaXRvcicsIChlZGl0b3IsIG9wdHMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIC4uLntcbiAgICAgICAgICAgIC8vUGFuZWwgdG8gYXBwZW5kIHRoZSBjb2RlIGVkaXRvclxuICAgICAgICAgICAgcGFuZWxJZDogJ3ZpZXdzLWNvbnRhaW5lcicsXG4gICAgICAgICAgICAvL0FwcGVuZCB0byBlbGVtZW50IGluc3RlYWQgb2Ygdmlld3MtY29udGFpbmVyXG4gICAgICAgICAgICBhcHBlbmRUbzogJycsXG4gICAgICAgICAgICAvL1N0YXRlIHdoZW4gb3BlblxuICAgICAgICAgICAgb3BlblN0YXRlOiB7XG4gICAgICAgICAgICAgICAgY3Y6ICc2NSUnLFxuICAgICAgICAgICAgICAgIHBuOiAnMzUlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vU3RhdGUgd2hlbiBjbG9zZWRcbiAgICAgICAgICAgIGNsb3NlZFN0YXRlOiB7XG4gICAgICAgICAgICAgICAgY3Y6ICc4NSUnLFxuICAgICAgICAgICAgICAgIHBuOiAnMTUlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vQWxsb3cgZWRpdGluZyBvZiBqYXZhc2NyaXB0LCBzZXQgYWxsb3dTY3JpcHRzIHRvIHRydWUgZm9yIHRoaXMgdG8gd29ya1xuICAgICAgICAgICAgZWRpdEpzOiBmYWxzZSxcbiAgICAgICAgICAgIC8vUmVtb3ZlIGNvbXBvbmVudCBkYXRhIGVnIGRhdGEtZ2pzLXR5cGU9XCIuLi5cIlxuICAgICAgICAgICAgY2xlYXJEYXRhOiBmYWxzZSxcbiAgICAgICAgICAgIC8vQ29kZSB2aWV3ZXIgb3B0aW9uc1xuICAgICAgICAgICAgY29kZVZpZXdPcHRpb25zOiB7fSxcbiAgICAgICAgICAgIC8vVXNlZCB0byByZW1vdmUgY3NzIGZyb20gdGhlIFNlbGVjdG9yIE1hbmFnZXJcbiAgICAgICAgICAgIGNsZWFuQ3NzQnRuOiB0cnVlLFxuICAgICAgICAgICAgLy9TYXZlIEhUTUwgYnV0dG9uIHRleHRcbiAgICAgICAgICAgIGh0bWxCdG5UZXh0OiAnQXBwbHknLFxuICAgICAgICAgICAgLy9TYXZlIENTUyBidXR0b24gdGV4dFxuICAgICAgICAgICAgY3NzQnRuVGV4dDogJ0FwcGx5JyxcbiAgICAgICAgICAgIC8vQ2xlYW4gQ1NTIGJ1dHRvbiB0ZXh0XG4gICAgICAgICAgICBjbGVhbkNzc0J0blRleHQ6ICdEZWxldGUnXG4gICAgICAgIH0sXG4gICAgICAgIC4uLm9wdHNcbiAgICB9O1xuXG4gICAgLy8gTG9hZCBjb21tYW5kc1xuICAgIGNvbW1hbmRzKGVkaXRvciwgb3B0aW9ucyk7XG59KTtcblxuLy8gZXhwb3J0IGRlZmF1bHQgKGVkaXRvciwgb3B0cyA9IHt9KSA9PiB7XG4vLyAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbi8vICAgICAgICAgLi4ue1xuLy8gICAgICAgICAgICAgLy9QYW5lbCB0byBhcHBlbmQgdGhlIGNvZGUgZWRpdG9yXG4vLyAgICAgICAgICAgICBwYW5lbElkOiAndmlld3MtY29udGFpbmVyJyxcbi8vICAgICAgICAgICAgIC8vQXBwZW5kIHRvIGVsZW1lbnQgaW5zdGVhZCBvZiB2aWV3cy1jb250YWluZXJcbi8vICAgICAgICAgICAgIGFwcGVuZFRvOiAnJyxcbi8vICAgICAgICAgICAgIC8vU3RhdGUgd2hlbiBvcGVuXG4vLyAgICAgICAgICAgICBvcGVuU3RhdGU6IHtcbi8vICAgICAgICAgICAgICAgICBjdjogJzY1JScsXG4vLyAgICAgICAgICAgICAgICAgcG46ICczNSUnXG4vLyAgICAgICAgICAgICB9LFxuLy8gICAgICAgICAgICAgLy9TdGF0ZSB3aGVuIGNsb3NlZFxuLy8gICAgICAgICAgICAgY2xvc2VkU3RhdGU6IHtcbi8vICAgICAgICAgICAgICAgICBjdjogJzg1JScsXG4vLyAgICAgICAgICAgICAgICAgcG46ICcxNSUnXG4vLyAgICAgICAgICAgICB9LFxuLy8gICAgICAgICAgICAgLy9BbGxvdyBlZGl0aW5nIG9mIGphdmFzY3JpcHQsIHNldCBhbGxvd1NjcmlwdHMgdG8gdHJ1ZSBmb3IgdGhpcyB0byB3b3JrXG4vLyAgICAgICAgICAgICBlZGl0SnM6IGZhbHNlLFxuLy8gICAgICAgICAgICAgLy9SZW1vdmUgY29tcG9uZW50IGRhdGEgZWcgZGF0YS1nanMtdHlwZT1cIi4uLlwiXG4vLyAgICAgICAgICAgICBjbGVhckRhdGE6IGZhbHNlLFxuLy8gICAgICAgICAgICAgLy9Db2RlIHZpZXdlciBvcHRpb25zXG4vLyAgICAgICAgICAgICBjb2RlVmlld09wdGlvbnM6IHt9LFxuLy8gICAgICAgICAgICAgLy9Vc2VkIHRvIHJlbW92ZSBjc3MgZnJvbSB0aGUgU2VsZWN0b3IgTWFuYWdlclxuLy8gICAgICAgICAgICAgY2xlYW5Dc3NCdG46IHRydWUsXG4vLyAgICAgICAgICAgICAvL1NhdmUgSFRNTCBidXR0b24gdGV4dFxuLy8gICAgICAgICAgICAgaHRtbEJ0blRleHQ6ICdBcHBseScsXG4vLyAgICAgICAgICAgICAvL1NhdmUgQ1NTIGJ1dHRvbiB0ZXh0XG4vLyAgICAgICAgICAgICBjc3NCdG5UZXh0OiAnQXBwbHknLFxuLy8gICAgICAgICAgICAgLy9DbGVhbiBDU1MgYnV0dG9uIHRleHRcbi8vICAgICAgICAgICAgIGNsZWFuQ3NzQnRuVGV4dDogJ0RlbGV0ZSdcbi8vICAgICAgICAgfSxcbi8vICAgICAgICAgLi4ub3B0c1xuLy8gICAgIH07XG5cbi8vICAgICAvLyBMb2FkIGNvbW1hbmRzXG4vLyAgICAgY29tbWFuZHMoZWRpdG9yLCBvcHRpb25zKTtcbi8vIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/vendor/Onix/js/codeEditor/grapeCodeEditor.js\n");

/***/ }),

/***/ "./node_modules/split.js/dist/split.es.js":
/*!************************************************!*\
  !*** ./node_modules/split.js/dist/split.es.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// The programming goals of Split.js are to deliver readable, understandable and\n// maintainable code, while at the same time manually optimizing for tiny minified file size,\n// browser compatibility without additional requirements\n// and very few assumptions about the user's page layout.\nvar global = typeof window !== 'undefined' ? window : null;\nvar ssr = global === null;\nvar document = !ssr ? global.document : undefined;\n\n// Save a couple long function names that are used frequently.\n// This optimization saves around 400 bytes.\nvar addEventListener = 'addEventListener';\nvar removeEventListener = 'removeEventListener';\nvar getBoundingClientRect = 'getBoundingClientRect';\nvar gutterStartDragging = '_a';\nvar aGutterSize = '_b';\nvar bGutterSize = '_c';\nvar HORIZONTAL = 'horizontal';\nvar NOOP = function () { return false; };\n\n// Helper function determines which prefixes of CSS calc we need.\n// We only need to do this once on startup, when this anonymous function is called.\n//\n// Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\n// http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\nvar calc = ssr\n    ? 'calc'\n    : ((['', '-webkit-', '-moz-', '-o-']\n          .filter(function (prefix) {\n              var el = document.createElement('div');\n              el.style.cssText = \"width:\" + prefix + \"calc(9px)\";\n\n              return !!el.style.length\n          })\n          .shift()) + \"calc\");\n\n// Helper function checks if its argument is a string-like type\nvar isString = function (v) { return typeof v === 'string' || v instanceof String; };\n\n// Helper function allows elements and string selectors to be used\n// interchangeably. In either case an element is returned. This allows us to\n// do `Split([elem1, elem2])` as well as `Split(['#id1', '#id2'])`.\nvar elementOrSelector = function (el) {\n    if (isString(el)) {\n        var ele = document.querySelector(el);\n        if (!ele) {\n            throw new Error((\"Selector \" + el + \" did not match a DOM element\"))\n        }\n        return ele\n    }\n\n    return el\n};\n\n// Helper function gets a property from the properties object, with a default fallback\nvar getOption = function (options, propName, def) {\n    var value = options[propName];\n    if (value !== undefined) {\n        return value\n    }\n    return def\n};\n\nvar getGutterSize = function (gutterSize, isFirst, isLast, gutterAlign) {\n    if (isFirst) {\n        if (gutterAlign === 'end') {\n            return 0\n        }\n        if (gutterAlign === 'center') {\n            return gutterSize / 2\n        }\n    } else if (isLast) {\n        if (gutterAlign === 'start') {\n            return 0\n        }\n        if (gutterAlign === 'center') {\n            return gutterSize / 2\n        }\n    }\n\n    return gutterSize\n};\n\n// Default options\nvar defaultGutterFn = function (i, gutterDirection) {\n    var gut = document.createElement('div');\n    gut.className = \"gutter gutter-\" + gutterDirection;\n    return gut\n};\n\nvar defaultElementStyleFn = function (dim, size, gutSize) {\n    var style = {};\n\n    if (!isString(size)) {\n        style[dim] = calc + \"(\" + size + \"% - \" + gutSize + \"px)\";\n    } else {\n        style[dim] = size;\n    }\n\n    return style\n};\n\nvar defaultGutterStyleFn = function (dim, gutSize) {\n    var obj;\n\n    return (( obj = {}, obj[dim] = (gutSize + \"px\"), obj ));\n};\n\n// The main function to initialize a split. Split.js thinks about each pair\n// of elements as an independant pair. Dragging the gutter between two elements\n// only changes the dimensions of elements in that pair. This is key to understanding\n// how the following functions operate, since each function is bound to a pair.\n//\n// A pair object is shaped like this:\n//\n// {\n//     a: DOM element,\n//     b: DOM element,\n//     aMin: Number,\n//     bMin: Number,\n//     dragging: Boolean,\n//     parent: DOM element,\n//     direction: 'horizontal' | 'vertical'\n// }\n//\n// The basic sequence:\n//\n// 1. Set defaults to something sane. `options` doesn't have to be passed at all.\n// 2. Initialize a bunch of strings based on the direction we're splitting.\n//    A lot of the behavior in the rest of the library is paramatized down to\n//    rely on CSS strings and classes.\n// 3. Define the dragging helper functions, and a few helpers to go with them.\n// 4. Loop through the elements while pairing them off. Every pair gets an\n//    `pair` object and a gutter.\n// 5. Actually size the pair elements, insert gutters and attach event listeners.\nvar Split = function (idsOption, options) {\n    if ( options === void 0 ) options = {};\n\n    if (ssr) { return {} }\n\n    var ids = idsOption;\n    var dimension;\n    var clientAxis;\n    var position;\n    var positionEnd;\n    var clientSize;\n    var elements;\n\n    // Allow HTMLCollection to be used as an argument when supported\n    if (Array.from) {\n        ids = Array.from(ids);\n    }\n\n    // All DOM elements in the split should have a common parent. We can grab\n    // the first elements parent and hope users read the docs because the\n    // behavior will be whacky otherwise.\n    var firstElement = elementOrSelector(ids[0]);\n    var parent = firstElement.parentNode;\n    var parentStyle = getComputedStyle ? getComputedStyle(parent) : null;\n    var parentFlexDirection = parentStyle ? parentStyle.flexDirection : null;\n\n    // Set default options.sizes to equal percentages of the parent element.\n    var sizes = getOption(options, 'sizes') || ids.map(function () { return 100 / ids.length; });\n\n    // Standardize minSize and maxSize to an array if it isn't already.\n    // This allows minSize and maxSize to be passed as a number.\n    var minSize = getOption(options, 'minSize', 100);\n    var minSizes = Array.isArray(minSize) ? minSize : ids.map(function () { return minSize; });\n    var maxSize = getOption(options, 'maxSize', Infinity);\n    var maxSizes = Array.isArray(maxSize) ? maxSize : ids.map(function () { return maxSize; });\n\n    // Get other options\n    var expandToMin = getOption(options, 'expandToMin', false);\n    var gutterSize = getOption(options, 'gutterSize', 10);\n    var gutterAlign = getOption(options, 'gutterAlign', 'center');\n    var snapOffset = getOption(options, 'snapOffset', 30);\n    var dragInterval = getOption(options, 'dragInterval', 1);\n    var direction = getOption(options, 'direction', HORIZONTAL);\n    var cursor = getOption(\n        options,\n        'cursor',\n        direction === HORIZONTAL ? 'col-resize' : 'row-resize'\n    );\n    var gutter = getOption(options, 'gutter', defaultGutterFn);\n    var elementStyle = getOption(\n        options,\n        'elementStyle',\n        defaultElementStyleFn\n    );\n    var gutterStyle = getOption(options, 'gutterStyle', defaultGutterStyleFn);\n\n    // 2. Initialize a bunch of strings based on the direction we're splitting.\n    // A lot of the behavior in the rest of the library is paramatized down to\n    // rely on CSS strings and classes.\n    if (direction === HORIZONTAL) {\n        dimension = 'width';\n        clientAxis = 'clientX';\n        position = 'left';\n        positionEnd = 'right';\n        clientSize = 'clientWidth';\n    } else if (direction === 'vertical') {\n        dimension = 'height';\n        clientAxis = 'clientY';\n        position = 'top';\n        positionEnd = 'bottom';\n        clientSize = 'clientHeight';\n    }\n\n    // 3. Define the dragging helper functions, and a few helpers to go with them.\n    // Each helper is bound to a pair object that contains its metadata. This\n    // also makes it easy to store references to listeners that that will be\n    // added and removed.\n    //\n    // Even though there are no other functions contained in them, aliasing\n    // this to self saves 50 bytes or so since it's used so frequently.\n    //\n    // The pair object saves metadata like dragging state, position and\n    // event listener references.\n\n    function setElementSize(el, size, gutSize, i) {\n        // Split.js allows setting sizes via numbers (ideally), or if you must,\n        // by string, like '300px'. This is less than ideal, because it breaks\n        // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\n        // make sure you calculate the gutter size by hand.\n        var style = elementStyle(dimension, size, gutSize, i);\n\n        Object.keys(style).forEach(function (prop) {\n            // eslint-disable-next-line no-param-reassign\n            el.style[prop] = style[prop];\n        });\n    }\n\n    function setGutterSize(gutterElement, gutSize, i) {\n        var style = gutterStyle(dimension, gutSize, i);\n\n        Object.keys(style).forEach(function (prop) {\n            // eslint-disable-next-line no-param-reassign\n            gutterElement.style[prop] = style[prop];\n        });\n    }\n\n    function getSizes() {\n        return elements.map(function (element) { return element.size; })\n    }\n\n    // Supports touch events, but not multitouch, so only the first\n    // finger `touches[0]` is counted.\n    function getMousePosition(e) {\n        if ('touches' in e) { return e.touches[0][clientAxis] }\n        return e[clientAxis]\n    }\n\n    // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\n    // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\n    // which allows the viewport to be resized without additional logic.\n    // Element a's size is the same as offset. b's size is total size - a size.\n    // Both sizes are calculated from the initial parent percentage,\n    // then the gutter size is subtracted.\n    function adjust(offset) {\n        var a = elements[this.a];\n        var b = elements[this.b];\n        var percentage = a.size + b.size;\n\n        a.size = (offset / this.size) * percentage;\n        b.size = percentage - (offset / this.size) * percentage;\n\n        setElementSize(a.element, a.size, this[aGutterSize], a.i);\n        setElementSize(b.element, b.size, this[bGutterSize], b.i);\n    }\n\n    // drag, where all the magic happens. The logic is really quite simple:\n    //\n    // 1. Ignore if the pair is not dragging.\n    // 2. Get the offset of the event.\n    // 3. Snap offset to min if within snappable range (within min + snapOffset).\n    // 4. Actually adjust each element in the pair to offset.\n    //\n    // ---------------------------------------------------------------------\n    // |    | <- a.minSize               ||              b.minSize -> |    |\n    // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\n    // |    |  |                         ||                        |  |    |\n    // |    |  |                         ||                        |  |    |\n    // ---------------------------------------------------------------------\n    // | <- this.start                                        this.size -> |\n    function drag(e) {\n        var offset;\n        var a = elements[this.a];\n        var b = elements[this.b];\n\n        if (!this.dragging) { return }\n\n        // Get the offset of the event from the first side of the\n        // pair `this.start`. Then offset by the initial position of the\n        // mouse compared to the gutter size.\n        offset =\n            getMousePosition(e) -\n            this.start +\n            (this[aGutterSize] - this.dragOffset);\n\n        if (dragInterval > 1) {\n            offset = Math.round(offset / dragInterval) * dragInterval;\n        }\n\n        // If within snapOffset of min or max, set offset to min or max.\n        // snapOffset buffers a.minSize and b.minSize, so logic is opposite for both.\n        // Include the appropriate gutter sizes to prevent overflows.\n        if (offset <= a.minSize + snapOffset + this[aGutterSize]) {\n            offset = a.minSize + this[aGutterSize];\n        } else if (\n            offset >=\n            this.size - (b.minSize + snapOffset + this[bGutterSize])\n        ) {\n            offset = this.size - (b.minSize + this[bGutterSize]);\n        }\n\n        if (offset >= a.maxSize - snapOffset + this[aGutterSize]) {\n            offset = a.maxSize + this[aGutterSize];\n        } else if (\n            offset <=\n            this.size - (b.maxSize - snapOffset + this[bGutterSize])\n        ) {\n            offset = this.size - (b.maxSize + this[bGutterSize]);\n        }\n\n        // Actually adjust the size.\n        adjust.call(this, offset);\n\n        // Call the drag callback continously. Don't do anything too intensive\n        // in this callback.\n        getOption(options, 'onDrag', NOOP)(getSizes());\n    }\n\n    // Cache some important sizes when drag starts, so we don't have to do that\n    // continously:\n    //\n    // `size`: The total size of the pair. First + second + first gutter + second gutter.\n    // `start`: The leading side of the first element.\n    //\n    // ------------------------------------------------\n    // |      aGutterSize -> |||                      |\n    // |                     |||                      |\n    // |                     |||                      |\n    // |                     ||| <- bGutterSize       |\n    // ------------------------------------------------\n    // | <- start                             size -> |\n    function calculateSizes() {\n        // Figure out the parent size minus padding.\n        var a = elements[this.a].element;\n        var b = elements[this.b].element;\n\n        var aBounds = a[getBoundingClientRect]();\n        var bBounds = b[getBoundingClientRect]();\n\n        this.size =\n            aBounds[dimension] +\n            bBounds[dimension] +\n            this[aGutterSize] +\n            this[bGutterSize];\n        this.start = aBounds[position];\n        this.end = aBounds[positionEnd];\n    }\n\n    function innerSize(element) {\n        // Return nothing if getComputedStyle is not supported (< IE9)\n        // Or if parent element has no layout yet\n        if (!getComputedStyle) { return null }\n\n        var computedStyle = getComputedStyle(element);\n\n        if (!computedStyle) { return null }\n\n        var size = element[clientSize];\n\n        if (size === 0) { return null }\n\n        if (direction === HORIZONTAL) {\n            size -=\n                parseFloat(computedStyle.paddingLeft) +\n                parseFloat(computedStyle.paddingRight);\n        } else {\n            size -=\n                parseFloat(computedStyle.paddingTop) +\n                parseFloat(computedStyle.paddingBottom);\n        }\n\n        return size\n    }\n\n    // When specifying percentage sizes that are less than the computed\n    // size of the element minus the gutter, the lesser percentages must be increased\n    // (and decreased from the other elements) to make space for the pixels\n    // subtracted by the gutters.\n    function trimToMin(sizesToTrim) {\n        // Try to get inner size of parent element.\n        // If it's no supported, return original sizes.\n        var parentSize = innerSize(parent);\n        if (parentSize === null) {\n            return sizesToTrim\n        }\n\n        if (minSizes.reduce(function (a, b) { return a + b; }, 0) > parentSize) {\n            return sizesToTrim\n        }\n\n        // Keep track of the excess pixels, the amount of pixels over the desired percentage\n        // Also keep track of the elements with pixels to spare, to decrease after if needed\n        var excessPixels = 0;\n        var toSpare = [];\n\n        var pixelSizes = sizesToTrim.map(function (size, i) {\n            // Convert requested percentages to pixel sizes\n            var pixelSize = (parentSize * size) / 100;\n            var elementGutterSize = getGutterSize(\n                gutterSize,\n                i === 0,\n                i === sizesToTrim.length - 1,\n                gutterAlign\n            );\n            var elementMinSize = minSizes[i] + elementGutterSize;\n\n            // If element is too smal, increase excess pixels by the difference\n            // and mark that it has no pixels to spare\n            if (pixelSize < elementMinSize) {\n                excessPixels += elementMinSize - pixelSize;\n                toSpare.push(0);\n                return elementMinSize\n            }\n\n            // Otherwise, mark the pixels it has to spare and return it's original size\n            toSpare.push(pixelSize - elementMinSize);\n            return pixelSize\n        });\n\n        // If nothing was adjusted, return the original sizes\n        if (excessPixels === 0) {\n            return sizesToTrim\n        }\n\n        return pixelSizes.map(function (pixelSize, i) {\n            var newPixelSize = pixelSize;\n\n            // While there's still pixels to take, and there's enough pixels to spare,\n            // take as many as possible up to the total excess pixels\n            if (excessPixels > 0 && toSpare[i] - excessPixels > 0) {\n                var takenPixels = Math.min(\n                    excessPixels,\n                    toSpare[i] - excessPixels\n                );\n\n                // Subtract the amount taken for the next iteration\n                excessPixels -= takenPixels;\n                newPixelSize = pixelSize - takenPixels;\n            }\n\n            // Return the pixel size adjusted as a percentage\n            return (newPixelSize / parentSize) * 100\n        })\n    }\n\n    // stopDragging is very similar to startDragging in reverse.\n    function stopDragging() {\n        var self = this;\n        var a = elements[self.a].element;\n        var b = elements[self.b].element;\n\n        if (self.dragging) {\n            getOption(options, 'onDragEnd', NOOP)(getSizes());\n        }\n\n        self.dragging = false;\n\n        // Remove the stored event listeners. This is why we store them.\n        global[removeEventListener]('mouseup', self.stop);\n        global[removeEventListener]('touchend', self.stop);\n        global[removeEventListener]('touchcancel', self.stop);\n        global[removeEventListener]('mousemove', self.move);\n        global[removeEventListener]('touchmove', self.move);\n\n        // Clear bound function references\n        self.stop = null;\n        self.move = null;\n\n        a[removeEventListener]('selectstart', NOOP);\n        a[removeEventListener]('dragstart', NOOP);\n        b[removeEventListener]('selectstart', NOOP);\n        b[removeEventListener]('dragstart', NOOP);\n\n        a.style.userSelect = '';\n        a.style.webkitUserSelect = '';\n        a.style.MozUserSelect = '';\n        a.style.pointerEvents = '';\n\n        b.style.userSelect = '';\n        b.style.webkitUserSelect = '';\n        b.style.MozUserSelect = '';\n        b.style.pointerEvents = '';\n\n        self.gutter.style.cursor = '';\n        self.parent.style.cursor = '';\n        document.body.style.cursor = '';\n    }\n\n    // startDragging calls `calculateSizes` to store the inital size in the pair object.\n    // It also adds event listeners for mouse/touch events,\n    // and prevents selection while dragging so avoid the selecting text.\n    function startDragging(e) {\n        // Right-clicking can't start dragging.\n        if ('button' in e && e.button !== 0) {\n            return\n        }\n\n        // Alias frequently used variables to save space. 200 bytes.\n        var self = this;\n        var a = elements[self.a].element;\n        var b = elements[self.b].element;\n\n        // Call the onDragStart callback.\n        if (!self.dragging) {\n            getOption(options, 'onDragStart', NOOP)(getSizes());\n        }\n\n        // Don't actually drag the element. We emulate that in the drag function.\n        e.preventDefault();\n\n        // Set the dragging property of the pair object.\n        self.dragging = true;\n\n        // Create two event listeners bound to the same pair object and store\n        // them in the pair object.\n        self.move = drag.bind(self);\n        self.stop = stopDragging.bind(self);\n\n        // All the binding. `window` gets the stop events in case we drag out of the elements.\n        global[addEventListener]('mouseup', self.stop);\n        global[addEventListener]('touchend', self.stop);\n        global[addEventListener]('touchcancel', self.stop);\n        global[addEventListener]('mousemove', self.move);\n        global[addEventListener]('touchmove', self.move);\n\n        // Disable selection. Disable!\n        a[addEventListener]('selectstart', NOOP);\n        a[addEventListener]('dragstart', NOOP);\n        b[addEventListener]('selectstart', NOOP);\n        b[addEventListener]('dragstart', NOOP);\n\n        a.style.userSelect = 'none';\n        a.style.webkitUserSelect = 'none';\n        a.style.MozUserSelect = 'none';\n        a.style.pointerEvents = 'none';\n\n        b.style.userSelect = 'none';\n        b.style.webkitUserSelect = 'none';\n        b.style.MozUserSelect = 'none';\n        b.style.pointerEvents = 'none';\n\n        // Set the cursor at multiple levels\n        self.gutter.style.cursor = cursor;\n        self.parent.style.cursor = cursor;\n        document.body.style.cursor = cursor;\n\n        // Cache the initial sizes of the pair.\n        calculateSizes.call(self);\n\n        // Determine the position of the mouse compared to the gutter\n        self.dragOffset = getMousePosition(e) - self.end;\n    }\n\n    // adjust sizes to ensure percentage is within min size and gutter.\n    sizes = trimToMin(sizes);\n\n    // 5. Create pair and element objects. Each pair has an index reference to\n    // elements `a` and `b` of the pair (first and second elements).\n    // Loop through the elements while pairing them off. Every pair gets a\n    // `pair` object and a gutter.\n    //\n    // Basic logic:\n    //\n    // - Starting with the second element `i > 0`, create `pair` objects with\n    //   `a = i - 1` and `b = i`\n    // - Set gutter sizes based on the _pair_ being first/last. The first and last\n    //   pair have gutterSize / 2, since they only have one half gutter, and not two.\n    // - Create gutter elements and add event listeners.\n    // - Set the size of the elements, minus the gutter sizes.\n    //\n    // -----------------------------------------------------------------------\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\n    // |             |                     |                  |              |\n    // |           pair 0                pair 1             pair 2           |\n    // |             |                     |                  |              |\n    // -----------------------------------------------------------------------\n    var pairs = [];\n    elements = ids.map(function (id, i) {\n        // Create the element object.\n        var element = {\n            element: elementOrSelector(id),\n            size: sizes[i],\n            minSize: minSizes[i],\n            maxSize: maxSizes[i],\n            i: i,\n        };\n\n        var pair;\n\n        if (i > 0) {\n            // Create the pair object with its metadata.\n            pair = {\n                a: i - 1,\n                b: i,\n                dragging: false,\n                direction: direction,\n                parent: parent,\n            };\n\n            pair[aGutterSize] = getGutterSize(\n                gutterSize,\n                i - 1 === 0,\n                false,\n                gutterAlign\n            );\n            pair[bGutterSize] = getGutterSize(\n                gutterSize,\n                false,\n                i === ids.length - 1,\n                gutterAlign\n            );\n\n            // if the parent has a reverse flex-direction, switch the pair elements.\n            if (\n                parentFlexDirection === 'row-reverse' ||\n                parentFlexDirection === 'column-reverse'\n            ) {\n                var temp = pair.a;\n                pair.a = pair.b;\n                pair.b = temp;\n            }\n        }\n\n        // Determine the size of the current element. IE8 is supported by\n        // staticly assigning sizes without draggable gutters. Assigns a string\n        // to `size`.\n        //\n        // Create gutter elements for each pair.\n        if (i > 0) {\n            var gutterElement = gutter(i, direction, element.element);\n            setGutterSize(gutterElement, gutterSize, i);\n\n            // Save bound event listener for removal later\n            pair[gutterStartDragging] = startDragging.bind(pair);\n\n            // Attach bound event listener\n            gutterElement[addEventListener](\n                'mousedown',\n                pair[gutterStartDragging]\n            );\n            gutterElement[addEventListener](\n                'touchstart',\n                pair[gutterStartDragging]\n            );\n\n            parent.insertBefore(gutterElement, element.element);\n\n            pair.gutter = gutterElement;\n        }\n\n        setElementSize(\n            element.element,\n            element.size,\n            getGutterSize(\n                gutterSize,\n                i === 0,\n                i === ids.length - 1,\n                gutterAlign\n            ),\n            i\n        );\n\n        // After the first iteration, and we have a pair object, append it to the\n        // list of pairs.\n        if (i > 0) {\n            pairs.push(pair);\n        }\n\n        return element\n    });\n\n    function adjustToMin(element) {\n        var isLast = element.i === pairs.length;\n        var pair = isLast ? pairs[element.i - 1] : pairs[element.i];\n\n        calculateSizes.call(pair);\n\n        var size = isLast\n            ? pair.size - element.minSize - pair[bGutterSize]\n            : element.minSize + pair[aGutterSize];\n\n        adjust.call(pair, size);\n    }\n\n    elements.forEach(function (element) {\n        var computedSize = element.element[getBoundingClientRect]()[dimension];\n\n        if (computedSize < element.minSize) {\n            if (expandToMin) {\n                adjustToMin(element);\n            } else {\n                // eslint-disable-next-line no-param-reassign\n                element.minSize = computedSize;\n            }\n        }\n    });\n\n    function setSizes(newSizes) {\n        var trimmed = trimToMin(newSizes);\n        trimmed.forEach(function (newSize, i) {\n            if (i > 0) {\n                var pair = pairs[i - 1];\n\n                var a = elements[pair.a];\n                var b = elements[pair.b];\n\n                a.size = trimmed[i - 1];\n                b.size = newSize;\n\n                setElementSize(a.element, a.size, pair[aGutterSize], a.i);\n                setElementSize(b.element, b.size, pair[bGutterSize], b.i);\n            }\n        });\n    }\n\n    function destroy(preserveStyles, preserveGutter) {\n        pairs.forEach(function (pair) {\n            if (preserveGutter !== true) {\n                pair.parent.removeChild(pair.gutter);\n            } else {\n                pair.gutter[removeEventListener](\n                    'mousedown',\n                    pair[gutterStartDragging]\n                );\n                pair.gutter[removeEventListener](\n                    'touchstart',\n                    pair[gutterStartDragging]\n                );\n            }\n\n            if (preserveStyles !== true) {\n                var style = elementStyle(\n                    dimension,\n                    pair.a.size,\n                    pair[aGutterSize]\n                );\n\n                Object.keys(style).forEach(function (prop) {\n                    elements[pair.a].element.style[prop] = '';\n                    elements[pair.b].element.style[prop] = '';\n                });\n            }\n        });\n    }\n\n    return {\n        setSizes: setSizes,\n        getSizes: getSizes,\n        collapse: function collapse(i) {\n            adjustToMin(elements[i]);\n        },\n        destroy: destroy,\n        parent: parent,\n        pairs: pairs,\n    }\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Split);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3BsaXQuanMvZGlzdC9zcGxpdC5lcy5qcz8xOTcwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLDZCQUE2QixxREFBcUQ7O0FBRWxGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsVUFBVTs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvRUFBb0UseUJBQXlCLEVBQUU7O0FBRS9GO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxnQkFBZ0IsRUFBRTtBQUM3RjtBQUNBLDJFQUEyRSxnQkFBZ0IsRUFBRTs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsZ0RBQWdELHFCQUFxQixFQUFFO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQzs7QUFFQSw2QkFBNkI7O0FBRTdCOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxjQUFjLEVBQUU7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLEtBQUssRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zcGxpdC5qcy9kaXN0L3NwbGl0LmVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhlIHByb2dyYW1taW5nIGdvYWxzIG9mIFNwbGl0LmpzIGFyZSB0byBkZWxpdmVyIHJlYWRhYmxlLCB1bmRlcnN0YW5kYWJsZSBhbmRcbi8vIG1haW50YWluYWJsZSBjb2RlLCB3aGlsZSBhdCB0aGUgc2FtZSB0aW1lIG1hbnVhbGx5IG9wdGltaXppbmcgZm9yIHRpbnkgbWluaWZpZWQgZmlsZSBzaXplLFxuLy8gYnJvd3NlciBjb21wYXRpYmlsaXR5IHdpdGhvdXQgYWRkaXRpb25hbCByZXF1aXJlbWVudHNcbi8vIGFuZCB2ZXJ5IGZldyBhc3N1bXB0aW9ucyBhYm91dCB0aGUgdXNlcidzIHBhZ2UgbGF5b3V0LlxudmFyIGdsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogbnVsbDtcbnZhciBzc3IgPSBnbG9iYWwgPT09IG51bGw7XG52YXIgZG9jdW1lbnQgPSAhc3NyID8gZ2xvYmFsLmRvY3VtZW50IDogdW5kZWZpbmVkO1xuXG4vLyBTYXZlIGEgY291cGxlIGxvbmcgZnVuY3Rpb24gbmFtZXMgdGhhdCBhcmUgdXNlZCBmcmVxdWVudGx5LlxuLy8gVGhpcyBvcHRpbWl6YXRpb24gc2F2ZXMgYXJvdW5kIDQwMCBieXRlcy5cbnZhciBhZGRFdmVudExpc3RlbmVyID0gJ2FkZEV2ZW50TGlzdGVuZXInO1xudmFyIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG52YXIgZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID0gJ2dldEJvdW5kaW5nQ2xpZW50UmVjdCc7XG52YXIgZ3V0dGVyU3RhcnREcmFnZ2luZyA9ICdfYSc7XG52YXIgYUd1dHRlclNpemUgPSAnX2InO1xudmFyIGJHdXR0ZXJTaXplID0gJ19jJztcbnZhciBIT1JJWk9OVEFMID0gJ2hvcml6b250YWwnO1xudmFyIE5PT1AgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIGRldGVybWluZXMgd2hpY2ggcHJlZml4ZXMgb2YgQ1NTIGNhbGMgd2UgbmVlZC5cbi8vIFdlIG9ubHkgbmVlZCB0byBkbyB0aGlzIG9uY2Ugb24gc3RhcnR1cCwgd2hlbiB0aGlzIGFub255bW91cyBmdW5jdGlvbiBpcyBjYWxsZWQuXG4vL1xuLy8gVGVzdHMgLXdlYmtpdCwgLW1veiBhbmQgLW8gcHJlZml4ZXMuIE1vZGlmaWVkIGZyb20gU3RhY2tPdmVyZmxvdzpcbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTY2MjUxNDAvanMtZmVhdHVyZS1kZXRlY3Rpb24tdG8tZGV0ZWN0LXRoZS11c2FnZS1vZi13ZWJraXQtY2FsYy1vdmVyLWNhbGMvMTY2MjUxNjcjMTY2MjUxNjdcbnZhciBjYWxjID0gc3NyXG4gICAgPyAnY2FsYydcbiAgICA6ICgoWycnLCAnLXdlYmtpdC0nLCAnLW1vei0nLCAnLW8tJ11cbiAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgIGVsLnN0eWxlLmNzc1RleHQgPSBcIndpZHRoOlwiICsgcHJlZml4ICsgXCJjYWxjKDlweClcIjtcblxuICAgICAgICAgICAgICByZXR1cm4gISFlbC5zdHlsZS5sZW5ndGhcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5zaGlmdCgpKSArIFwiY2FsY1wiKTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIGNoZWNrcyBpZiBpdHMgYXJndW1lbnQgaXMgYSBzdHJpbmctbGlrZSB0eXBlXG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8IHYgaW5zdGFuY2VvZiBTdHJpbmc7IH07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiBhbGxvd3MgZWxlbWVudHMgYW5kIHN0cmluZyBzZWxlY3RvcnMgdG8gYmUgdXNlZFxuLy8gaW50ZXJjaGFuZ2VhYmx5LiBJbiBlaXRoZXIgY2FzZSBhbiBlbGVtZW50IGlzIHJldHVybmVkLiBUaGlzIGFsbG93cyB1cyB0b1xuLy8gZG8gYFNwbGl0KFtlbGVtMSwgZWxlbTJdKWAgYXMgd2VsbCBhcyBgU3BsaXQoWycjaWQxJywgJyNpZDInXSlgLlxudmFyIGVsZW1lbnRPclNlbGVjdG9yID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGlzU3RyaW5nKGVsKSkge1xuICAgICAgICB2YXIgZWxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgICAgIGlmICghZWxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiU2VsZWN0b3IgXCIgKyBlbCArIFwiIGRpZCBub3QgbWF0Y2ggYSBET00gZWxlbWVudFwiKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlXG4gICAgfVxuXG4gICAgcmV0dXJuIGVsXG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gZ2V0cyBhIHByb3BlcnR5IGZyb20gdGhlIHByb3BlcnRpZXMgb2JqZWN0LCB3aXRoIGEgZGVmYXVsdCBmYWxsYmFja1xudmFyIGdldE9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zLCBwcm9wTmFtZSwgZGVmKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9uc1twcm9wTmFtZV07XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIHJldHVybiBkZWZcbn07XG5cbnZhciBnZXRHdXR0ZXJTaXplID0gZnVuY3Rpb24gKGd1dHRlclNpemUsIGlzRmlyc3QsIGlzTGFzdCwgZ3V0dGVyQWxpZ24pIHtcbiAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICBpZiAoZ3V0dGVyQWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9XG4gICAgICAgIGlmIChndXR0ZXJBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBndXR0ZXJTaXplIC8gMlxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0xhc3QpIHtcbiAgICAgICAgaWYgKGd1dHRlckFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9XG4gICAgICAgIGlmIChndXR0ZXJBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBndXR0ZXJTaXplIC8gMlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGd1dHRlclNpemVcbn07XG5cbi8vIERlZmF1bHQgb3B0aW9uc1xudmFyIGRlZmF1bHRHdXR0ZXJGbiA9IGZ1bmN0aW9uIChpLCBndXR0ZXJEaXJlY3Rpb24pIHtcbiAgICB2YXIgZ3V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZ3V0LmNsYXNzTmFtZSA9IFwiZ3V0dGVyIGd1dHRlci1cIiArIGd1dHRlckRpcmVjdGlvbjtcbiAgICByZXR1cm4gZ3V0XG59O1xuXG52YXIgZGVmYXVsdEVsZW1lbnRTdHlsZUZuID0gZnVuY3Rpb24gKGRpbSwgc2l6ZSwgZ3V0U2l6ZSkge1xuICAgIHZhciBzdHlsZSA9IHt9O1xuXG4gICAgaWYgKCFpc1N0cmluZyhzaXplKSkge1xuICAgICAgICBzdHlsZVtkaW1dID0gY2FsYyArIFwiKFwiICsgc2l6ZSArIFwiJSAtIFwiICsgZ3V0U2l6ZSArIFwicHgpXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVbZGltXSA9IHNpemU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlXG59O1xuXG52YXIgZGVmYXVsdEd1dHRlclN0eWxlRm4gPSBmdW5jdGlvbiAoZGltLCBndXRTaXplKSB7XG4gICAgdmFyIG9iajtcblxuICAgIHJldHVybiAoKCBvYmogPSB7fSwgb2JqW2RpbV0gPSAoZ3V0U2l6ZSArIFwicHhcIiksIG9iaiApKTtcbn07XG5cbi8vIFRoZSBtYWluIGZ1bmN0aW9uIHRvIGluaXRpYWxpemUgYSBzcGxpdC4gU3BsaXQuanMgdGhpbmtzIGFib3V0IGVhY2ggcGFpclxuLy8gb2YgZWxlbWVudHMgYXMgYW4gaW5kZXBlbmRhbnQgcGFpci4gRHJhZ2dpbmcgdGhlIGd1dHRlciBiZXR3ZWVuIHR3byBlbGVtZW50c1xuLy8gb25seSBjaGFuZ2VzIHRoZSBkaW1lbnNpb25zIG9mIGVsZW1lbnRzIGluIHRoYXQgcGFpci4gVGhpcyBpcyBrZXkgdG8gdW5kZXJzdGFuZGluZ1xuLy8gaG93IHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG9wZXJhdGUsIHNpbmNlIGVhY2ggZnVuY3Rpb24gaXMgYm91bmQgdG8gYSBwYWlyLlxuLy9cbi8vIEEgcGFpciBvYmplY3QgaXMgc2hhcGVkIGxpa2UgdGhpczpcbi8vXG4vLyB7XG4vLyAgICAgYTogRE9NIGVsZW1lbnQsXG4vLyAgICAgYjogRE9NIGVsZW1lbnQsXG4vLyAgICAgYU1pbjogTnVtYmVyLFxuLy8gICAgIGJNaW46IE51bWJlcixcbi8vICAgICBkcmFnZ2luZzogQm9vbGVhbixcbi8vICAgICBwYXJlbnQ6IERPTSBlbGVtZW50LFxuLy8gICAgIGRpcmVjdGlvbjogJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJ1xuLy8gfVxuLy9cbi8vIFRoZSBiYXNpYyBzZXF1ZW5jZTpcbi8vXG4vLyAxLiBTZXQgZGVmYXVsdHMgdG8gc29tZXRoaW5nIHNhbmUuIGBvcHRpb25zYCBkb2Vzbid0IGhhdmUgdG8gYmUgcGFzc2VkIGF0IGFsbC5cbi8vIDIuIEluaXRpYWxpemUgYSBidW5jaCBvZiBzdHJpbmdzIGJhc2VkIG9uIHRoZSBkaXJlY3Rpb24gd2UncmUgc3BsaXR0aW5nLlxuLy8gICAgQSBsb3Qgb2YgdGhlIGJlaGF2aW9yIGluIHRoZSByZXN0IG9mIHRoZSBsaWJyYXJ5IGlzIHBhcmFtYXRpemVkIGRvd24gdG9cbi8vICAgIHJlbHkgb24gQ1NTIHN0cmluZ3MgYW5kIGNsYXNzZXMuXG4vLyAzLiBEZWZpbmUgdGhlIGRyYWdnaW5nIGhlbHBlciBmdW5jdGlvbnMsIGFuZCBhIGZldyBoZWxwZXJzIHRvIGdvIHdpdGggdGhlbS5cbi8vIDQuIExvb3AgdGhyb3VnaCB0aGUgZWxlbWVudHMgd2hpbGUgcGFpcmluZyB0aGVtIG9mZi4gRXZlcnkgcGFpciBnZXRzIGFuXG4vLyAgICBgcGFpcmAgb2JqZWN0IGFuZCBhIGd1dHRlci5cbi8vIDUuIEFjdHVhbGx5IHNpemUgdGhlIHBhaXIgZWxlbWVudHMsIGluc2VydCBndXR0ZXJzIGFuZCBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzLlxudmFyIFNwbGl0ID0gZnVuY3Rpb24gKGlkc09wdGlvbiwgb3B0aW9ucykge1xuICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKHNzcikgeyByZXR1cm4ge30gfVxuXG4gICAgdmFyIGlkcyA9IGlkc09wdGlvbjtcbiAgICB2YXIgZGltZW5zaW9uO1xuICAgIHZhciBjbGllbnRBeGlzO1xuICAgIHZhciBwb3NpdGlvbjtcbiAgICB2YXIgcG9zaXRpb25FbmQ7XG4gICAgdmFyIGNsaWVudFNpemU7XG4gICAgdmFyIGVsZW1lbnRzO1xuXG4gICAgLy8gQWxsb3cgSFRNTENvbGxlY3Rpb24gdG8gYmUgdXNlZCBhcyBhbiBhcmd1bWVudCB3aGVuIHN1cHBvcnRlZFxuICAgIGlmIChBcnJheS5mcm9tKSB7XG4gICAgICAgIGlkcyA9IEFycmF5LmZyb20oaWRzKTtcbiAgICB9XG5cbiAgICAvLyBBbGwgRE9NIGVsZW1lbnRzIGluIHRoZSBzcGxpdCBzaG91bGQgaGF2ZSBhIGNvbW1vbiBwYXJlbnQuIFdlIGNhbiBncmFiXG4gICAgLy8gdGhlIGZpcnN0IGVsZW1lbnRzIHBhcmVudCBhbmQgaG9wZSB1c2VycyByZWFkIHRoZSBkb2NzIGJlY2F1c2UgdGhlXG4gICAgLy8gYmVoYXZpb3Igd2lsbCBiZSB3aGFja3kgb3RoZXJ3aXNlLlxuICAgIHZhciBmaXJzdEVsZW1lbnQgPSBlbGVtZW50T3JTZWxlY3RvcihpZHNbMF0pO1xuICAgIHZhciBwYXJlbnQgPSBmaXJzdEVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICB2YXIgcGFyZW50U3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlID8gZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpIDogbnVsbDtcbiAgICB2YXIgcGFyZW50RmxleERpcmVjdGlvbiA9IHBhcmVudFN0eWxlID8gcGFyZW50U3R5bGUuZmxleERpcmVjdGlvbiA6IG51bGw7XG5cbiAgICAvLyBTZXQgZGVmYXVsdCBvcHRpb25zLnNpemVzIHRvIGVxdWFsIHBlcmNlbnRhZ2VzIG9mIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICB2YXIgc2l6ZXMgPSBnZXRPcHRpb24ob3B0aW9ucywgJ3NpemVzJykgfHwgaWRzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiAxMDAgLyBpZHMubGVuZ3RoOyB9KTtcblxuICAgIC8vIFN0YW5kYXJkaXplIG1pblNpemUgYW5kIG1heFNpemUgdG8gYW4gYXJyYXkgaWYgaXQgaXNuJ3QgYWxyZWFkeS5cbiAgICAvLyBUaGlzIGFsbG93cyBtaW5TaXplIGFuZCBtYXhTaXplIHRvIGJlIHBhc3NlZCBhcyBhIG51bWJlci5cbiAgICB2YXIgbWluU2l6ZSA9IGdldE9wdGlvbihvcHRpb25zLCAnbWluU2l6ZScsIDEwMCk7XG4gICAgdmFyIG1pblNpemVzID0gQXJyYXkuaXNBcnJheShtaW5TaXplKSA/IG1pblNpemUgOiBpZHMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1pblNpemU7IH0pO1xuICAgIHZhciBtYXhTaXplID0gZ2V0T3B0aW9uKG9wdGlvbnMsICdtYXhTaXplJywgSW5maW5pdHkpO1xuICAgIHZhciBtYXhTaXplcyA9IEFycmF5LmlzQXJyYXkobWF4U2l6ZSkgPyBtYXhTaXplIDogaWRzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBtYXhTaXplOyB9KTtcblxuICAgIC8vIEdldCBvdGhlciBvcHRpb25zXG4gICAgdmFyIGV4cGFuZFRvTWluID0gZ2V0T3B0aW9uKG9wdGlvbnMsICdleHBhbmRUb01pbicsIGZhbHNlKTtcbiAgICB2YXIgZ3V0dGVyU2l6ZSA9IGdldE9wdGlvbihvcHRpb25zLCAnZ3V0dGVyU2l6ZScsIDEwKTtcbiAgICB2YXIgZ3V0dGVyQWxpZ24gPSBnZXRPcHRpb24ob3B0aW9ucywgJ2d1dHRlckFsaWduJywgJ2NlbnRlcicpO1xuICAgIHZhciBzbmFwT2Zmc2V0ID0gZ2V0T3B0aW9uKG9wdGlvbnMsICdzbmFwT2Zmc2V0JywgMzApO1xuICAgIHZhciBkcmFnSW50ZXJ2YWwgPSBnZXRPcHRpb24ob3B0aW9ucywgJ2RyYWdJbnRlcnZhbCcsIDEpO1xuICAgIHZhciBkaXJlY3Rpb24gPSBnZXRPcHRpb24ob3B0aW9ucywgJ2RpcmVjdGlvbicsIEhPUklaT05UQUwpO1xuICAgIHZhciBjdXJzb3IgPSBnZXRPcHRpb24oXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgICdjdXJzb3InLFxuICAgICAgICBkaXJlY3Rpb24gPT09IEhPUklaT05UQUwgPyAnY29sLXJlc2l6ZScgOiAncm93LXJlc2l6ZSdcbiAgICApO1xuICAgIHZhciBndXR0ZXIgPSBnZXRPcHRpb24ob3B0aW9ucywgJ2d1dHRlcicsIGRlZmF1bHRHdXR0ZXJGbik7XG4gICAgdmFyIGVsZW1lbnRTdHlsZSA9IGdldE9wdGlvbihcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgJ2VsZW1lbnRTdHlsZScsXG4gICAgICAgIGRlZmF1bHRFbGVtZW50U3R5bGVGblxuICAgICk7XG4gICAgdmFyIGd1dHRlclN0eWxlID0gZ2V0T3B0aW9uKG9wdGlvbnMsICdndXR0ZXJTdHlsZScsIGRlZmF1bHRHdXR0ZXJTdHlsZUZuKTtcblxuICAgIC8vIDIuIEluaXRpYWxpemUgYSBidW5jaCBvZiBzdHJpbmdzIGJhc2VkIG9uIHRoZSBkaXJlY3Rpb24gd2UncmUgc3BsaXR0aW5nLlxuICAgIC8vIEEgbG90IG9mIHRoZSBiZWhhdmlvciBpbiB0aGUgcmVzdCBvZiB0aGUgbGlicmFyeSBpcyBwYXJhbWF0aXplZCBkb3duIHRvXG4gICAgLy8gcmVseSBvbiBDU1Mgc3RyaW5ncyBhbmQgY2xhc3Nlcy5cbiAgICBpZiAoZGlyZWN0aW9uID09PSBIT1JJWk9OVEFMKSB7XG4gICAgICAgIGRpbWVuc2lvbiA9ICd3aWR0aCc7XG4gICAgICAgIGNsaWVudEF4aXMgPSAnY2xpZW50WCc7XG4gICAgICAgIHBvc2l0aW9uID0gJ2xlZnQnO1xuICAgICAgICBwb3NpdGlvbkVuZCA9ICdyaWdodCc7XG4gICAgICAgIGNsaWVudFNpemUgPSAnY2xpZW50V2lkdGgnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgIGRpbWVuc2lvbiA9ICdoZWlnaHQnO1xuICAgICAgICBjbGllbnRBeGlzID0gJ2NsaWVudFknO1xuICAgICAgICBwb3NpdGlvbiA9ICd0b3AnO1xuICAgICAgICBwb3NpdGlvbkVuZCA9ICdib3R0b20nO1xuICAgICAgICBjbGllbnRTaXplID0gJ2NsaWVudEhlaWdodCc7XG4gICAgfVxuXG4gICAgLy8gMy4gRGVmaW5lIHRoZSBkcmFnZ2luZyBoZWxwZXIgZnVuY3Rpb25zLCBhbmQgYSBmZXcgaGVscGVycyB0byBnbyB3aXRoIHRoZW0uXG4gICAgLy8gRWFjaCBoZWxwZXIgaXMgYm91bmQgdG8gYSBwYWlyIG9iamVjdCB0aGF0IGNvbnRhaW5zIGl0cyBtZXRhZGF0YS4gVGhpc1xuICAgIC8vIGFsc28gbWFrZXMgaXQgZWFzeSB0byBzdG9yZSByZWZlcmVuY2VzIHRvIGxpc3RlbmVycyB0aGF0IHRoYXQgd2lsbCBiZVxuICAgIC8vIGFkZGVkIGFuZCByZW1vdmVkLlxuICAgIC8vXG4gICAgLy8gRXZlbiB0aG91Z2ggdGhlcmUgYXJlIG5vIG90aGVyIGZ1bmN0aW9ucyBjb250YWluZWQgaW4gdGhlbSwgYWxpYXNpbmdcbiAgICAvLyB0aGlzIHRvIHNlbGYgc2F2ZXMgNTAgYnl0ZXMgb3Igc28gc2luY2UgaXQncyB1c2VkIHNvIGZyZXF1ZW50bHkuXG4gICAgLy9cbiAgICAvLyBUaGUgcGFpciBvYmplY3Qgc2F2ZXMgbWV0YWRhdGEgbGlrZSBkcmFnZ2luZyBzdGF0ZSwgcG9zaXRpb24gYW5kXG4gICAgLy8gZXZlbnQgbGlzdGVuZXIgcmVmZXJlbmNlcy5cblxuICAgIGZ1bmN0aW9uIHNldEVsZW1lbnRTaXplKGVsLCBzaXplLCBndXRTaXplLCBpKSB7XG4gICAgICAgIC8vIFNwbGl0LmpzIGFsbG93cyBzZXR0aW5nIHNpemVzIHZpYSBudW1iZXJzIChpZGVhbGx5KSwgb3IgaWYgeW91IG11c3QsXG4gICAgICAgIC8vIGJ5IHN0cmluZywgbGlrZSAnMzAwcHgnLiBUaGlzIGlzIGxlc3MgdGhhbiBpZGVhbCwgYmVjYXVzZSBpdCBicmVha3NcbiAgICAgICAgLy8gdGhlIGZsdWlkIGxheW91dCB0aGF0IGBjYWxjKCUgLSBweClgIHByb3ZpZGVzLiBZb3UncmUgb24geW91ciBvd24gaWYgeW91IGRvIHRoYXQsXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB5b3UgY2FsY3VsYXRlIHRoZSBndXR0ZXIgc2l6ZSBieSBoYW5kLlxuICAgICAgICB2YXIgc3R5bGUgPSBlbGVtZW50U3R5bGUoZGltZW5zaW9uLCBzaXplLCBndXRTaXplLCBpKTtcblxuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBlbC5zdHlsZVtwcm9wXSA9IHN0eWxlW3Byb3BdO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRHdXR0ZXJTaXplKGd1dHRlckVsZW1lbnQsIGd1dFNpemUsIGkpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gZ3V0dGVyU3R5bGUoZGltZW5zaW9uLCBndXRTaXplLCBpKTtcblxuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBndXR0ZXJFbGVtZW50LnN0eWxlW3Byb3BdID0gc3R5bGVbcHJvcF07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNpemVzKCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudHMubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50LnNpemU7IH0pXG4gICAgfVxuXG4gICAgLy8gU3VwcG9ydHMgdG91Y2ggZXZlbnRzLCBidXQgbm90IG11bHRpdG91Y2gsIHNvIG9ubHkgdGhlIGZpcnN0XG4gICAgLy8gZmluZ2VyIGB0b3VjaGVzWzBdYCBpcyBjb3VudGVkLlxuICAgIGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZSkge1xuICAgICAgICBpZiAoJ3RvdWNoZXMnIGluIGUpIHsgcmV0dXJuIGUudG91Y2hlc1swXVtjbGllbnRBeGlzXSB9XG4gICAgICAgIHJldHVybiBlW2NsaWVudEF4aXNdXG4gICAgfVxuXG4gICAgLy8gQWN0dWFsbHkgYWRqdXN0IHRoZSBzaXplIG9mIGVsZW1lbnRzIGBhYCBhbmQgYGJgIHRvIGBvZmZzZXRgIHdoaWxlIGRyYWdnaW5nLlxuICAgIC8vIGNhbGMgaXMgdXNlZCB0byBhbGxvdyBjYWxjKHBlcmNlbnRhZ2UgKyBndXR0ZXJweCkgb24gdGhlIHdob2xlIHNwbGl0IGluc3RhbmNlLFxuICAgIC8vIHdoaWNoIGFsbG93cyB0aGUgdmlld3BvcnQgdG8gYmUgcmVzaXplZCB3aXRob3V0IGFkZGl0aW9uYWwgbG9naWMuXG4gICAgLy8gRWxlbWVudCBhJ3Mgc2l6ZSBpcyB0aGUgc2FtZSBhcyBvZmZzZXQuIGIncyBzaXplIGlzIHRvdGFsIHNpemUgLSBhIHNpemUuXG4gICAgLy8gQm90aCBzaXplcyBhcmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBpbml0aWFsIHBhcmVudCBwZXJjZW50YWdlLFxuICAgIC8vIHRoZW4gdGhlIGd1dHRlciBzaXplIGlzIHN1YnRyYWN0ZWQuXG4gICAgZnVuY3Rpb24gYWRqdXN0KG9mZnNldCkge1xuICAgICAgICB2YXIgYSA9IGVsZW1lbnRzW3RoaXMuYV07XG4gICAgICAgIHZhciBiID0gZWxlbWVudHNbdGhpcy5iXTtcbiAgICAgICAgdmFyIHBlcmNlbnRhZ2UgPSBhLnNpemUgKyBiLnNpemU7XG5cbiAgICAgICAgYS5zaXplID0gKG9mZnNldCAvIHRoaXMuc2l6ZSkgKiBwZXJjZW50YWdlO1xuICAgICAgICBiLnNpemUgPSBwZXJjZW50YWdlIC0gKG9mZnNldCAvIHRoaXMuc2l6ZSkgKiBwZXJjZW50YWdlO1xuXG4gICAgICAgIHNldEVsZW1lbnRTaXplKGEuZWxlbWVudCwgYS5zaXplLCB0aGlzW2FHdXR0ZXJTaXplXSwgYS5pKTtcbiAgICAgICAgc2V0RWxlbWVudFNpemUoYi5lbGVtZW50LCBiLnNpemUsIHRoaXNbYkd1dHRlclNpemVdLCBiLmkpO1xuICAgIH1cblxuICAgIC8vIGRyYWcsIHdoZXJlIGFsbCB0aGUgbWFnaWMgaGFwcGVucy4gVGhlIGxvZ2ljIGlzIHJlYWxseSBxdWl0ZSBzaW1wbGU6XG4gICAgLy9cbiAgICAvLyAxLiBJZ25vcmUgaWYgdGhlIHBhaXIgaXMgbm90IGRyYWdnaW5nLlxuICAgIC8vIDIuIEdldCB0aGUgb2Zmc2V0IG9mIHRoZSBldmVudC5cbiAgICAvLyAzLiBTbmFwIG9mZnNldCB0byBtaW4gaWYgd2l0aGluIHNuYXBwYWJsZSByYW5nZSAod2l0aGluIG1pbiArIHNuYXBPZmZzZXQpLlxuICAgIC8vIDQuIEFjdHVhbGx5IGFkanVzdCBlYWNoIGVsZW1lbnQgaW4gdGhlIHBhaXIgdG8gb2Zmc2V0LlxuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gfCAgICB8IDwtIGEubWluU2l6ZSAgICAgICAgICAgICAgIHx8ICAgICAgICAgICAgICBiLm1pblNpemUgLT4gfCAgICB8XG4gICAgLy8gfCAgICB8ICB8IDwtIHRoaXMuc25hcE9mZnNldCAgICAgIHx8ICAgICB0aGlzLnNuYXBPZmZzZXQgLT4gfCAgfCAgICB8XG4gICAgLy8gfCAgICB8ICB8ICAgICAgICAgICAgICAgICAgICAgICAgIHx8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgfCAgICB8XG4gICAgLy8gfCAgICB8ICB8ICAgICAgICAgICAgICAgICAgICAgICAgIHx8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgfCAgICB8XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gfCA8LSB0aGlzLnN0YXJ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSAtPiB8XG4gICAgZnVuY3Rpb24gZHJhZyhlKSB7XG4gICAgICAgIHZhciBvZmZzZXQ7XG4gICAgICAgIHZhciBhID0gZWxlbWVudHNbdGhpcy5hXTtcbiAgICAgICAgdmFyIGIgPSBlbGVtZW50c1t0aGlzLmJdO1xuXG4gICAgICAgIGlmICghdGhpcy5kcmFnZ2luZykgeyByZXR1cm4gfVxuXG4gICAgICAgIC8vIEdldCB0aGUgb2Zmc2V0IG9mIHRoZSBldmVudCBmcm9tIHRoZSBmaXJzdCBzaWRlIG9mIHRoZVxuICAgICAgICAvLyBwYWlyIGB0aGlzLnN0YXJ0YC4gVGhlbiBvZmZzZXQgYnkgdGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlXG4gICAgICAgIC8vIG1vdXNlIGNvbXBhcmVkIHRvIHRoZSBndXR0ZXIgc2l6ZS5cbiAgICAgICAgb2Zmc2V0ID1cbiAgICAgICAgICAgIGdldE1vdXNlUG9zaXRpb24oZSkgLVxuICAgICAgICAgICAgdGhpcy5zdGFydCArXG4gICAgICAgICAgICAodGhpc1thR3V0dGVyU2l6ZV0gLSB0aGlzLmRyYWdPZmZzZXQpO1xuXG4gICAgICAgIGlmIChkcmFnSW50ZXJ2YWwgPiAxKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBNYXRoLnJvdW5kKG9mZnNldCAvIGRyYWdJbnRlcnZhbCkgKiBkcmFnSW50ZXJ2YWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3aXRoaW4gc25hcE9mZnNldCBvZiBtaW4gb3IgbWF4LCBzZXQgb2Zmc2V0IHRvIG1pbiBvciBtYXguXG4gICAgICAgIC8vIHNuYXBPZmZzZXQgYnVmZmVycyBhLm1pblNpemUgYW5kIGIubWluU2l6ZSwgc28gbG9naWMgaXMgb3Bwb3NpdGUgZm9yIGJvdGguXG4gICAgICAgIC8vIEluY2x1ZGUgdGhlIGFwcHJvcHJpYXRlIGd1dHRlciBzaXplcyB0byBwcmV2ZW50IG92ZXJmbG93cy5cbiAgICAgICAgaWYgKG9mZnNldCA8PSBhLm1pblNpemUgKyBzbmFwT2Zmc2V0ICsgdGhpc1thR3V0dGVyU2l6ZV0pIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGEubWluU2l6ZSArIHRoaXNbYUd1dHRlclNpemVdO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgb2Zmc2V0ID49XG4gICAgICAgICAgICB0aGlzLnNpemUgLSAoYi5taW5TaXplICsgc25hcE9mZnNldCArIHRoaXNbYkd1dHRlclNpemVdKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuc2l6ZSAtIChiLm1pblNpemUgKyB0aGlzW2JHdXR0ZXJTaXplXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2Zmc2V0ID49IGEubWF4U2l6ZSAtIHNuYXBPZmZzZXQgKyB0aGlzW2FHdXR0ZXJTaXplXSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gYS5tYXhTaXplICsgdGhpc1thR3V0dGVyU2l6ZV07XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBvZmZzZXQgPD1cbiAgICAgICAgICAgIHRoaXMuc2l6ZSAtIChiLm1heFNpemUgLSBzbmFwT2Zmc2V0ICsgdGhpc1tiR3V0dGVyU2l6ZV0pXG4gICAgICAgICkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5zaXplIC0gKGIubWF4U2l6ZSArIHRoaXNbYkd1dHRlclNpemVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFjdHVhbGx5IGFkanVzdCB0aGUgc2l6ZS5cbiAgICAgICAgYWRqdXN0LmNhbGwodGhpcywgb2Zmc2V0KTtcblxuICAgICAgICAvLyBDYWxsIHRoZSBkcmFnIGNhbGxiYWNrIGNvbnRpbm91c2x5LiBEb24ndCBkbyBhbnl0aGluZyB0b28gaW50ZW5zaXZlXG4gICAgICAgIC8vIGluIHRoaXMgY2FsbGJhY2suXG4gICAgICAgIGdldE9wdGlvbihvcHRpb25zLCAnb25EcmFnJywgTk9PUCkoZ2V0U2l6ZXMoKSk7XG4gICAgfVxuXG4gICAgLy8gQ2FjaGUgc29tZSBpbXBvcnRhbnQgc2l6ZXMgd2hlbiBkcmFnIHN0YXJ0cywgc28gd2UgZG9uJ3QgaGF2ZSB0byBkbyB0aGF0XG4gICAgLy8gY29udGlub3VzbHk6XG4gICAgLy9cbiAgICAvLyBgc2l6ZWA6IFRoZSB0b3RhbCBzaXplIG9mIHRoZSBwYWlyLiBGaXJzdCArIHNlY29uZCArIGZpcnN0IGd1dHRlciArIHNlY29uZCBndXR0ZXIuXG4gICAgLy8gYHN0YXJ0YDogVGhlIGxlYWRpbmcgc2lkZSBvZiB0aGUgZmlyc3QgZWxlbWVudC5cbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHwgICAgICBhR3V0dGVyU2l6ZSAtPiB8fHwgICAgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vIHwgICAgICAgICAgICAgICAgICAgICB8fHwgICAgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vIHwgICAgICAgICAgICAgICAgICAgICB8fHwgICAgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vIHwgICAgICAgICAgICAgICAgICAgICB8fHwgPC0gYkd1dHRlclNpemUgICAgICAgfFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHwgPC0gc3RhcnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgLT4gfFxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZVNpemVzKCkge1xuICAgICAgICAvLyBGaWd1cmUgb3V0IHRoZSBwYXJlbnQgc2l6ZSBtaW51cyBwYWRkaW5nLlxuICAgICAgICB2YXIgYSA9IGVsZW1lbnRzW3RoaXMuYV0uZWxlbWVudDtcbiAgICAgICAgdmFyIGIgPSBlbGVtZW50c1t0aGlzLmJdLmVsZW1lbnQ7XG5cbiAgICAgICAgdmFyIGFCb3VuZHMgPSBhW2dldEJvdW5kaW5nQ2xpZW50UmVjdF0oKTtcbiAgICAgICAgdmFyIGJCb3VuZHMgPSBiW2dldEJvdW5kaW5nQ2xpZW50UmVjdF0oKTtcblxuICAgICAgICB0aGlzLnNpemUgPVxuICAgICAgICAgICAgYUJvdW5kc1tkaW1lbnNpb25dICtcbiAgICAgICAgICAgIGJCb3VuZHNbZGltZW5zaW9uXSArXG4gICAgICAgICAgICB0aGlzW2FHdXR0ZXJTaXplXSArXG4gICAgICAgICAgICB0aGlzW2JHdXR0ZXJTaXplXTtcbiAgICAgICAgdGhpcy5zdGFydCA9IGFCb3VuZHNbcG9zaXRpb25dO1xuICAgICAgICB0aGlzLmVuZCA9IGFCb3VuZHNbcG9zaXRpb25FbmRdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlubmVyU2l6ZShlbGVtZW50KSB7XG4gICAgICAgIC8vIFJldHVybiBub3RoaW5nIGlmIGdldENvbXB1dGVkU3R5bGUgaXMgbm90IHN1cHBvcnRlZCAoPCBJRTkpXG4gICAgICAgIC8vIE9yIGlmIHBhcmVudCBlbGVtZW50IGhhcyBubyBsYXlvdXQgeWV0XG4gICAgICAgIGlmICghZ2V0Q29tcHV0ZWRTdHlsZSkgeyByZXR1cm4gbnVsbCB9XG5cbiAgICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgICAgIGlmICghY29tcHV0ZWRTdHlsZSkgeyByZXR1cm4gbnVsbCB9XG5cbiAgICAgICAgdmFyIHNpemUgPSBlbGVtZW50W2NsaWVudFNpemVdO1xuXG4gICAgICAgIGlmIChzaXplID09PSAwKSB7IHJldHVybiBudWxsIH1cblxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBIT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICBzaXplIC09XG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdMZWZ0KSArXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdSaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaXplIC09XG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdUb3ApICtcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ0JvdHRvbSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2l6ZVxuICAgIH1cblxuICAgIC8vIFdoZW4gc3BlY2lmeWluZyBwZXJjZW50YWdlIHNpemVzIHRoYXQgYXJlIGxlc3MgdGhhbiB0aGUgY29tcHV0ZWRcbiAgICAvLyBzaXplIG9mIHRoZSBlbGVtZW50IG1pbnVzIHRoZSBndXR0ZXIsIHRoZSBsZXNzZXIgcGVyY2VudGFnZXMgbXVzdCBiZSBpbmNyZWFzZWRcbiAgICAvLyAoYW5kIGRlY3JlYXNlZCBmcm9tIHRoZSBvdGhlciBlbGVtZW50cykgdG8gbWFrZSBzcGFjZSBmb3IgdGhlIHBpeGVsc1xuICAgIC8vIHN1YnRyYWN0ZWQgYnkgdGhlIGd1dHRlcnMuXG4gICAgZnVuY3Rpb24gdHJpbVRvTWluKHNpemVzVG9UcmltKSB7XG4gICAgICAgIC8vIFRyeSB0byBnZXQgaW5uZXIgc2l6ZSBvZiBwYXJlbnQgZWxlbWVudC5cbiAgICAgICAgLy8gSWYgaXQncyBubyBzdXBwb3J0ZWQsIHJldHVybiBvcmlnaW5hbCBzaXplcy5cbiAgICAgICAgdmFyIHBhcmVudFNpemUgPSBpbm5lclNpemUocGFyZW50KTtcbiAgICAgICAgaWYgKHBhcmVudFNpemUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBzaXplc1RvVHJpbVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pblNpemVzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSArIGI7IH0sIDApID4gcGFyZW50U2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpemVzVG9UcmltXG4gICAgICAgIH1cblxuICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBleGNlc3MgcGl4ZWxzLCB0aGUgYW1vdW50IG9mIHBpeGVscyBvdmVyIHRoZSBkZXNpcmVkIHBlcmNlbnRhZ2VcbiAgICAgICAgLy8gQWxzbyBrZWVwIHRyYWNrIG9mIHRoZSBlbGVtZW50cyB3aXRoIHBpeGVscyB0byBzcGFyZSwgdG8gZGVjcmVhc2UgYWZ0ZXIgaWYgbmVlZGVkXG4gICAgICAgIHZhciBleGNlc3NQaXhlbHMgPSAwO1xuICAgICAgICB2YXIgdG9TcGFyZSA9IFtdO1xuXG4gICAgICAgIHZhciBwaXhlbFNpemVzID0gc2l6ZXNUb1RyaW0ubWFwKGZ1bmN0aW9uIChzaXplLCBpKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHJlcXVlc3RlZCBwZXJjZW50YWdlcyB0byBwaXhlbCBzaXplc1xuICAgICAgICAgICAgdmFyIHBpeGVsU2l6ZSA9IChwYXJlbnRTaXplICogc2l6ZSkgLyAxMDA7XG4gICAgICAgICAgICB2YXIgZWxlbWVudEd1dHRlclNpemUgPSBnZXRHdXR0ZXJTaXplKFxuICAgICAgICAgICAgICAgIGd1dHRlclNpemUsXG4gICAgICAgICAgICAgICAgaSA9PT0gMCxcbiAgICAgICAgICAgICAgICBpID09PSBzaXplc1RvVHJpbS5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgIGd1dHRlckFsaWduXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRNaW5TaXplID0gbWluU2l6ZXNbaV0gKyBlbGVtZW50R3V0dGVyU2l6ZTtcblxuICAgICAgICAgICAgLy8gSWYgZWxlbWVudCBpcyB0b28gc21hbCwgaW5jcmVhc2UgZXhjZXNzIHBpeGVscyBieSB0aGUgZGlmZmVyZW5jZVxuICAgICAgICAgICAgLy8gYW5kIG1hcmsgdGhhdCBpdCBoYXMgbm8gcGl4ZWxzIHRvIHNwYXJlXG4gICAgICAgICAgICBpZiAocGl4ZWxTaXplIDwgZWxlbWVudE1pblNpemUpIHtcbiAgICAgICAgICAgICAgICBleGNlc3NQaXhlbHMgKz0gZWxlbWVudE1pblNpemUgLSBwaXhlbFNpemU7XG4gICAgICAgICAgICAgICAgdG9TcGFyZS5wdXNoKDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50TWluU2l6ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIG1hcmsgdGhlIHBpeGVscyBpdCBoYXMgdG8gc3BhcmUgYW5kIHJldHVybiBpdCdzIG9yaWdpbmFsIHNpemVcbiAgICAgICAgICAgIHRvU3BhcmUucHVzaChwaXhlbFNpemUgLSBlbGVtZW50TWluU2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4gcGl4ZWxTaXplXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIElmIG5vdGhpbmcgd2FzIGFkanVzdGVkLCByZXR1cm4gdGhlIG9yaWdpbmFsIHNpemVzXG4gICAgICAgIGlmIChleGNlc3NQaXhlbHMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzaXplc1RvVHJpbVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBpeGVsU2l6ZXMubWFwKGZ1bmN0aW9uIChwaXhlbFNpemUsIGkpIHtcbiAgICAgICAgICAgIHZhciBuZXdQaXhlbFNpemUgPSBwaXhlbFNpemU7XG5cbiAgICAgICAgICAgIC8vIFdoaWxlIHRoZXJlJ3Mgc3RpbGwgcGl4ZWxzIHRvIHRha2UsIGFuZCB0aGVyZSdzIGVub3VnaCBwaXhlbHMgdG8gc3BhcmUsXG4gICAgICAgICAgICAvLyB0YWtlIGFzIG1hbnkgYXMgcG9zc2libGUgdXAgdG8gdGhlIHRvdGFsIGV4Y2VzcyBwaXhlbHNcbiAgICAgICAgICAgIGlmIChleGNlc3NQaXhlbHMgPiAwICYmIHRvU3BhcmVbaV0gLSBleGNlc3NQaXhlbHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRha2VuUGl4ZWxzID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICAgIGV4Y2Vzc1BpeGVscyxcbiAgICAgICAgICAgICAgICAgICAgdG9TcGFyZVtpXSAtIGV4Y2Vzc1BpeGVsc1xuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgYW1vdW50IHRha2VuIGZvciB0aGUgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICBleGNlc3NQaXhlbHMgLT0gdGFrZW5QaXhlbHM7XG4gICAgICAgICAgICAgICAgbmV3UGl4ZWxTaXplID0gcGl4ZWxTaXplIC0gdGFrZW5QaXhlbHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgcGl4ZWwgc2l6ZSBhZGp1c3RlZCBhcyBhIHBlcmNlbnRhZ2VcbiAgICAgICAgICAgIHJldHVybiAobmV3UGl4ZWxTaXplIC8gcGFyZW50U2l6ZSkgKiAxMDBcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBzdG9wRHJhZ2dpbmcgaXMgdmVyeSBzaW1pbGFyIHRvIHN0YXJ0RHJhZ2dpbmcgaW4gcmV2ZXJzZS5cbiAgICBmdW5jdGlvbiBzdG9wRHJhZ2dpbmcoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGEgPSBlbGVtZW50c1tzZWxmLmFdLmVsZW1lbnQ7XG4gICAgICAgIHZhciBiID0gZWxlbWVudHNbc2VsZi5iXS5lbGVtZW50O1xuXG4gICAgICAgIGlmIChzZWxmLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICBnZXRPcHRpb24ob3B0aW9ucywgJ29uRHJhZ0VuZCcsIE5PT1ApKGdldFNpemVzKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5kcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgc3RvcmVkIGV2ZW50IGxpc3RlbmVycy4gVGhpcyBpcyB3aHkgd2Ugc3RvcmUgdGhlbS5cbiAgICAgICAgZ2xvYmFsW3JlbW92ZUV2ZW50TGlzdGVuZXJdKCdtb3VzZXVwJywgc2VsZi5zdG9wKTtcbiAgICAgICAgZ2xvYmFsW3JlbW92ZUV2ZW50TGlzdGVuZXJdKCd0b3VjaGVuZCcsIHNlbGYuc3RvcCk7XG4gICAgICAgIGdsb2JhbFtyZW1vdmVFdmVudExpc3RlbmVyXSgndG91Y2hjYW5jZWwnLCBzZWxmLnN0b3ApO1xuICAgICAgICBnbG9iYWxbcmVtb3ZlRXZlbnRMaXN0ZW5lcl0oJ21vdXNlbW92ZScsIHNlbGYubW92ZSk7XG4gICAgICAgIGdsb2JhbFtyZW1vdmVFdmVudExpc3RlbmVyXSgndG91Y2htb3ZlJywgc2VsZi5tb3ZlKTtcblxuICAgICAgICAvLyBDbGVhciBib3VuZCBmdW5jdGlvbiByZWZlcmVuY2VzXG4gICAgICAgIHNlbGYuc3RvcCA9IG51bGw7XG4gICAgICAgIHNlbGYubW92ZSA9IG51bGw7XG5cbiAgICAgICAgYVtyZW1vdmVFdmVudExpc3RlbmVyXSgnc2VsZWN0c3RhcnQnLCBOT09QKTtcbiAgICAgICAgYVtyZW1vdmVFdmVudExpc3RlbmVyXSgnZHJhZ3N0YXJ0JywgTk9PUCk7XG4gICAgICAgIGJbcmVtb3ZlRXZlbnRMaXN0ZW5lcl0oJ3NlbGVjdHN0YXJ0JywgTk9PUCk7XG4gICAgICAgIGJbcmVtb3ZlRXZlbnRMaXN0ZW5lcl0oJ2RyYWdzdGFydCcsIE5PT1ApO1xuXG4gICAgICAgIGEuc3R5bGUudXNlclNlbGVjdCA9ICcnO1xuICAgICAgICBhLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnJztcbiAgICAgICAgYS5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gJyc7XG4gICAgICAgIGEuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuXG4gICAgICAgIGIuc3R5bGUudXNlclNlbGVjdCA9ICcnO1xuICAgICAgICBiLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnJztcbiAgICAgICAgYi5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gJyc7XG4gICAgICAgIGIuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuXG4gICAgICAgIHNlbGYuZ3V0dGVyLnN0eWxlLmN1cnNvciA9ICcnO1xuICAgICAgICBzZWxmLnBhcmVudC5zdHlsZS5jdXJzb3IgPSAnJztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnJztcbiAgICB9XG5cbiAgICAvLyBzdGFydERyYWdnaW5nIGNhbGxzIGBjYWxjdWxhdGVTaXplc2AgdG8gc3RvcmUgdGhlIGluaXRhbCBzaXplIGluIHRoZSBwYWlyIG9iamVjdC5cbiAgICAvLyBJdCBhbHNvIGFkZHMgZXZlbnQgbGlzdGVuZXJzIGZvciBtb3VzZS90b3VjaCBldmVudHMsXG4gICAgLy8gYW5kIHByZXZlbnRzIHNlbGVjdGlvbiB3aGlsZSBkcmFnZ2luZyBzbyBhdm9pZCB0aGUgc2VsZWN0aW5nIHRleHQuXG4gICAgZnVuY3Rpb24gc3RhcnREcmFnZ2luZyhlKSB7XG4gICAgICAgIC8vIFJpZ2h0LWNsaWNraW5nIGNhbid0IHN0YXJ0IGRyYWdnaW5nLlxuICAgICAgICBpZiAoJ2J1dHRvbicgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGlhcyBmcmVxdWVudGx5IHVzZWQgdmFyaWFibGVzIHRvIHNhdmUgc3BhY2UuIDIwMCBieXRlcy5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgYSA9IGVsZW1lbnRzW3NlbGYuYV0uZWxlbWVudDtcbiAgICAgICAgdmFyIGIgPSBlbGVtZW50c1tzZWxmLmJdLmVsZW1lbnQ7XG5cbiAgICAgICAgLy8gQ2FsbCB0aGUgb25EcmFnU3RhcnQgY2FsbGJhY2suXG4gICAgICAgIGlmICghc2VsZi5kcmFnZ2luZykge1xuICAgICAgICAgICAgZ2V0T3B0aW9uKG9wdGlvbnMsICdvbkRyYWdTdGFydCcsIE5PT1ApKGdldFNpemVzKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9uJ3QgYWN0dWFsbHkgZHJhZyB0aGUgZWxlbWVudC4gV2UgZW11bGF0ZSB0aGF0IGluIHRoZSBkcmFnIGZ1bmN0aW9uLlxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBkcmFnZ2luZyBwcm9wZXJ0eSBvZiB0aGUgcGFpciBvYmplY3QuXG4gICAgICAgIHNlbGYuZHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0d28gZXZlbnQgbGlzdGVuZXJzIGJvdW5kIHRvIHRoZSBzYW1lIHBhaXIgb2JqZWN0IGFuZCBzdG9yZVxuICAgICAgICAvLyB0aGVtIGluIHRoZSBwYWlyIG9iamVjdC5cbiAgICAgICAgc2VsZi5tb3ZlID0gZHJhZy5iaW5kKHNlbGYpO1xuICAgICAgICBzZWxmLnN0b3AgPSBzdG9wRHJhZ2dpbmcuYmluZChzZWxmKTtcblxuICAgICAgICAvLyBBbGwgdGhlIGJpbmRpbmcuIGB3aW5kb3dgIGdldHMgdGhlIHN0b3AgZXZlbnRzIGluIGNhc2Ugd2UgZHJhZyBvdXQgb2YgdGhlIGVsZW1lbnRzLlxuICAgICAgICBnbG9iYWxbYWRkRXZlbnRMaXN0ZW5lcl0oJ21vdXNldXAnLCBzZWxmLnN0b3ApO1xuICAgICAgICBnbG9iYWxbYWRkRXZlbnRMaXN0ZW5lcl0oJ3RvdWNoZW5kJywgc2VsZi5zdG9wKTtcbiAgICAgICAgZ2xvYmFsW2FkZEV2ZW50TGlzdGVuZXJdKCd0b3VjaGNhbmNlbCcsIHNlbGYuc3RvcCk7XG4gICAgICAgIGdsb2JhbFthZGRFdmVudExpc3RlbmVyXSgnbW91c2Vtb3ZlJywgc2VsZi5tb3ZlKTtcbiAgICAgICAgZ2xvYmFsW2FkZEV2ZW50TGlzdGVuZXJdKCd0b3VjaG1vdmUnLCBzZWxmLm1vdmUpO1xuXG4gICAgICAgIC8vIERpc2FibGUgc2VsZWN0aW9uLiBEaXNhYmxlIVxuICAgICAgICBhW2FkZEV2ZW50TGlzdGVuZXJdKCdzZWxlY3RzdGFydCcsIE5PT1ApO1xuICAgICAgICBhW2FkZEV2ZW50TGlzdGVuZXJdKCdkcmFnc3RhcnQnLCBOT09QKTtcbiAgICAgICAgYlthZGRFdmVudExpc3RlbmVyXSgnc2VsZWN0c3RhcnQnLCBOT09QKTtcbiAgICAgICAgYlthZGRFdmVudExpc3RlbmVyXSgnZHJhZ3N0YXJ0JywgTk9PUCk7XG5cbiAgICAgICAgYS5zdHlsZS51c2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgICAgICBhLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICAgIGEuc3R5bGUuTW96VXNlclNlbGVjdCA9ICdub25lJztcbiAgICAgICAgYS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuXG4gICAgICAgIGIuc3R5bGUudXNlclNlbGVjdCA9ICdub25lJztcbiAgICAgICAgYi5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgICAgICBiLnN0eWxlLk1velVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICAgIGIuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcblxuICAgICAgICAvLyBTZXQgdGhlIGN1cnNvciBhdCBtdWx0aXBsZSBsZXZlbHNcbiAgICAgICAgc2VsZi5ndXR0ZXIuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuICAgICAgICBzZWxmLnBhcmVudC5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuXG4gICAgICAgIC8vIENhY2hlIHRoZSBpbml0aWFsIHNpemVzIG9mIHRoZSBwYWlyLlxuICAgICAgICBjYWxjdWxhdGVTaXplcy5jYWxsKHNlbGYpO1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgdGhlIG1vdXNlIGNvbXBhcmVkIHRvIHRoZSBndXR0ZXJcbiAgICAgICAgc2VsZi5kcmFnT2Zmc2V0ID0gZ2V0TW91c2VQb3NpdGlvbihlKSAtIHNlbGYuZW5kO1xuICAgIH1cblxuICAgIC8vIGFkanVzdCBzaXplcyB0byBlbnN1cmUgcGVyY2VudGFnZSBpcyB3aXRoaW4gbWluIHNpemUgYW5kIGd1dHRlci5cbiAgICBzaXplcyA9IHRyaW1Ub01pbihzaXplcyk7XG5cbiAgICAvLyA1LiBDcmVhdGUgcGFpciBhbmQgZWxlbWVudCBvYmplY3RzLiBFYWNoIHBhaXIgaGFzIGFuIGluZGV4IHJlZmVyZW5jZSB0b1xuICAgIC8vIGVsZW1lbnRzIGBhYCBhbmQgYGJgIG9mIHRoZSBwYWlyIChmaXJzdCBhbmQgc2Vjb25kIGVsZW1lbnRzKS5cbiAgICAvLyBMb29wIHRocm91Z2ggdGhlIGVsZW1lbnRzIHdoaWxlIHBhaXJpbmcgdGhlbSBvZmYuIEV2ZXJ5IHBhaXIgZ2V0cyBhXG4gICAgLy8gYHBhaXJgIG9iamVjdCBhbmQgYSBndXR0ZXIuXG4gICAgLy9cbiAgICAvLyBCYXNpYyBsb2dpYzpcbiAgICAvL1xuICAgIC8vIC0gU3RhcnRpbmcgd2l0aCB0aGUgc2Vjb25kIGVsZW1lbnQgYGkgPiAwYCwgY3JlYXRlIGBwYWlyYCBvYmplY3RzIHdpdGhcbiAgICAvLyAgIGBhID0gaSAtIDFgIGFuZCBgYiA9IGlgXG4gICAgLy8gLSBTZXQgZ3V0dGVyIHNpemVzIGJhc2VkIG9uIHRoZSBfcGFpcl8gYmVpbmcgZmlyc3QvbGFzdC4gVGhlIGZpcnN0IGFuZCBsYXN0XG4gICAgLy8gICBwYWlyIGhhdmUgZ3V0dGVyU2l6ZSAvIDIsIHNpbmNlIHRoZXkgb25seSBoYXZlIG9uZSBoYWxmIGd1dHRlciwgYW5kIG5vdCB0d28uXG4gICAgLy8gLSBDcmVhdGUgZ3V0dGVyIGVsZW1lbnRzIGFuZCBhZGQgZXZlbnQgbGlzdGVuZXJzLlxuICAgIC8vIC0gU2V0IHRoZSBzaXplIG9mIHRoZSBlbGVtZW50cywgbWludXMgdGhlIGd1dHRlciBzaXplcy5cbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gfCAgICAgaT0wICAgICB8ICAgICAgICAgaT0xICAgICAgICAgfCAgICAgICAgaT0yICAgICAgIHwgICAgICBpPTMgICAgIHxcbiAgICAvLyB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICAgIC8vIHwgICAgICAgICAgIHBhaXIgMCAgICAgICAgICAgICAgICBwYWlyIDEgICAgICAgICAgICAgcGFpciAyICAgICAgICAgICB8XG4gICAgLy8gfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBwYWlycyA9IFtdO1xuICAgIGVsZW1lbnRzID0gaWRzLm1hcChmdW5jdGlvbiAoaWQsIGkpIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBlbGVtZW50IG9iamVjdC5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50T3JTZWxlY3RvcihpZCksXG4gICAgICAgICAgICBzaXplOiBzaXplc1tpXSxcbiAgICAgICAgICAgIG1pblNpemU6IG1pblNpemVzW2ldLFxuICAgICAgICAgICAgbWF4U2l6ZTogbWF4U2l6ZXNbaV0sXG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwYWlyO1xuXG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBwYWlyIG9iamVjdCB3aXRoIGl0cyBtZXRhZGF0YS5cbiAgICAgICAgICAgIHBhaXIgPSB7XG4gICAgICAgICAgICAgICAgYTogaSAtIDEsXG4gICAgICAgICAgICAgICAgYjogaSxcbiAgICAgICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBwYWlyW2FHdXR0ZXJTaXplXSA9IGdldEd1dHRlclNpemUoXG4gICAgICAgICAgICAgICAgZ3V0dGVyU2l6ZSxcbiAgICAgICAgICAgICAgICBpIC0gMSA9PT0gMCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBndXR0ZXJBbGlnblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHBhaXJbYkd1dHRlclNpemVdID0gZ2V0R3V0dGVyU2l6ZShcbiAgICAgICAgICAgICAgICBndXR0ZXJTaXplLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGkgPT09IGlkcy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgIGd1dHRlckFsaWduXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgcGFyZW50IGhhcyBhIHJldmVyc2UgZmxleC1kaXJlY3Rpb24sIHN3aXRjaCB0aGUgcGFpciBlbGVtZW50cy5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBwYXJlbnRGbGV4RGlyZWN0aW9uID09PSAncm93LXJldmVyc2UnIHx8XG4gICAgICAgICAgICAgICAgcGFyZW50RmxleERpcmVjdGlvbiA9PT0gJ2NvbHVtbi1yZXZlcnNlJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBwYWlyLmE7XG4gICAgICAgICAgICAgICAgcGFpci5hID0gcGFpci5iO1xuICAgICAgICAgICAgICAgIHBhaXIuYiA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHNpemUgb2YgdGhlIGN1cnJlbnQgZWxlbWVudC4gSUU4IGlzIHN1cHBvcnRlZCBieVxuICAgICAgICAvLyBzdGF0aWNseSBhc3NpZ25pbmcgc2l6ZXMgd2l0aG91dCBkcmFnZ2FibGUgZ3V0dGVycy4gQXNzaWducyBhIHN0cmluZ1xuICAgICAgICAvLyB0byBgc2l6ZWAuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIENyZWF0ZSBndXR0ZXIgZWxlbWVudHMgZm9yIGVhY2ggcGFpci5cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICB2YXIgZ3V0dGVyRWxlbWVudCA9IGd1dHRlcihpLCBkaXJlY3Rpb24sIGVsZW1lbnQuZWxlbWVudCk7XG4gICAgICAgICAgICBzZXRHdXR0ZXJTaXplKGd1dHRlckVsZW1lbnQsIGd1dHRlclNpemUsIGkpO1xuXG4gICAgICAgICAgICAvLyBTYXZlIGJvdW5kIGV2ZW50IGxpc3RlbmVyIGZvciByZW1vdmFsIGxhdGVyXG4gICAgICAgICAgICBwYWlyW2d1dHRlclN0YXJ0RHJhZ2dpbmddID0gc3RhcnREcmFnZ2luZy5iaW5kKHBhaXIpO1xuXG4gICAgICAgICAgICAvLyBBdHRhY2ggYm91bmQgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgICAgIGd1dHRlckVsZW1lbnRbYWRkRXZlbnRMaXN0ZW5lcl0oXG4gICAgICAgICAgICAgICAgJ21vdXNlZG93bicsXG4gICAgICAgICAgICAgICAgcGFpcltndXR0ZXJTdGFydERyYWdnaW5nXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGd1dHRlckVsZW1lbnRbYWRkRXZlbnRMaXN0ZW5lcl0oXG4gICAgICAgICAgICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgICAgICAgICAgIHBhaXJbZ3V0dGVyU3RhcnREcmFnZ2luZ11cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZ3V0dGVyRWxlbWVudCwgZWxlbWVudC5lbGVtZW50KTtcblxuICAgICAgICAgICAgcGFpci5ndXR0ZXIgPSBndXR0ZXJFbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0RWxlbWVudFNpemUoXG4gICAgICAgICAgICBlbGVtZW50LmVsZW1lbnQsXG4gICAgICAgICAgICBlbGVtZW50LnNpemUsXG4gICAgICAgICAgICBnZXRHdXR0ZXJTaXplKFxuICAgICAgICAgICAgICAgIGd1dHRlclNpemUsXG4gICAgICAgICAgICAgICAgaSA9PT0gMCxcbiAgICAgICAgICAgICAgICBpID09PSBpZHMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICBndXR0ZXJBbGlnblxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBBZnRlciB0aGUgZmlyc3QgaXRlcmF0aW9uLCBhbmQgd2UgaGF2ZSBhIHBhaXIgb2JqZWN0LCBhcHBlbmQgaXQgdG8gdGhlXG4gICAgICAgIC8vIGxpc3Qgb2YgcGFpcnMuXG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgcGFpcnMucHVzaChwYWlyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtZW50XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGp1c3RUb01pbihlbGVtZW50KSB7XG4gICAgICAgIHZhciBpc0xhc3QgPSBlbGVtZW50LmkgPT09IHBhaXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIHBhaXIgPSBpc0xhc3QgPyBwYWlyc1tlbGVtZW50LmkgLSAxXSA6IHBhaXJzW2VsZW1lbnQuaV07XG5cbiAgICAgICAgY2FsY3VsYXRlU2l6ZXMuY2FsbChwYWlyKTtcblxuICAgICAgICB2YXIgc2l6ZSA9IGlzTGFzdFxuICAgICAgICAgICAgPyBwYWlyLnNpemUgLSBlbGVtZW50Lm1pblNpemUgLSBwYWlyW2JHdXR0ZXJTaXplXVxuICAgICAgICAgICAgOiBlbGVtZW50Lm1pblNpemUgKyBwYWlyW2FHdXR0ZXJTaXplXTtcblxuICAgICAgICBhZGp1c3QuY2FsbChwYWlyLCBzaXplKTtcbiAgICB9XG5cbiAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBjb21wdXRlZFNpemUgPSBlbGVtZW50LmVsZW1lbnRbZ2V0Qm91bmRpbmdDbGllbnRSZWN0XSgpW2RpbWVuc2lvbl07XG5cbiAgICAgICAgaWYgKGNvbXB1dGVkU2l6ZSA8IGVsZW1lbnQubWluU2l6ZSkge1xuICAgICAgICAgICAgaWYgKGV4cGFuZFRvTWluKSB7XG4gICAgICAgICAgICAgICAgYWRqdXN0VG9NaW4oZWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGVsZW1lbnQubWluU2l6ZSA9IGNvbXB1dGVkU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gc2V0U2l6ZXMobmV3U2l6ZXMpIHtcbiAgICAgICAgdmFyIHRyaW1tZWQgPSB0cmltVG9NaW4obmV3U2l6ZXMpO1xuICAgICAgICB0cmltbWVkLmZvckVhY2goZnVuY3Rpb24gKG5ld1NpemUsIGkpIHtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaSAtIDFdO1xuXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBlbGVtZW50c1twYWlyLmFdO1xuICAgICAgICAgICAgICAgIHZhciBiID0gZWxlbWVudHNbcGFpci5iXTtcblxuICAgICAgICAgICAgICAgIGEuc2l6ZSA9IHRyaW1tZWRbaSAtIDFdO1xuICAgICAgICAgICAgICAgIGIuc2l6ZSA9IG5ld1NpemU7XG5cbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2l6ZShhLmVsZW1lbnQsIGEuc2l6ZSwgcGFpclthR3V0dGVyU2l6ZV0sIGEuaSk7XG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFNpemUoYi5lbGVtZW50LCBiLnNpemUsIHBhaXJbYkd1dHRlclNpemVdLCBiLmkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXN0cm95KHByZXNlcnZlU3R5bGVzLCBwcmVzZXJ2ZUd1dHRlcikge1xuICAgICAgICBwYWlycy5mb3JFYWNoKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgICAgICBpZiAocHJlc2VydmVHdXR0ZXIgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBwYWlyLnBhcmVudC5yZW1vdmVDaGlsZChwYWlyLmd1dHRlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhaXIuZ3V0dGVyW3JlbW92ZUV2ZW50TGlzdGVuZXJdKFxuICAgICAgICAgICAgICAgICAgICAnbW91c2Vkb3duJyxcbiAgICAgICAgICAgICAgICAgICAgcGFpcltndXR0ZXJTdGFydERyYWdnaW5nXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcGFpci5ndXR0ZXJbcmVtb3ZlRXZlbnRMaXN0ZW5lcl0oXG4gICAgICAgICAgICAgICAgICAgICd0b3VjaHN0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgcGFpcltndXR0ZXJTdGFydERyYWdnaW5nXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmVzZXJ2ZVN0eWxlcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGVsZW1lbnRTdHlsZShcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uLFxuICAgICAgICAgICAgICAgICAgICBwYWlyLmEuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgcGFpclthR3V0dGVyU2l6ZV1cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc3R5bGUpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbcGFpci5hXS5lbGVtZW50LnN0eWxlW3Byb3BdID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzW3BhaXIuYl0uZWxlbWVudC5zdHlsZVtwcm9wXSA9ICcnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzZXRTaXplczogc2V0U2l6ZXMsXG4gICAgICAgIGdldFNpemVzOiBnZXRTaXplcyxcbiAgICAgICAgY29sbGFwc2U6IGZ1bmN0aW9uIGNvbGxhcHNlKGkpIHtcbiAgICAgICAgICAgIGFkanVzdFRvTWluKGVsZW1lbnRzW2ldKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveTogZGVzdHJveSxcbiAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgIHBhaXJzOiBwYWlycyxcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTcGxpdDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/split.js/dist/split.es.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/vendor/Onix/js/codeEditor/grapeCodeEditor.js");
/******/ 	
/******/ })()
;