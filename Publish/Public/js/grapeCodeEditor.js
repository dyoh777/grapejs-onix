/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/vendor/Onix/js/codeEditor/code-editor/index.js":
/*!******************************************************************!*\
  !*** ./resources/vendor/Onix/js/codeEditor/code-editor/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CodeEditor\": () => (/* binding */ CodeEditor)\n/* harmony export */ });\n/* harmony import */ var split_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! split.js */ \"./node_modules/split.js/dist/split.es.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n//Original work Copyright (c) 2018, Duarte Henriques, https://github.com/portablemind/grapesjs-code-editor\n//Modified work Copyright (c) 2020, Brendon Ngirazi,\n//All rights reserved.\n\nvar CodeEditor = /*#__PURE__*/function () {\n  function CodeEditor(editor, opts) {\n    _classCallCheck(this, CodeEditor);\n\n    this.editor = editor;\n    this.$ = editor.$;\n    this.pfx = editor.getConfig('stylePrefix');\n    this.opts = opts;\n    this.canvas = this.findWithinEditor(\".\".concat(this.pfx, \"cv-canvas\"));\n    this.panelViews = opts.appendTo ? this.$(opts.appendTo) : this.findWithinEditor(\".\".concat(this.pfx, \"pn-\").concat(opts.panelId));\n    this.isShowing = true;\n  }\n\n  _createClass(CodeEditor, [{\n    key: \"findPanel\",\n    value: function findPanel() {\n      var pn = this.editor.Panels;\n      var id = this.opts.panelId;\n      var panel = pn.getPanel(id) || pn.addPanel({\n        id: id\n      });\n      return panel;\n    }\n  }, {\n    key: \"findWithinEditor\",\n    value: function findWithinEditor(selector) {\n      return this.$(selector, this.editor.getEl());\n    }\n  }, {\n    key: \"buildCodeEditor\",\n    value: function buildCodeEditor(type) {\n      var editor = this.editor,\n          opts = this.opts;\n      return editor.CodeManager.createViewer(_objectSpread({\n        codeName: type === 'html' ? 'htmlmixed' : 'css',\n        theme: 'hopscotch',\n        readOnly: 0,\n        autoBeautify: 1,\n        autoCloseTags: 1,\n        autoCloseBrackets: 1,\n        styleActiveLine: 1,\n        smartIndent: 1\n      }, opts.codeViewOptions));\n    }\n  }, {\n    key: \"buildSection\",\n    value: function buildSection(type, codeViewer) {\n      var $ = this.$,\n          pfx = this.pfx,\n          opts = this.opts;\n      var section = $('<section></section>');\n      var btnText = type === 'html' ? opts.htmlBtnText : opts.cssBtnText;\n      var cleanCssBtn = opts.cleanCssBtn && type === 'css' ? \"<button class=\\\"cp-delete-\".concat(type, \" \").concat(pfx, \"btn-prim\\\">\").concat(opts.cleanCssBtnText, \"</button>\") : '';\n      section.append($(\"\\n            <div class=\\\"codepanel-separator\\\">\\n                <div class=\\\"codepanel-label\\\">\".concat(type, \"</div>\\n                <div class=\\\"cp-btn-container\\\">\\n                    \").concat(cleanCssBtn, \"\\n                    <button class=\\\"cp-apply-\").concat(type, \" \").concat(pfx, \"btn-prim\\\">\").concat(btnText, \"</button>\\n                </div>\\n            </div>\")));\n      var codeViewerEl = codeViewer.getElement();\n      codeViewerEl.style.height = 'calc(100% - 30px)';\n      section.append(codeViewerEl);\n      this.codePanel.append(section);\n      return section.get(0);\n    }\n  }, {\n    key: \"buildCodePanel\",\n    value: function buildCodePanel() {\n      var _this = this;\n\n      var $ = this.$,\n          editor = this.editor;\n      var panel = this.opts.panelId ? this.findPanel() : 0;\n      this.codePanel = $('<div></div>');\n      this.codePanel.addClass('code-panel');\n      this.htmlCodeEditor = this.buildCodeEditor('html');\n      this.cssCodeEditor = this.buildCodeEditor('css');\n      var sections = [this.buildSection('html', this.htmlCodeEditor), this.buildSection('css', this.cssCodeEditor)];\n      panel && !this.opts.appendTo && panel.set('appendContent', this.codePanel).trigger('change:appendContent');\n      this.opts.appendTo && $(this.opts.appendTo).append(this.codePanel);\n      this.updateEditorContents();\n      this.findWithinEditor('.cp-apply-html').get(0).addEventListener('click', this.updateHtml.bind(this));\n\n      if (!this.opts.inlineCss) {\n        this.findWithinEditor('.cp-apply-css').get(0).addEventListener('click', this.updateCss.bind(this));\n      }\n\n      (0,split_js__WEBPACK_IMPORTED_MODULE_0__.default)(sections, {\n        direction: 'vertical',\n        sizes: [50, 50],\n        minSize: 100,\n        gutterSize: 1,\n        onDragEnd: this.refreshEditors.bind(this)\n      });\n      editor.on('component:update', function (model) {\n        return _this.updateEditorContents();\n      });\n    }\n  }, {\n    key: \"showCodePanel\",\n    value: function showCodePanel() {\n      this.isShowing = true;\n      this.updateEditorContents();\n      this.codePanel.css('display', 'block'); // make sure editor is aware of width change after the 300ms effect ends\n\n      setTimeout(this.refreshEditors.bind(this), 320);\n      this.panelViews.css('width', this.opts.openState.pn);\n      this.canvas.css('width', this.opts.openState.cv);\n    }\n  }, {\n    key: \"hideCodePanel\",\n    value: function hideCodePanel() {\n      if (this.codePanel) this.codePanel.css('display', 'none');\n      this.panelViews.css('width', this.opts.closedState.pn);\n      this.canvas.css('width', this.opts.closedState.cv);\n      this.isShowing = false;\n    }\n  }, {\n    key: \"refreshEditors\",\n    value: function refreshEditors() {\n      this.htmlCodeEditor.refresh();\n      this.cssCodeEditor.refresh();\n    }\n  }, {\n    key: \"updateHtml\",\n    value: function updateHtml() {\n      var htmlCode = this.htmlCodeEditor.editor.getValue();\n      if (!htmlCode || htmlCode === this.previousHtmlCode) return;\n      this.previousHtmlCode = htmlCode;\n      var rootNode = this.editor.LayerManager.getRoot();\n      rootNode.components(htmlCode);\n      console.log(this.senderBtn);\n      this.senderBtn.set('active', false);\n      console.log(this.senderBtn);\n      this.hideCodePanel();\n    }\n  }, {\n    key: \"updateCss\",\n    value: function updateCss() {\n      var cssCode = this.cssCodeEditor.getContent().trim();\n      if (!cssCode || cssCode === this.previousCssCode) return;\n      this.parseRemove(cssCode);\n      this.previousCssCode = cssCode;\n      this.editor.Components.addComponent(\"<style>\".concat(cssCode, \"</style>\"));\n    }\n  }, {\n    key: \"deleteSelectedCss\",\n    value: function deleteSelectedCss() {\n      var _this2 = this;\n\n      var selections = this.cssCodeEditor.editor.getSelections();\n      selections.forEach(function (selection) {\n        return _this2.parseRemove(selection);\n      });\n      this.cssCodeEditor.editor.deleteH();\n    }\n  }, {\n    key: \"parseRemove\",\n    value: function parseRemove(removeCss) {\n      var _this3 = this;\n\n      var editor = this.editor;\n      var cssc = editor.CssComposer;\n      var allRules = cssc.getAll();\n      editor.Parser.parseCss(removeCss).forEach(function (p) {\n        var config = {\n          singleAtRule: p.singleAtRule,\n          atRuleType: p.atRuleType,\n          mediaText: p.mediaText,\n          state: p.state\n        };\n        p.selectors.length && p.selectors.forEach(function (selector) {\n          _this3.removeSelector(selector, allRules, cssc, config);\n        });\n        p.selectorsAdd && p.selectorsAdd.split(', ').forEach(function (selector) {\n          _this3.removeSelector(selector, allRules, cssc, config);\n        });\n      });\n    }\n  }, {\n    key: \"removeSelector\",\n    value: function removeSelector(rule, allRules, cssc) {\n      var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var singleAtRule = opts.singleAtRule,\n          atRuleType = opts.atRuleType,\n          mediaText = opts.mediaText,\n          state = opts.state;\n      var toRemove = allRules.filter(function (r) {\n        if (atRuleType && mediaText) return function (r) {\n          return r.get('atRuleType') == atRuleType && r.get('mediaText') == mediaText;\n        };else if (atRuleType && singleAtRule) return function (r) {\n          return r.get('atRuleType') == atRuleType && r.get('singleAtRule') == singleAtRule;\n        };else if (state) return r == cssc.getRule(\"\".concat(rule, \":\").concat(state));\n        return r == cssc.getRule(rule);\n      });\n      allRules.remove(toRemove);\n    }\n  }, {\n    key: \"updateEditorContents\",\n    value: function updateEditorContents() {\n      if (!this.isShowing) return;\n      this.component = this.editor.getSelected();\n\n      if (this.component) {\n        this.htmlCodeEditor.setContent(this.getComponentHtml(this.component));\n        this.cssCodeEditor.setContent(this.editor.CodeManager.getCode(this.component, 'css', {\n          cssc: this.editor.CssComposer\n        }));\n      }\n    }\n  }, {\n    key: \"getComponentHtml\",\n    value: function getComponentHtml(component) {\n      var pfx = this.pfx,\n          opts = this.opts;\n      var result = '';\n      var componentEl = component.getEl();\n      !opts.clearData && componentEl.classList.remove(\"\".concat(pfx, \"selected\"));\n      var html = opts.clearData ? component.toHTML() : componentEl.id === 'wrapper' ? componentEl.innerHTML : componentEl.outerHTML;\n      !opts.clearData && componentEl.classList.add(\"\".concat(pfx, \"selected\"));\n      result += html;\n      var js = opts.editJs ? component.getScriptString() : '';\n      result += js ? \"<script>\".concat(js, \"</script>\") : '';\n      return result;\n    }\n  }]);\n\n  return CodeEditor;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvdmVuZG9yL09uaXgvanMvY29kZUVkaXRvci9jb2RlLWVkaXRvci9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRU8sSUFBTUMsVUFBYjtBQUNJLHNCQUFZQyxNQUFaLEVBQW9CQyxJQUFwQixFQUEwQjtBQUFBOztBQUN0QixTQUFLRCxNQUFMLEdBQWtCQSxNQUFsQjtBQUNBLFNBQUtFLENBQUwsR0FBa0JGLE1BQU0sQ0FBQ0UsQ0FBekI7QUFDQSxTQUFLQyxHQUFMLEdBQWtCSCxNQUFNLENBQUNJLFNBQVAsQ0FBaUIsYUFBakIsQ0FBbEI7QUFDQSxTQUFLSCxJQUFMLEdBQWtCQSxJQUFsQjtBQUNBLFNBQUtJLE1BQUwsR0FBa0IsS0FBS0MsZ0JBQUwsWUFBMEIsS0FBS0gsR0FBL0IsZUFBbEI7QUFDQSxTQUFLSSxVQUFMLEdBQWtCTixJQUFJLENBQUNPLFFBQUwsR0FBZ0IsS0FBS04sQ0FBTCxDQUFPRCxJQUFJLENBQUNPLFFBQVosQ0FBaEIsR0FDZCxLQUFLRixnQkFBTCxZQUEwQixLQUFLSCxHQUEvQixnQkFBd0NGLElBQUksQ0FBQ1EsT0FBN0MsRUFESjtBQUVBLFNBQUtDLFNBQUwsR0FBaUIsSUFBakI7QUFDSDs7QUFWTDtBQUFBO0FBQUEsV0FZSSxxQkFBWTtBQUNSLFVBQU1DLEVBQUUsR0FBRyxLQUFLWCxNQUFMLENBQVlZLE1BQXZCO0FBQ0EsVUFBTUMsRUFBRSxHQUFHLEtBQUtaLElBQUwsQ0FBVVEsT0FBckI7QUFDQSxVQUFNSyxLQUFLLEdBQUdILEVBQUUsQ0FBQ0ksUUFBSCxDQUFZRixFQUFaLEtBQW1CRixFQUFFLENBQUNLLFFBQUgsQ0FBWTtBQUFFSCxRQUFBQSxFQUFFLEVBQUZBO0FBQUYsT0FBWixDQUFqQztBQUNBLGFBQU9DLEtBQVA7QUFDSDtBQWpCTDtBQUFBO0FBQUEsV0FtQkksMEJBQWlCRyxRQUFqQixFQUEyQjtBQUN2QixhQUFPLEtBQUtmLENB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LEdBQWNmLFNBQVMsQ0FBQ2dCLGVBQVYsRUFBZCxHQUE0QyxFQUF2RDtBQUNBWCxNQUFBQSxNQUFNLElBQUlTLEVBQUUscUJBQWNBLEVBQWQsaUJBQThCLEVBQTFDO0FBRUEsYUFBT1QsTUFBUDtBQUNIO0FBcE5MOztBQUFBO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdmVuZG9yL09uaXgvanMvY29kZUVkaXRvci9jb2RlLWVkaXRvci9pbmRleC5qcz9hMmMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vT3JpZ2luYWwgd29yayBDb3B5cmlnaHQgKGMpIDIwMTgsIER1YXJ0ZSBIZW5yaXF1ZXMsIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3J0YWJsZW1pbmQvZ3JhcGVzanMtY29kZS1lZGl0b3Jcbi8vTW9kaWZpZWQgd29yayBDb3B5cmlnaHQgKGMpIDIwMjAsIEJyZW5kb24gTmdpcmF6aSxcbi8vQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuaW1wb3J0IFNwbGl0IGZyb20gJ3NwbGl0LmpzJztcblxuZXhwb3J0IGNsYXNzIENvZGVFZGl0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGVkaXRvciwgb3B0cykge1xuICAgICAgICB0aGlzLmVkaXRvciAgICAgPSBlZGl0b3I7XG4gICAgICAgIHRoaXMuJCAgICAgICAgICA9IGVkaXRvci4kO1xuICAgICAgICB0aGlzLnBmeCAgICAgICAgPSBlZGl0b3IuZ2V0Q29uZmlnKCdzdHlsZVByZWZpeCcpO1xuICAgICAgICB0aGlzLm9wdHMgICAgICAgPSBvcHRzO1xuICAgICAgICB0aGlzLmNhbnZhcyAgICAgPSB0aGlzLmZpbmRXaXRoaW5FZGl0b3IoYC4ke3RoaXMucGZ4fWN2LWNhbnZhc2ApO1xuICAgICAgICB0aGlzLnBhbmVsVmlld3MgPSBvcHRzLmFwcGVuZFRvID8gdGhpcy4kKG9wdHMuYXBwZW5kVG8pIDpcbiAgICAgICAgICAgIHRoaXMuZmluZFdpdGhpbkVkaXRvcihgLiR7dGhpcy5wZnh9cG4tJHtvcHRzLnBhbmVsSWR9YCk7XG4gICAgICAgIHRoaXMuaXNTaG93aW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmaW5kUGFuZWwoKSB7XG4gICAgICAgIGNvbnN0IHBuID0gdGhpcy5lZGl0b3IuUGFuZWxzO1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMub3B0cy5wYW5lbElkO1xuICAgICAgICBjb25zdCBwYW5lbCA9IHBuLmdldFBhbmVsKGlkKSB8fCBwbi5hZGRQYW5lbCh7IGlkIH0pO1xuICAgICAgICByZXR1cm4gcGFuZWw7XG4gICAgfVxuXG4gICAgZmluZFdpdGhpbkVkaXRvcihzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcy4kKHNlbGVjdG9yLCB0aGlzLmVkaXRvci5nZXRFbCgpKTtcbiAgICB9XG5cbiAgICBidWlsZENvZGVFZGl0b3IodHlwZSkge1xuICAgICAgICBjb25zdCB7IGVkaXRvciwgb3B0cyB9ID0gdGhpcztcblxuICAgICAgICByZXR1cm4gZWRpdG9yLkNvZGVNYW5hZ2VyLmNyZWF0ZVZpZXdlcih7XG4gICAgICAgICAgICBjb2RlTmFtZTogdHlwZSA9PT0gJ2h0bWwnID8gJ2h0bWxtaXhlZCcgOiAnY3NzJyxcbiAgICAgICAgICAgIHRoZW1lOiAnaG9wc2NvdGNoJyxcbiAgICAgICAgICAgIHJlYWRPbmx5OiAwLFxuICAgICAgICAgICAgYXV0b0JlYXV0aWZ5OiAxLFxuICAgICAgICAgICAgYXV0b0Nsb3NlVGFnczogMSxcbiAgICAgICAgICAgIGF1dG9DbG9zZUJyYWNrZXRzOiAxLFxuICAgICAgICAgICAgc3R5bGVBY3RpdmVMaW5lOiAxLFxuICAgICAgICAgICAgc21hcnRJbmRlbnQ6IDEsXG4gICAgICAgICAgICAuLi5vcHRzLmNvZGVWaWV3T3B0aW9uc1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBidWlsZFNlY3Rpb24odHlwZSwgY29kZVZpZXdlcikge1xuICAgICAgICBjb25zdCB7ICQsIHBmeCwgb3B0cyB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2VjdGlvbiA9ICQoJzxzZWN0aW9uPjwvc2VjdGlvbj4nKTtcbiAgICAgICAgY29uc3QgYnRuVGV4dCA9IHR5cGUgPT09ICdodG1sJyA/IG9wdHMuaHRtbEJ0blRleHQgOiBvcHRzLmNzc0J0blRleHQ7XG4gICAgICAgIGNvbnN0IGNsZWFuQ3NzQnRuID0gKG9wdHMuY2xlYW5Dc3NCdG4gJiYgdHlwZSA9PT0gJ2NzcycpID9cbiAgICAgICAgICAgIGA8YnV0dG9uIGNsYXNzPVwiY3AtZGVsZXRlLSR7dHlwZX0gJHtwZnh9YnRuLXByaW1cIj4ke29wdHMuY2xlYW5Dc3NCdG5UZXh0fTwvYnV0dG9uPmAgOiAnJztcbiAgICAgICAgc2VjdGlvbi5hcHBlbmQoJChgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29kZXBhbmVsLXNlcGFyYXRvclwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2RlcGFuZWwtbGFiZWxcIj4ke3R5cGV9PC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNwLWJ0bi1jb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgJHtjbGVhbkNzc0J0bn1cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImNwLWFwcGx5LSR7dHlwZX0gJHtwZnh9YnRuLXByaW1cIj4ke2J0blRleHR9PC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5gKSk7XG4gICAgICAgIGNvbnN0IGNvZGVWaWV3ZXJFbCA9IGNvZGVWaWV3ZXIuZ2V0RWxlbWVudCgpO1xuICAgICAgICBjb2RlVmlld2VyRWwuc3R5bGUuaGVpZ2h0ID0gJ2NhbGMoMTAwJSAtIDMwcHgpJztcbiAgICAgICAgc2VjdGlvbi5hcHBlbmQoY29kZVZpZXdlckVsKTtcbiAgICAgICAgdGhpcy5jb2RlUGFuZWwuYXBwZW5kKHNlY3Rpb24pO1xuICAgICAgICByZXR1cm4gc2VjdGlvbi5nZXQoMCk7XG4gICAgfVxuXG4gICAgYnVpbGRDb2RlUGFuZWwoKSB7XG4gICAgICAgIGNvbnN0IHsgJCwgZWRpdG9yIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBwYW5lbCA9IHRoaXMub3B0cy5wYW5lbElkID8gdGhpcy5maW5kUGFuZWwoKSA6IDA7XG4gICAgICAgIHRoaXMuY29kZVBhbmVsID0gJCgnPGRpdj48L2Rpdj4nKTtcbiAgICAgICAgdGhpcy5jb2RlUGFuZWwuYWRkQ2xhc3MoJ2NvZGUtcGFuZWwnKTtcblxuICAgICAgICB0aGlzLmh0bWxDb2RlRWRpdG9yID0gdGhpcy5idWlsZENvZGVFZGl0b3IoJ2h0bWwnKTtcbiAgICAgICAgdGhpcy5jc3NDb2RlRWRpdG9yID0gdGhpcy5idWlsZENvZGVFZGl0b3IoJ2NzcycpO1xuXG4gICAgICAgIGNvbnN0IHNlY3Rpb25zID0gW3RoaXMuYnVpbGRTZWN0aW9uKCdodG1sJywgdGhpcy5odG1sQ29kZUVkaXRvciksXG4gICAgICAgICAgICB0aGlzLmJ1aWxkU2VjdGlvbignY3NzJywgdGhpcy5jc3NDb2RlRWRpdG9yKVxuICAgICAgICBdO1xuXG4gICAgICAgIHBhbmVsICYmICF0aGlzLm9wdHMuYXBwZW5kVG8gJiZcbiAgICAgICAgICAgIHBhbmVsLnNldCgnYXBwZW5kQ29udGVudCcsIHRoaXMuY29kZVBhbmVsKS50cmlnZ2VyKCdjaGFuZ2U6YXBwZW5kQ29udGVudCcpO1xuICAgICAgICB0aGlzLm9wdHMuYXBwZW5kVG8gJiYgJCh0aGlzLm9wdHMuYXBwZW5kVG8pLmFwcGVuZCh0aGlzLmNvZGVQYW5lbCk7XG4gICAgICAgIHRoaXMudXBkYXRlRWRpdG9yQ29udGVudHMoKTtcblxuICAgICAgICB0aGlzLmZpbmRXaXRoaW5FZGl0b3IoJy5jcC1hcHBseS1odG1sJylcbiAgICAgICAgLmdldCgwKVxuICAgICAgICAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnVwZGF0ZUh0bWwuYmluZCh0aGlzKSk7XG5cbiAgICAgIGlmICghdGhpcy5vcHRzLmlubGluZUNzcykge1xuICAgICAgICB0aGlzLmZpbmRXaXRoaW5FZGl0b3IoJy5jcC1hcHBseS1jc3MnKVxuICAgICAgICAgIC5nZXQoMClcbiAgICAgICAgICAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnVwZGF0ZUNzcy5iaW5kKHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgICBTcGxpdChzZWN0aW9ucywge1xuICAgICAgICAgICAgZGlyZWN0aW9uOiAndmVydGljYWwnLFxuICAgICAgICAgICAgc2l6ZXM6IFs1MCwgNTBdLFxuICAgICAgICAgICAgbWluU2l6ZTogMTAwLFxuICAgICAgICAgICAgZ3V0dGVyU2l6ZTogMSxcbiAgICAgICAgICAgIG9uRHJhZ0VuZDogdGhpcy5yZWZyZXNoRWRpdG9ycy5iaW5kKHRoaXMpLFxuICAgICAgICB9KTtcblxuICAgICAgICBlZGl0b3Iub24oJ2NvbXBvbmVudDp1cGRhdGUnLCBtb2RlbCA9PiB0aGlzLnVwZGF0ZUVkaXRvckNvbnRlbnRzKCkpO1xuICAgIH1cblxuICAgIHNob3dDb2RlUGFuZWwoKSB7XG4gICAgICAgIHRoaXMuaXNTaG93aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3JDb250ZW50cygpO1xuICAgICAgICB0aGlzLmNvZGVQYW5lbC5jc3MoJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgICAgICAgLy8gbWFrZSBzdXJlIGVkaXRvciBpcyBhd2FyZSBvZiB3aWR0aCBjaGFuZ2UgYWZ0ZXIgdGhlIDMwMG1zIGVmZmVjdCBlbmRzXG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5yZWZyZXNoRWRpdG9ycy5iaW5kKHRoaXMpLCAzMjApO1xuICAgICAgICB0aGlzLnBhbmVsVmlld3MuY3NzKCd3aWR0aCcsIHRoaXMub3B0cy5vcGVuU3RhdGUucG4pO1xuICAgICAgICB0aGlzLmNhbnZhcy5jc3MoJ3dpZHRoJywgdGhpcy5vcHRzLm9wZW5TdGF0ZS5jdik7XG4gICAgfVxuXG4gICAgaGlkZUNvZGVQYW5lbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29kZVBhbmVsKSB0aGlzLmNvZGVQYW5lbC5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgICB0aGlzLnBhbmVsVmlld3MuY3NzKCd3aWR0aCcsIHRoaXMub3B0cy5jbG9zZWRTdGF0ZS5wbik7XG4gICAgICAgIHRoaXMuY2FudmFzLmNzcygnd2lkdGgnLCB0aGlzLm9wdHMuY2xvc2VkU3RhdGUuY3YpO1xuICAgICAgICB0aGlzLmlzU2hvd2luZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJlZnJlc2hFZGl0b3JzKCkge1xuICAgICAgICB0aGlzLmh0bWxDb2RlRWRpdG9yLnJlZnJlc2goKTtcbiAgICAgICAgdGhpcy5jc3NDb2RlRWRpdG9yLnJlZnJlc2goKTtcbiAgICB9XG5cbiAgICB1cGRhdGVIdG1sKCkge1xuICAgICAgICBjb25zdCBodG1sQ29kZSA9IHRoaXMuaHRtbENvZGVFZGl0b3IuZWRpdG9yLmdldFZhbHVlKCk7XG4gICAgICAgIGlmICghaHRtbENvZGUgfHwgaHRtbENvZGUgPT09IHRoaXMucHJldmlvdXNIdG1sQ29kZSkgcmV0dXJuO1xuICAgICAgICB0aGlzLnByZXZpb3VzSHRtbENvZGUgPSBodG1sQ29kZTtcbiAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSB0aGlzLmVkaXRvci5MYXllck1hbmFnZXIuZ2V0Um9vdCgpO1xuICAgICAgICByb290Tm9kZS5jb21wb25lbnRzKGh0bWxDb2RlKTtcblxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnNlbmRlckJ0bik7XG4gICAgICAgIHRoaXMuc2VuZGVyQnRuLnNldCgnYWN0aXZlJywgZmFsc2UpO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnNlbmRlckJ0bik7XG5cbiAgICAgICAgdGhpcy5oaWRlQ29kZVBhbmVsKCk7XG4gICAgICB9XG5cbiAgICB1cGRhdGVDc3MoKSB7XG4gICAgICAgIGNvbnN0IGNzc0NvZGUgPSB0aGlzLmNzc0NvZGVFZGl0b3IuZ2V0Q29udGVudCgpLnRyaW0oKTtcbiAgICAgICAgaWYgKCFjc3NDb2RlIHx8IGNzc0NvZGUgPT09IHRoaXMucHJldmlvdXNDc3NDb2RlKSByZXR1cm47XG4gICAgICAgIHRoaXMucGFyc2VSZW1vdmUoY3NzQ29kZSk7XG4gICAgICAgIHRoaXMucHJldmlvdXNDc3NDb2RlID0gY3NzQ29kZTtcbiAgICAgICAgdGhpcy5lZGl0b3IuQ29tcG9uZW50cy5hZGRDb21wb25lbnQoYDxzdHlsZT4ke2Nzc0NvZGV9PC9zdHlsZT5gKTtcbiAgICB9XG5cbiAgICBkZWxldGVTZWxlY3RlZENzcygpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9ucyA9IHRoaXMuY3NzQ29kZUVkaXRvci5lZGl0b3IuZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgICBzZWxlY3Rpb25zLmZvckVhY2goc2VsZWN0aW9uID0+IHRoaXMucGFyc2VSZW1vdmUoc2VsZWN0aW9uKSk7XG4gICAgICAgIHRoaXMuY3NzQ29kZUVkaXRvci5lZGl0b3IuZGVsZXRlSCgpO1xuICAgIH1cblxuICAgIHBhcnNlUmVtb3ZlKHJlbW92ZUNzcykge1xuICAgICAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgY3NzYyA9IGVkaXRvci5Dc3NDb21wb3NlclxuICAgICAgICBjb25zdCBhbGxSdWxlcyA9IGNzc2MuZ2V0QWxsKCk7XG4gICAgICAgIGVkaXRvci5QYXJzZXIucGFyc2VDc3MocmVtb3ZlQ3NzKS5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgIHNpbmdsZUF0UnVsZTogcC5zaW5nbGVBdFJ1bGUsXG4gICAgICAgICAgICAgICAgYXRSdWxlVHlwZTogcC5hdFJ1bGVUeXBlLFxuICAgICAgICAgICAgICAgIG1lZGlhVGV4dDogcC5tZWRpYVRleHQsXG4gICAgICAgICAgICAgICAgc3RhdGU6IHAuc3RhdGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwLnNlbGVjdG9ycy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBwLnNlbGVjdG9ycy5mb3JFYWNoKHNlbGVjdG9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVTZWxlY3RvcihzZWxlY3RvciwgYWxsUnVsZXMsIGNzc2MsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwLnNlbGVjdG9yc0FkZCAmJlxuICAgICAgICAgICAgICAgIHAuc2VsZWN0b3JzQWRkLnNwbGl0KCcsICcpLmZvckVhY2goc2VsZWN0b3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVNlbGVjdG9yKHNlbGVjdG9yLCBhbGxSdWxlcywgY3NzYywgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlU2VsZWN0b3IocnVsZSwgYWxsUnVsZXMsIGNzc2MsIG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IHNpbmdsZUF0UnVsZSwgYXRSdWxlVHlwZSwgbWVkaWFUZXh0LCBzdGF0ZSB9ID0gb3B0cztcbiAgICAgICAgY29uc3QgdG9SZW1vdmUgPSBhbGxSdWxlcy5maWx0ZXIociA9PiB7XG4gICAgICAgICAgICBpZiAoYXRSdWxlVHlwZSAmJiBtZWRpYVRleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHIgPT4gci5nZXQoJ2F0UnVsZVR5cGUnKSA9PSBhdFJ1bGVUeXBlICYmIHIuZ2V0KCdtZWRpYVRleHQnKSA9PSBtZWRpYVRleHQ7XG4gICAgICAgICAgICBlbHNlIGlmIChhdFJ1bGVUeXBlICYmIHNpbmdsZUF0UnVsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gciA9PiByLmdldCgnYXRSdWxlVHlwZScpID09IGF0UnVsZVR5cGUgJiYgci5nZXQoJ3NpbmdsZUF0UnVsZScpID09IHNpbmdsZUF0UnVsZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlKVxuICAgICAgICAgICAgICAgIHJldHVybiByID09IGNzc2MuZ2V0UnVsZShgJHtydWxlfToke3N0YXRlfWApO1xuICAgICAgICAgICAgcmV0dXJuIHIgPT0gY3NzYy5nZXRSdWxlKHJ1bGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgYWxsUnVsZXMucmVtb3ZlKHRvUmVtb3ZlKTtcbiAgICB9XG5cbiAgICB1cGRhdGVFZGl0b3JDb250ZW50cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU2hvd2luZykgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gdGhpcy5lZGl0b3IuZ2V0U2VsZWN0ZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aGlzLmh0bWxDb2RlRWRpdG9yLnNldENvbnRlbnQodGhpcy5nZXRDb21wb25lbnRIdG1sKHRoaXMuY29tcG9uZW50KSk7XG4gICAgICAgICAgICB0aGlzLmNzc0NvZGVFZGl0b3Iuc2V0Q29udGVudCh0aGlzLmVkaXRvci5Db2RlTWFuYWdlci5nZXRDb2RlKHRoaXMuY29tcG9uZW50LCAnY3NzJywge1xuICAgICAgICAgICAgICAgIGNzc2M6IHRoaXMuZWRpdG9yLkNzc0NvbXBvc2VyXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRDb21wb25lbnRIdG1sKGNvbXBvbmVudCkge1xuICAgICAgICBjb25zdCB7IHBmeCwgb3B0cyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICBjb25zdCBjb21wb25lbnRFbCA9IGNvbXBvbmVudC5nZXRFbCgpO1xuXG4gICAgICAgICFvcHRzLmNsZWFyRGF0YSAmJiBjb21wb25lbnRFbC5jbGFzc0xpc3QucmVtb3ZlKGAke3BmeH1zZWxlY3RlZGApO1xuICAgICAgICBjb25zdCBodG1sID0gb3B0cy5jbGVhckRhdGEgPyBjb21wb25lbnQudG9IVE1MKCkgOlxuICAgICAgICAgICAgKGNvbXBvbmVudEVsLmlkID09PSAnd3JhcHBlcicgPyBjb21wb25lbnRFbC5pbm5lckhUTUwgOiBjb21wb25lbnRFbC5vdXRlckhUTUwpO1xuICAgICAgICAhb3B0cy5jbGVhckRhdGEgJiYgY29tcG9uZW50RWwuY2xhc3NMaXN0LmFkZChgJHtwZnh9c2VsZWN0ZWRgKTtcbiAgICAgICAgcmVzdWx0ICs9IGh0bWw7XG5cbiAgICAgICAgY29uc3QganMgPSBvcHRzLmVkaXRKcyA/IGNvbXBvbmVudC5nZXRTY3JpcHRTdHJpbmcoKSA6ICcnO1xuICAgICAgICByZXN1bHQgKz0ganMgPyBgPHNjcmlwdD4ke2pzfTwvc2NyaXB0PmAgOiAnJztcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJTcGxpdCIsIkNvZGVFZGl0b3IiLCJlZGl0b3IiLCJvcHRzIiwiJCIsInBmeCIsImdldENvbmZpZyIsImNhbnZhcyIsImZpbmRXaXRoaW5FZGl0b3IiLCJwYW5lbFZpZXdzIiwiYXBwZW5kVG8iLCJwYW5lbElkIiwiaXNTaG93aW5nIiwicG4iLCJQYW5lbHMiLCJpZCIsInBhbmVsIiwiZ2V0UGFuZWwiLCJhZGRQYW5lbCIsInNlbGVjdG9yIiwiZ2V0RWwiLCJ0eXBlIiwiQ29kZU1hbmFnZXIiLCJjcmVhdGVWaWV3ZXIiLCJjb2RlTmFtZSIsInRoZW1lIiwicmVhZE9ubHkiLCJhdXRvQmVhdXRpZnkiLCJhdXRvQ2xvc2VUYWdzIiwiYXV0b0Nsb3NlQnJhY2tldHMiLCJzdHlsZUFjdGl2ZUxpbmUiLCJzbWFydEluZGVudCIsImNvZGVWaWV3T3B0aW9ucyIsImNvZGVWaWV3ZXIiLCJzZWN0aW9uIiwiYnRuVGV4dCIsImh0bWxCdG5UZXh0IiwiY3NzQnRuVGV4dCIsImNsZWFuQ3NzQnRuIiwiY2xlYW5Dc3NCdG5UZXh0IiwiYXBwZW5kIiwiY29kZVZpZXdlckVsIiwiZ2V0RWxlbWVudCIsInN0eWxlIiwiaGVpZ2h0IiwiY29kZVBhbmVsIiwiZ2V0IiwiZmluZFBhbmVsIiwiYWRkQ2xhc3MiLCJodG1sQ29kZUVkaXRvciIsImJ1aWxkQ29kZUVkaXRvciIsImNzc0NvZGVFZGl0b3IiLCJzZWN0aW9ucyIsImJ1aWxkU2VjdGlvbiIsInNldCIsInRyaWdnZXIiLCJ1cGRhdGVFZGl0b3JDb250ZW50cyIsImFkZEV2ZW50TGlzdGVuZXIiLCJ1cGRhdGVIdG1sIiwiYmluZCIsImlubGluZUNzcyIsInVwZGF0ZUNzcyIsImRpcmVjdGlvbiIsInNpemVzIiwibWluU2l6ZSIsImd1dHRlclNpemUiLCJvbkRyYWdFbmQiLCJyZWZyZXNoRWRpdG9ycyIsIm9uIiwibW9kZWwiLCJjc3MiLCJzZXRUaW1lb3V0Iiwib3BlblN0YXRlIiwiY3YiLCJjbG9zZWRTdGF0ZSIsInJlZnJlc2giLCJodG1sQ29kZSIsImdldFZhbHVlIiwicHJldmlvdXNIdG1sQ29kZSIsInJvb3ROb2RlIiwiTGF5ZXJNYW5hZ2VyIiwiZ2V0Um9vdCIsImNvbXBvbmVudHMiLCJjb25zb2xlIiwibG9nIiwic2VuZGVyQnRuIiwiaGlkZUNvZGVQYW5lbCIsImNzc0NvZGUiLCJnZXRDb250ZW50IiwidHJpbSIsInByZXZpb3VzQ3NzQ29kZSIsInBhcnNlUmVtb3ZlIiwiQ29tcG9uZW50cyIsImFkZENvbXBvbmVudCIsInNlbGVjdGlvbnMiLCJnZXRTZWxlY3Rpb25zIiwiZm9yRWFjaCIsInNlbGVjdGlvbiIsImRlbGV0ZUgiLCJyZW1vdmVDc3MiLCJjc3NjIiwiQ3NzQ29tcG9zZXIiLCJhbGxSdWxlcyIsImdldEFsbCIsIlBhcnNlciIsInBhcnNlQ3NzIiwicCIsImNvbmZpZyIsInNpbmdsZUF0UnVsZSIsImF0UnVsZVR5cGUiLCJtZWRpYVRleHQiLCJzdGF0ZSIsInNlbGVjdG9ycyIsImxlbmd0aCIsInJlbW92ZVNlbGVjdG9yIiwic2VsZWN0b3JzQWRkIiwic3BsaXQiLCJydWxlIiwidG9SZW1vdmUiLCJmaWx0ZXIiLCJyIiwiZ2V0UnVsZSIsInJlbW92ZSIsImNvbXBvbmVudCIsImdldFNlbGVjdGVkIiwic2V0Q29udGVudCIsImdldENvbXBvbmVudEh0bWwiLCJnZXRDb2RlIiwicmVzdWx0IiwiY29tcG9uZW50RWwiLCJjbGVhckRhdGEiLCJjbGFzc0xpc3QiLCJodG1sIiwidG9IVE1MIiwiaW5uZXJIVE1MIiwib3V0ZXJIVE1MIiwiYWRkIiwianMiLCJlZGl0SnMiLCJnZXRTY3JpcHRTdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/vendor/Onix/js/codeEditor/code-editor/index.js\n");

/***/ }),

/***/ "./resources/vendor/Onix/js/codeEditor/commands.js":
/*!*********************************************************!*\
  !*** ./resources/vendor/Onix/js/codeEditor/commands.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _code_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./code-editor */ \"./resources/vendor/Onix/js/codeEditor/code-editor/index.js\");\n/* harmony import */ var _consts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./consts */ \"./resources/vendor/Onix/js/codeEditor/consts.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function (editor, opts) {\n  var cm = editor.Commands;\n  var codeEditor = null;\n  cm.add(_consts__WEBPACK_IMPORTED_MODULE_1__.openCodeStr, {\n    run: function run(editor) {\n      !codeEditor && (codeEditor = new _code_editor__WEBPACK_IMPORTED_MODULE_0__.CodeEditor(editor, opts)) && codeEditor.buildCodePanel();\n      codeEditor.showCodePanel();\n    },\n    stop: function stop(editor) {\n      codeEditor && codeEditor.hideCodePanel();\n    }\n  });\n  cm.add(_consts__WEBPACK_IMPORTED_MODULE_1__.getObject, function (editor, sender) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return new _code_editor__WEBPACK_IMPORTED_MODULE_0__.CodeEditor(editor, _objectSpread(_objectSpread({}, options), opts));\n  });\n  cm.add(_consts__WEBPACK_IMPORTED_MODULE_1__.getConstuctor, function () {\n    return _code_editor__WEBPACK_IMPORTED_MODULE_0__.CodeEditor;\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvdmVuZG9yL09uaXgvanMvY29kZUVkaXRvci9jb21tYW5kcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBRUEsaUVBQWUsVUFBQ0ksTUFBRCxFQUFTQyxJQUFULEVBQWtCO0FBQzdCLE1BQU1DLEVBQUUsR0FBR0YsTUFBTSxDQUFDRyxRQUFsQjtBQUNBLE1BQUlDLFVBQVUsR0FBRyxJQUFqQjtBQUVBRixFQUFBQSxFQUFFLENBQUNHLEdBQUgsQ0FBT1IsZ0RBQVAsRUFBb0I7QUFDaEJTLElBQUFBLEdBQUcsRUFBRSxhQUFBTixNQUFNLEVBQUk7QUFDWCxPQUFDSSxVQUFELEtBQWdCQSxVQUFVLEdBQUcsSUFBSVIsb0RBQUosQ0FBZUksTUFBZixFQUF1QkMsSUFBdkIsQ0FBN0IsS0FBOERHLFVBQVUsQ0FBQ0csY0FBWCxFQUE5RDtBQUNBSCxNQUFBQSxVQUFVLENBQUNJLGFBQVg7QUFDSCxLQUplO0FBS2hCQyxJQUFBQSxJQUFJLEVBQUUsY0FBQVQsTUFBTSxFQUFJO0FBQ1pJLE1BQUFBLFVBQVUsSUFBSUEsVUFBVSxDQUFDTSxhQUFYLEVBQWQ7QUFDSDtBQVBlLEdBQXBCO0FBVUFSLEVBQUFBLEVBQUUsQ0FBQ0csR0FBSCxDQUFPUCw4Q0FBUCxFQUFrQixVQUFDRSxNQUFELEVBQVNXLE1BQVQsRUFBa0M7QUFBQSxRQUFqQkMsT0FBaUIsdUVBQVAsRUFBTztBQUNoRCxXQUFPLElBQUloQixvREFBSixDQUFlSSxNQUFmLGtDQUE0QlksT0FBNUIsR0FBd0NYLElBQXhDLEVBQVA7QUFDSCxHQUZEO0FBSUFDLEVBQUFBLEVBQUUsQ0FBQ0csR0FBSCxDQUFPTixrREFBUCxFQUFzQixZQUFNO0FBQ3hCLFdBQU9ILG9EQUFQO0FBQ0gsR0FGRDtBQUdILENBckJEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3ZlbmRvci9Pbml4L2pzL2NvZGVFZGl0b3IvY29tbWFuZHMuanM/ZTI4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2RlRWRpdG9yIH0gZnJvbSAnLi9jb2RlLWVkaXRvcic7XG5pbXBvcnQgeyBvcGVuQ29kZVN0ciwgZ2V0T2JqZWN0LCBnZXRDb25zdHVjdG9yIH0gZnJvbSAnLi9jb25zdHMnO1xuXG5leHBvcnQgZGVmYXVsdCAoZWRpdG9yLCBvcHRzKSA9PiB7XG4gICAgY29uc3QgY20gPSBlZGl0b3IuQ29tbWFuZHM7XG4gICAgbGV0IGNvZGVFZGl0b3IgPSBudWxsO1xuXG4gICAgY20uYWRkKG9wZW5Db2RlU3RyLCB7XG4gICAgICAgIHJ1bjogZWRpdG9yID0+IHtcbiAgICAgICAgICAgICFjb2RlRWRpdG9yICYmIChjb2RlRWRpdG9yID0gbmV3IENvZGVFZGl0b3IoZWRpdG9yLCBvcHRzKSkgJiYgY29kZUVkaXRvci5idWlsZENvZGVQYW5lbCgpO1xuICAgICAgICAgICAgY29kZUVkaXRvci5zaG93Q29kZVBhbmVsKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0b3A6IGVkaXRvciA9PiB7XG4gICAgICAgICAgICBjb2RlRWRpdG9yICYmIGNvZGVFZGl0b3IuaGlkZUNvZGVQYW5lbCgpO1xuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgY20uYWRkKGdldE9iamVjdCwgKGVkaXRvciwgc2VuZGVyLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2RlRWRpdG9yKGVkaXRvciwgeyAuLi5vcHRpb25zLCAuLi5vcHRzIH0pO1xuICAgIH0pO1xuXG4gICAgY20uYWRkKGdldENvbnN0dWN0b3IsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIENvZGVFZGl0b3I7XG4gICAgfSk7XG59Il0sIm5hbWVzIjpbIkNvZGVFZGl0b3IiLCJvcGVuQ29kZVN0ciIsImdldE9iamVjdCIsImdldENvbnN0dWN0b3IiLCJlZGl0b3IiLCJvcHRzIiwiY20iLCJDb21tYW5kcyIsImNvZGVFZGl0b3IiLCJhZGQiLCJydW4iLCJidWlsZENvZGVQYW5lbCIsInNob3dDb2RlUGFuZWwiLCJzdG9wIiwiaGlkZUNvZGVQYW5lbCIsInNlbmRlciIsIm9wdGlvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/vendor/Onix/js/codeEditor/commands.js\n");

/***/ }),

/***/ "./resources/vendor/Onix/js/codeEditor/consts.js":
/*!*******************************************************!*\
  !*** ./resources/vendor/Onix/js/codeEditor/consts.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"openCodeStr\": () => (/* binding */ openCodeStr),\n/* harmony export */   \"getObject\": () => (/* binding */ getObject),\n/* harmony export */   \"getConstuctor\": () => (/* binding */ getConstuctor)\n/* harmony export */ });\nvar openCodeStr = 'open-code',\n    getObject = 'code-editor-object',\n    getConstuctor = 'code-editor-constructor';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvdmVuZG9yL09uaXgvanMvY29kZUVkaXRvci9jb25zdHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQU8sSUFDSEEsV0FBVyxHQUFHLFdBRFg7QUFBQSxJQUVIQyxTQUFTLEdBQUcsb0JBRlQ7QUFBQSxJQUdIQyxhQUFhLEdBQUcseUJBSGIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdmVuZG9yL09uaXgvanMvY29kZUVkaXRvci9jb25zdHMuanM/MWI5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3RcbiAgICBvcGVuQ29kZVN0ciA9ICdvcGVuLWNvZGUnLFxuICAgIGdldE9iamVjdCA9ICdjb2RlLWVkaXRvci1vYmplY3QnLFxuICAgIGdldENvbnN0dWN0b3IgPSAnY29kZS1lZGl0b3ItY29uc3RydWN0b3InOyJdLCJuYW1lcyI6WyJvcGVuQ29kZVN0ciIsImdldE9iamVjdCIsImdldENvbnN0dWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/vendor/Onix/js/codeEditor/consts.js\n");

/***/ }),

/***/ "./resources/vendor/Onix/js/codeEditor/grapeCodeEditor.js":
/*!****************************************************************!*\
  !*** ./resources/vendor/Onix/js/codeEditor/grapeCodeEditor.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _commands__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commands */ \"./resources/vendor/Onix/js/codeEditor/commands.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\nwindow.grapesjs.plugins.add('code-editor', function (editor) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var options = _objectSpread(_objectSpread({}, {\n    //Panel to append the code editor\n    panelId: 'views-container',\n    //Append to element instead of views-container\n    appendTo: '',\n    //State when open\n    openState: {\n      cv: '65%',\n      pn: '35%'\n    },\n    //State when closed\n    closedState: {\n      cv: '85%',\n      pn: '15%'\n    },\n    //Allow editing of javascript, set allowScripts to true for this to work\n    editJs: false,\n    //Remove component data eg data-gjs-type=\"...\"\n    clearData: false,\n    //Code viewer options\n    codeViewOptions: {},\n    //Used to remove css from the Selector Manager\n    cleanCssBtn: true,\n    //Save HTML button text\n    htmlBtnText: 'Apply',\n    //Save CSS button text\n    cssBtnText: 'Apply',\n    //Clean CSS button text\n    cleanCssBtnText: 'Delete'\n  }), opts); // Load commands\n\n\n  (0,_commands__WEBPACK_IMPORTED_MODULE_0__.default)(editor, options);\n}); // export default (editor, opts = {}) => {\n//     const options = {\n//         ...{\n//             //Panel to append the code editor\n//             panelId: 'views-container',\n//             //Append to element instead of views-container\n//             appendTo: '',\n//             //State when open\n//             openState: {\n//                 cv: '65%',\n//                 pn: '35%'\n//             },\n//             //State when closed\n//             closedState: {\n//                 cv: '85%',\n//                 pn: '15%'\n//             },\n//             //Allow editing of javascript, set allowScripts to true for this to work\n//             editJs: false,\n//             //Remove component data eg data-gjs-type=\"...\"\n//             clearData: false,\n//             //Code viewer options\n//             codeViewOptions: {},\n//             //Used to remove css from the Selector Manager\n//             cleanCssBtn: true,\n//             //Save HTML button text\n//             htmlBtnText: 'Apply',\n//             //Save CSS button text\n//             cssBtnText: 'Apply',\n//             //Clean CSS button text\n//             cleanCssBtnText: 'Delete'\n//         },\n//         ...opts\n//     };\n//     // Load commands\n//     commands(editor, options);\n// };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvdmVuZG9yL09uaXgvanMvY29kZUVkaXRvci9ncmFwZUNvZGVFZGl0b3IuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUVBQyxNQUFNLENBQUNDLFFBQVAsQ0FBZ0JDLE9BQWhCLENBQXdCQyxHQUF4QixDQUE0QixhQUE1QixFQUEyQyxVQUFDQyxNQUFELEVBQXVCO0FBQUEsTUFBZEMsSUFBYyx1RUFBUCxFQUFPOztBQUM5RCxNQUFNQyxPQUFPLG1DQUNOO0FBQ0M7QUFDQUMsSUFBQUEsT0FBTyxFQUFFLGlCQUZWO0FBR0M7QUFDQUMsSUFBQUEsUUFBUSxFQUFFLEVBSlg7QUFLQztBQUNBQyxJQUFBQSxTQUFTLEVBQUU7QUFDUEMsTUFBQUEsRUFBRSxFQUFFLEtBREc7QUFFUEMsTUFBQUEsRUFBRSxFQUFFO0FBRkcsS0FOWjtBQVVDO0FBQ0FDLElBQUFBLFdBQVcsRUFBRTtBQUNURixNQUFBQSxFQUFFLEVBQUUsS0FESztBQUVUQyxNQUFBQSxFQUFFLEVBQUU7QUFGSyxLQVhkO0FBZUM7QUFDQUUsSUFBQUEsTUFBTSxFQUFFLEtBaEJUO0FBaUJDO0FBQ0FDLElBQUFBLFNBQVMsRUFBRSxLQWxCWjtBQW1CQztBQUNBQyxJQUFBQSxlQUFlLEVBQUUsRUFwQmxCO0FBcUJDO0FBQ0FDLElBQUFBLFdBQVcsRUFBRSxJQXRCZDtBQXVCQztBQUNBQyxJQUFBQSxXQUFXLEVBQUUsT0F4QmQ7QUF5QkM7QUFDQUMsSUFBQUEsVUFBVSxFQUFFLE9BMUJiO0FBMkJDO0FBQ0FDLElBQUFBLGVBQWUsRUFBRTtBQTVCbEIsR0FETSxHQStCTmQsSUEvQk0sQ0FBYixDQUQ4RCxDQW1DOUQ7OztBQUNBTixFQUFBQSxrREFBUSxDQUFDSyxNQUFELEVBQVNFLE9BQVQsQ0FBUjtBQUNILENBckNELEdBdUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3ZlbmRvci9Pbml4L2pzL2NvZGVFZGl0b3IvZ3JhcGVDb2RlRWRpdG9yLmpzP2VhMmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNvbW1hbmRzIGZyb20gJy4vY29tbWFuZHMnO1xuXG53aW5kb3cuZ3JhcGVzanMucGx1Z2lucy5hZGQoJ2NvZGUtZWRpdG9yJywgKGVkaXRvciwgb3B0cyA9IHt9KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgLi4ue1xuICAgICAgICAgICAgLy9QYW5lbCB0byBhcHBlbmQgdGhlIGNvZGUgZWRpdG9yXG4gICAgICAgICAgICBwYW5lbElkOiAndmlld3MtY29udGFpbmVyJyxcbiAgICAgICAgICAgIC8vQXBwZW5kIHRvIGVsZW1lbnQgaW5zdGVhZCBvZiB2aWV3cy1jb250YWluZXJcbiAgICAgICAgICAgIGFwcGVuZFRvOiAnJyxcbiAgICAgICAgICAgIC8vU3RhdGUgd2hlbiBvcGVuXG4gICAgICAgICAgICBvcGVuU3RhdGU6IHtcbiAgICAgICAgICAgICAgICBjdjogJzY1JScsXG4gICAgICAgICAgICAgICAgcG46ICczNSUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy9TdGF0ZSB3aGVuIGNsb3NlZFxuICAgICAgICAgICAgY2xvc2VkU3RhdGU6IHtcbiAgICAgICAgICAgICAgICBjdjogJzg1JScsXG4gICAgICAgICAgICAgICAgcG46ICcxNSUnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy9BbGxvdyBlZGl0aW5nIG9mIGphdmFzY3JpcHQsIHNldCBhbGxvd1NjcmlwdHMgdG8gdHJ1ZSBmb3IgdGhpcyB0byB3b3JrXG4gICAgICAgICAgICBlZGl0SnM6IGZhbHNlLFxuICAgICAgICAgICAgLy9SZW1vdmUgY29tcG9uZW50IGRhdGEgZWcgZGF0YS1nanMtdHlwZT1cIi4uLlwiXG4gICAgICAgICAgICBjbGVhckRhdGE6IGZhbHNlLFxuICAgICAgICAgICAgLy9Db2RlIHZpZXdlciBvcHRpb25zXG4gICAgICAgICAgICBjb2RlVmlld09wdGlvbnM6IHt9LFxuICAgICAgICAgICAgLy9Vc2VkIHRvIHJlbW92ZSBjc3MgZnJvbSB0aGUgU2VsZWN0b3IgTWFuYWdlclxuICAgICAgICAgICAgY2xlYW5Dc3NCdG46IHRydWUsXG4gICAgICAgICAgICAvL1NhdmUgSFRNTCBidXR0b24gdGV4dFxuICAgICAgICAgICAgaHRtbEJ0blRleHQ6ICdBcHBseScsXG4gICAgICAgICAgICAvL1NhdmUgQ1NTIGJ1dHRvbiB0ZXh0XG4gICAgICAgICAgICBjc3NCdG5UZXh0OiAnQXBwbHknLFxuICAgICAgICAgICAgLy9DbGVhbiBDU1MgYnV0dG9uIHRleHRcbiAgICAgICAgICAgIGNsZWFuQ3NzQnRuVGV4dDogJ0RlbGV0ZSdcbiAgICAgICAgfSxcbiAgICAgICAgLi4ub3B0c1xuICAgIH07XG5cbiAgICAvLyBMb2FkIGNvbW1hbmRzXG4gICAgY29tbWFuZHMoZWRpdG9yLCBvcHRpb25zKTtcbn0pO1xuXG4vLyBleHBvcnQgZGVmYXVsdCAoZWRpdG9yLCBvcHRzID0ge30pID0+IHtcbi8vICAgICBjb25zdCBvcHRpb25zID0ge1xuLy8gICAgICAgICAuLi57XG4vLyAgICAgICAgICAgICAvL1BhbmVsIHRvIGFwcGVuZCB0aGUgY29kZSBlZGl0b3Jcbi8vICAgICAgICAgICAgIHBhbmVsSWQ6ICd2aWV3cy1jb250YWluZXInLFxuLy8gICAgICAgICAgICAgLy9BcHBlbmQgdG8gZWxlbWVudCBpbnN0ZWFkIG9mIHZpZXdzLWNvbnRhaW5lclxuLy8gICAgICAgICAgICAgYXBwZW5kVG86ICcnLFxuLy8gICAgICAgICAgICAgLy9TdGF0ZSB3aGVuIG9wZW5cbi8vICAgICAgICAgICAgIG9wZW5TdGF0ZToge1xuLy8gICAgICAgICAgICAgICAgIGN2OiAnNjUlJyxcbi8vICAgICAgICAgICAgICAgICBwbjogJzM1JSdcbi8vICAgICAgICAgICAgIH0sXG4vLyAgICAgICAgICAgICAvL1N0YXRlIHdoZW4gY2xvc2VkXG4vLyAgICAgICAgICAgICBjbG9zZWRTdGF0ZToge1xuLy8gICAgICAgICAgICAgICAgIGN2OiAnODUlJyxcbi8vICAgICAgICAgICAgICAgICBwbjogJzE1JSdcbi8vICAgICAgICAgICAgIH0sXG4vLyAgICAgICAgICAgICAvL0FsbG93IGVkaXRpbmcgb2YgamF2YXNjcmlwdCwgc2V0IGFsbG93U2NyaXB0cyB0byB0cnVlIGZvciB0aGlzIHRvIHdvcmtcbi8vICAgICAgICAgICAgIGVkaXRKczogZmFsc2UsXG4vLyAgICAgICAgICAgICAvL1JlbW92ZSBjb21wb25lbnQgZGF0YSBlZyBkYXRhLWdqcy10eXBlPVwiLi4uXCJcbi8vICAgICAgICAgICAgIGNsZWFyRGF0YTogZmFsc2UsXG4vLyAgICAgICAgICAgICAvL0NvZGUgdmlld2VyIG9wdGlvbnNcbi8vICAgICAgICAgICAgIGNvZGVWaWV3T3B0aW9uczoge30sXG4vLyAgICAgICAgICAgICAvL1VzZWQgdG8gcmVtb3ZlIGNzcyBmcm9tIHRoZSBTZWxlY3RvciBNYW5hZ2VyXG4vLyAgICAgICAgICAgICBjbGVhbkNzc0J0bjogdHJ1ZSxcbi8vICAgICAgICAgICAgIC8vU2F2ZSBIVE1MIGJ1dHRvbiB0ZXh0XG4vLyAgICAgICAgICAgICBodG1sQnRuVGV4dDogJ0FwcGx5Jyxcbi8vICAgICAgICAgICAgIC8vU2F2ZSBDU1MgYnV0dG9uIHRleHRcbi8vICAgICAgICAgICAgIGNzc0J0blRleHQ6ICdBcHBseScsXG4vLyAgICAgICAgICAgICAvL0NsZWFuIENTUyBidXR0b24gdGV4dFxuLy8gICAgICAgICAgICAgY2xlYW5Dc3NCdG5UZXh0OiAnRGVsZXRlJ1xuLy8gICAgICAgICB9LFxuLy8gICAgICAgICAuLi5vcHRzXG4vLyAgICAgfTtcblxuLy8gICAgIC8vIExvYWQgY29tbWFuZHNcbi8vICAgICBjb21tYW5kcyhlZGl0b3IsIG9wdGlvbnMpO1xuLy8gfTtcbiJdLCJuYW1lcyI6WyJjb21tYW5kcyIsIndpbmRvdyIsImdyYXBlc2pzIiwicGx1Z2lucyIsImFkZCIsImVkaXRvciIsIm9wdHMiLCJvcHRpb25zIiwicGFuZWxJZCIsImFwcGVuZFRvIiwib3BlblN0YXRlIiwiY3YiLCJwbiIsImNsb3NlZFN0YXRlIiwiZWRpdEpzIiwiY2xlYXJEYXRhIiwiY29kZVZpZXdPcHRpb25zIiwiY2xlYW5Dc3NCdG4iLCJodG1sQnRuVGV4dCIsImNzc0J0blRleHQiLCJjbGVhbkNzc0J0blRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/vendor/Onix/js/codeEditor/grapeCodeEditor.js\n");

/***/ }),

/***/ "./node_modules/split.js/dist/split.es.js":
/*!************************************************!*\
  !*** ./node_modules/split.js/dist/split.es.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// The programming goals of Split.js are to deliver readable, understandable and\n// maintainable code, while at the same time manually optimizing for tiny minified file size,\n// browser compatibility without additional requirements\n// and very few assumptions about the user's page layout.\nvar global = typeof window !== 'undefined' ? window : null;\nvar ssr = global === null;\nvar document = !ssr ? global.document : undefined;\n\n// Save a couple long function names that are used frequently.\n// This optimization saves around 400 bytes.\nvar addEventListener = 'addEventListener';\nvar removeEventListener = 'removeEventListener';\nvar getBoundingClientRect = 'getBoundingClientRect';\nvar gutterStartDragging = '_a';\nvar aGutterSize = '_b';\nvar bGutterSize = '_c';\nvar HORIZONTAL = 'horizontal';\nvar NOOP = function () { return false; };\n\n// Helper function determines which prefixes of CSS calc we need.\n// We only need to do this once on startup, when this anonymous function is called.\n//\n// Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\n// http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\nvar calc = ssr\n    ? 'calc'\n    : ((['', '-webkit-', '-moz-', '-o-']\n          .filter(function (prefix) {\n              var el = document.createElement('div');\n              el.style.cssText = \"width:\" + prefix + \"calc(9px)\";\n\n              return !!el.style.length\n          })\n          .shift()) + \"calc\");\n\n// Helper function checks if its argument is a string-like type\nvar isString = function (v) { return typeof v === 'string' || v instanceof String; };\n\n// Helper function allows elements and string selectors to be used\n// interchangeably. In either case an element is returned. This allows us to\n// do `Split([elem1, elem2])` as well as `Split(['#id1', '#id2'])`.\nvar elementOrSelector = function (el) {\n    if (isString(el)) {\n        var ele = document.querySelector(el);\n        if (!ele) {\n            throw new Error((\"Selector \" + el + \" did not match a DOM element\"))\n        }\n        return ele\n    }\n\n    return el\n};\n\n// Helper function gets a property from the properties object, with a default fallback\nvar getOption = function (options, propName, def) {\n    var value = options[propName];\n    if (value !== undefined) {\n        return value\n    }\n    return def\n};\n\nvar getGutterSize = function (gutterSize, isFirst, isLast, gutterAlign) {\n    if (isFirst) {\n        if (gutterAlign === 'end') {\n            return 0\n        }\n        if (gutterAlign === 'center') {\n            return gutterSize / 2\n        }\n    } else if (isLast) {\n        if (gutterAlign === 'start') {\n            return 0\n        }\n        if (gutterAlign === 'center') {\n            return gutterSize / 2\n        }\n    }\n\n    return gutterSize\n};\n\n// Default options\nvar defaultGutterFn = function (i, gutterDirection) {\n    var gut = document.createElement('div');\n    gut.className = \"gutter gutter-\" + gutterDirection;\n    return gut\n};\n\nvar defaultElementStyleFn = function (dim, size, gutSize) {\n    var style = {};\n\n    if (!isString(size)) {\n        style[dim] = calc + \"(\" + size + \"% - \" + gutSize + \"px)\";\n    } else {\n        style[dim] = size;\n    }\n\n    return style\n};\n\nvar defaultGutterStyleFn = function (dim, gutSize) {\n    var obj;\n\n    return (( obj = {}, obj[dim] = (gutSize + \"px\"), obj ));\n};\n\n// The main function to initialize a split. Split.js thinks about each pair\n// of elements as an independant pair. Dragging the gutter between two elements\n// only changes the dimensions of elements in that pair. This is key to understanding\n// how the following functions operate, since each function is bound to a pair.\n//\n// A pair object is shaped like this:\n//\n// {\n//     a: DOM element,\n//     b: DOM element,\n//     aMin: Number,\n//     bMin: Number,\n//     dragging: Boolean,\n//     parent: DOM element,\n//     direction: 'horizontal' | 'vertical'\n// }\n//\n// The basic sequence:\n//\n// 1. Set defaults to something sane. `options` doesn't have to be passed at all.\n// 2. Initialize a bunch of strings based on the direction we're splitting.\n//    A lot of the behavior in the rest of the library is paramatized down to\n//    rely on CSS strings and classes.\n// 3. Define the dragging helper functions, and a few helpers to go with them.\n// 4. Loop through the elements while pairing them off. Every pair gets an\n//    `pair` object and a gutter.\n// 5. Actually size the pair elements, insert gutters and attach event listeners.\nvar Split = function (idsOption, options) {\n    if ( options === void 0 ) options = {};\n\n    if (ssr) { return {} }\n\n    var ids = idsOption;\n    var dimension;\n    var clientAxis;\n    var position;\n    var positionEnd;\n    var clientSize;\n    var elements;\n\n    // Allow HTMLCollection to be used as an argument when supported\n    if (Array.from) {\n        ids = Array.from(ids);\n    }\n\n    // All DOM elements in the split should have a common parent. We can grab\n    // the first elements parent and hope users read the docs because the\n    // behavior will be whacky otherwise.\n    var firstElement = elementOrSelector(ids[0]);\n    var parent = firstElement.parentNode;\n    var parentStyle = getComputedStyle ? getComputedStyle(parent) : null;\n    var parentFlexDirection = parentStyle ? parentStyle.flexDirection : null;\n\n    // Set default options.sizes to equal percentages of the parent element.\n    var sizes = getOption(options, 'sizes') || ids.map(function () { return 100 / ids.length; });\n\n    // Standardize minSize and maxSize to an array if it isn't already.\n    // This allows minSize and maxSize to be passed as a number.\n    var minSize = getOption(options, 'minSize', 100);\n    var minSizes = Array.isArray(minSize) ? minSize : ids.map(function () { return minSize; });\n    var maxSize = getOption(options, 'maxSize', Infinity);\n    var maxSizes = Array.isArray(maxSize) ? maxSize : ids.map(function () { return maxSize; });\n\n    // Get other options\n    var expandToMin = getOption(options, 'expandToMin', false);\n    var gutterSize = getOption(options, 'gutterSize', 10);\n    var gutterAlign = getOption(options, 'gutterAlign', 'center');\n    var snapOffset = getOption(options, 'snapOffset', 30);\n    var dragInterval = getOption(options, 'dragInterval', 1);\n    var direction = getOption(options, 'direction', HORIZONTAL);\n    var cursor = getOption(\n        options,\n        'cursor',\n        direction === HORIZONTAL ? 'col-resize' : 'row-resize'\n    );\n    var gutter = getOption(options, 'gutter', defaultGutterFn);\n    var elementStyle = getOption(\n        options,\n        'elementStyle',\n        defaultElementStyleFn\n    );\n    var gutterStyle = getOption(options, 'gutterStyle', defaultGutterStyleFn);\n\n    // 2. Initialize a bunch of strings based on the direction we're splitting.\n    // A lot of the behavior in the rest of the library is paramatized down to\n    // rely on CSS strings and classes.\n    if (direction === HORIZONTAL) {\n        dimension = 'width';\n        clientAxis = 'clientX';\n        position = 'left';\n        positionEnd = 'right';\n        clientSize = 'clientWidth';\n    } else if (direction === 'vertical') {\n        dimension = 'height';\n        clientAxis = 'clientY';\n        position = 'top';\n        positionEnd = 'bottom';\n        clientSize = 'clientHeight';\n    }\n\n    // 3. Define the dragging helper functions, and a few helpers to go with them.\n    // Each helper is bound to a pair object that contains its metadata. This\n    // also makes it easy to store references to listeners that that will be\n    // added and removed.\n    //\n    // Even though there are no other functions contained in them, aliasing\n    // this to self saves 50 bytes or so since it's used so frequently.\n    //\n    // The pair object saves metadata like dragging state, position and\n    // event listener references.\n\n    function setElementSize(el, size, gutSize, i) {\n        // Split.js allows setting sizes via numbers (ideally), or if you must,\n        // by string, like '300px'. This is less than ideal, because it breaks\n        // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\n        // make sure you calculate the gutter size by hand.\n        var style = elementStyle(dimension, size, gutSize, i);\n\n        Object.keys(style).forEach(function (prop) {\n            // eslint-disable-next-line no-param-reassign\n            el.style[prop] = style[prop];\n        });\n    }\n\n    function setGutterSize(gutterElement, gutSize, i) {\n        var style = gutterStyle(dimension, gutSize, i);\n\n        Object.keys(style).forEach(function (prop) {\n            // eslint-disable-next-line no-param-reassign\n            gutterElement.style[prop] = style[prop];\n        });\n    }\n\n    function getSizes() {\n        return elements.map(function (element) { return element.size; })\n    }\n\n    // Supports touch events, but not multitouch, so only the first\n    // finger `touches[0]` is counted.\n    function getMousePosition(e) {\n        if ('touches' in e) { return e.touches[0][clientAxis] }\n        return e[clientAxis]\n    }\n\n    // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\n    // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\n    // which allows the viewport to be resized without additional logic.\n    // Element a's size is the same as offset. b's size is total size - a size.\n    // Both sizes are calculated from the initial parent percentage,\n    // then the gutter size is subtracted.\n    function adjust(offset) {\n        var a = elements[this.a];\n        var b = elements[this.b];\n        var percentage = a.size + b.size;\n\n        a.size = (offset / this.size) * percentage;\n        b.size = percentage - (offset / this.size) * percentage;\n\n        setElementSize(a.element, a.size, this[aGutterSize], a.i);\n        setElementSize(b.element, b.size, this[bGutterSize], b.i);\n    }\n\n    // drag, where all the magic happens. The logic is really quite simple:\n    //\n    // 1. Ignore if the pair is not dragging.\n    // 2. Get the offset of the event.\n    // 3. Snap offset to min if within snappable range (within min + snapOffset).\n    // 4. Actually adjust each element in the pair to offset.\n    //\n    // ---------------------------------------------------------------------\n    // |    | <- a.minSize               ||              b.minSize -> |    |\n    // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\n    // |    |  |                         ||                        |  |    |\n    // |    |  |                         ||                        |  |    |\n    // ---------------------------------------------------------------------\n    // | <- this.start                                        this.size -> |\n    function drag(e) {\n        var offset;\n        var a = elements[this.a];\n        var b = elements[this.b];\n\n        if (!this.dragging) { return }\n\n        // Get the offset of the event from the first side of the\n        // pair `this.start`. Then offset by the initial position of the\n        // mouse compared to the gutter size.\n        offset =\n            getMousePosition(e) -\n            this.start +\n            (this[aGutterSize] - this.dragOffset);\n\n        if (dragInterval > 1) {\n            offset = Math.round(offset / dragInterval) * dragInterval;\n        }\n\n        // If within snapOffset of min or max, set offset to min or max.\n        // snapOffset buffers a.minSize and b.minSize, so logic is opposite for both.\n        // Include the appropriate gutter sizes to prevent overflows.\n        if (offset <= a.minSize + snapOffset + this[aGutterSize]) {\n            offset = a.minSize + this[aGutterSize];\n        } else if (\n            offset >=\n            this.size - (b.minSize + snapOffset + this[bGutterSize])\n        ) {\n            offset = this.size - (b.minSize + this[bGutterSize]);\n        }\n\n        if (offset >= a.maxSize - snapOffset + this[aGutterSize]) {\n            offset = a.maxSize + this[aGutterSize];\n        } else if (\n            offset <=\n            this.size - (b.maxSize - snapOffset + this[bGutterSize])\n        ) {\n            offset = this.size - (b.maxSize + this[bGutterSize]);\n        }\n\n        // Actually adjust the size.\n        adjust.call(this, offset);\n\n        // Call the drag callback continously. Don't do anything too intensive\n        // in this callback.\n        getOption(options, 'onDrag', NOOP)(getSizes());\n    }\n\n    // Cache some important sizes when drag starts, so we don't have to do that\n    // continously:\n    //\n    // `size`: The total size of the pair. First + second + first gutter + second gutter.\n    // `start`: The leading side of the first element.\n    //\n    // ------------------------------------------------\n    // |      aGutterSize -> |||                      |\n    // |                     |||                      |\n    // |                     |||                      |\n    // |                     ||| <- bGutterSize       |\n    // ------------------------------------------------\n    // | <- start                             size -> |\n    function calculateSizes() {\n        // Figure out the parent size minus padding.\n        var a = elements[this.a].element;\n        var b = elements[this.b].element;\n\n        var aBounds = a[getBoundingClientRect]();\n        var bBounds = b[getBoundingClientRect]();\n\n        this.size =\n            aBounds[dimension] +\n            bBounds[dimension] +\n            this[aGutterSize] +\n            this[bGutterSize];\n        this.start = aBounds[position];\n        this.end = aBounds[positionEnd];\n    }\n\n    function innerSize(element) {\n        // Return nothing if getComputedStyle is not supported (< IE9)\n        // Or if parent element has no layout yet\n        if (!getComputedStyle) { return null }\n\n        var computedStyle = getComputedStyle(element);\n\n        if (!computedStyle) { return null }\n\n        var size = element[clientSize];\n\n        if (size === 0) { return null }\n\n        if (direction === HORIZONTAL) {\n            size -=\n                parseFloat(computedStyle.paddingLeft) +\n                parseFloat(computedStyle.paddingRight);\n        } else {\n            size -=\n                parseFloat(computedStyle.paddingTop) +\n                parseFloat(computedStyle.paddingBottom);\n        }\n\n        return size\n    }\n\n    // When specifying percentage sizes that are less than the computed\n    // size of the element minus the gutter, the lesser percentages must be increased\n    // (and decreased from the other elements) to make space for the pixels\n    // subtracted by the gutters.\n    function trimToMin(sizesToTrim) {\n        // Try to get inner size of parent element.\n        // If it's no supported, return original sizes.\n        var parentSize = innerSize(parent);\n        if (parentSize === null) {\n            return sizesToTrim\n        }\n\n        if (minSizes.reduce(function (a, b) { return a + b; }, 0) > parentSize) {\n            return sizesToTrim\n        }\n\n        // Keep track of the excess pixels, the amount of pixels over the desired percentage\n        // Also keep track of the elements with pixels to spare, to decrease after if needed\n        var excessPixels = 0;\n        var toSpare = [];\n\n        var pixelSizes = sizesToTrim.map(function (size, i) {\n            // Convert requested percentages to pixel sizes\n            var pixelSize = (parentSize * size) / 100;\n            var elementGutterSize = getGutterSize(\n                gutterSize,\n                i === 0,\n                i === sizesToTrim.length - 1,\n                gutterAlign\n            );\n            var elementMinSize = minSizes[i] + elementGutterSize;\n\n            // If element is too smal, increase excess pixels by the difference\n            // and mark that it has no pixels to spare\n            if (pixelSize < elementMinSize) {\n                excessPixels += elementMinSize - pixelSize;\n                toSpare.push(0);\n                return elementMinSize\n            }\n\n            // Otherwise, mark the pixels it has to spare and return it's original size\n            toSpare.push(pixelSize - elementMinSize);\n            return pixelSize\n        });\n\n        // If nothing was adjusted, return the original sizes\n        if (excessPixels === 0) {\n            return sizesToTrim\n        }\n\n        return pixelSizes.map(function (pixelSize, i) {\n            var newPixelSize = pixelSize;\n\n            // While there's still pixels to take, and there's enough pixels to spare,\n            // take as many as possible up to the total excess pixels\n            if (excessPixels > 0 && toSpare[i] - excessPixels > 0) {\n                var takenPixels = Math.min(\n                    excessPixels,\n                    toSpare[i] - excessPixels\n                );\n\n                // Subtract the amount taken for the next iteration\n                excessPixels -= takenPixels;\n                newPixelSize = pixelSize - takenPixels;\n            }\n\n            // Return the pixel size adjusted as a percentage\n            return (newPixelSize / parentSize) * 100\n        })\n    }\n\n    // stopDragging is very similar to startDragging in reverse.\n    function stopDragging() {\n        var self = this;\n        var a = elements[self.a].element;\n        var b = elements[self.b].element;\n\n        if (self.dragging) {\n            getOption(options, 'onDragEnd', NOOP)(getSizes());\n        }\n\n        self.dragging = false;\n\n        // Remove the stored event listeners. This is why we store them.\n        global[removeEventListener]('mouseup', self.stop);\n        global[removeEventListener]('touchend', self.stop);\n        global[removeEventListener]('touchcancel', self.stop);\n        global[removeEventListener]('mousemove', self.move);\n        global[removeEventListener]('touchmove', self.move);\n\n        // Clear bound function references\n        self.stop = null;\n        self.move = null;\n\n        a[removeEventListener]('selectstart', NOOP);\n        a[removeEventListener]('dragstart', NOOP);\n        b[removeEventListener]('selectstart', NOOP);\n        b[removeEventListener]('dragstart', NOOP);\n\n        a.style.userSelect = '';\n        a.style.webkitUserSelect = '';\n        a.style.MozUserSelect = '';\n        a.style.pointerEvents = '';\n\n        b.style.userSelect = '';\n        b.style.webkitUserSelect = '';\n        b.style.MozUserSelect = '';\n        b.style.pointerEvents = '';\n\n        self.gutter.style.cursor = '';\n        self.parent.style.cursor = '';\n        document.body.style.cursor = '';\n    }\n\n    // startDragging calls `calculateSizes` to store the inital size in the pair object.\n    // It also adds event listeners for mouse/touch events,\n    // and prevents selection while dragging so avoid the selecting text.\n    function startDragging(e) {\n        // Right-clicking can't start dragging.\n        if ('button' in e && e.button !== 0) {\n            return\n        }\n\n        // Alias frequently used variables to save space. 200 bytes.\n        var self = this;\n        var a = elements[self.a].element;\n        var b = elements[self.b].element;\n\n        // Call the onDragStart callback.\n        if (!self.dragging) {\n            getOption(options, 'onDragStart', NOOP)(getSizes());\n        }\n\n        // Don't actually drag the element. We emulate that in the drag function.\n        e.preventDefault();\n\n        // Set the dragging property of the pair object.\n        self.dragging = true;\n\n        // Create two event listeners bound to the same pair object and store\n        // them in the pair object.\n        self.move = drag.bind(self);\n        self.stop = stopDragging.bind(self);\n\n        // All the binding. `window` gets the stop events in case we drag out of the elements.\n        global[addEventListener]('mouseup', self.stop);\n        global[addEventListener]('touchend', self.stop);\n        global[addEventListener]('touchcancel', self.stop);\n        global[addEventListener]('mousemove', self.move);\n        global[addEventListener]('touchmove', self.move);\n\n        // Disable selection. Disable!\n        a[addEventListener]('selectstart', NOOP);\n        a[addEventListener]('dragstart', NOOP);\n        b[addEventListener]('selectstart', NOOP);\n        b[addEventListener]('dragstart', NOOP);\n\n        a.style.userSelect = 'none';\n        a.style.webkitUserSelect = 'none';\n        a.style.MozUserSelect = 'none';\n        a.style.pointerEvents = 'none';\n\n        b.style.userSelect = 'none';\n        b.style.webkitUserSelect = 'none';\n        b.style.MozUserSelect = 'none';\n        b.style.pointerEvents = 'none';\n\n        // Set the cursor at multiple levels\n        self.gutter.style.cursor = cursor;\n        self.parent.style.cursor = cursor;\n        document.body.style.cursor = cursor;\n\n        // Cache the initial sizes of the pair.\n        calculateSizes.call(self);\n\n        // Determine the position of the mouse compared to the gutter\n        self.dragOffset = getMousePosition(e) - self.end;\n    }\n\n    // adjust sizes to ensure percentage is within min size and gutter.\n    sizes = trimToMin(sizes);\n\n    // 5. Create pair and element objects. Each pair has an index reference to\n    // elements `a` and `b` of the pair (first and second elements).\n    // Loop through the elements while pairing them off. Every pair gets a\n    // `pair` object and a gutter.\n    //\n    // Basic logic:\n    //\n    // - Starting with the second element `i > 0`, create `pair` objects with\n    //   `a = i - 1` and `b = i`\n    // - Set gutter sizes based on the _pair_ being first/last. The first and last\n    //   pair have gutterSize / 2, since they only have one half gutter, and not two.\n    // - Create gutter elements and add event listeners.\n    // - Set the size of the elements, minus the gutter sizes.\n    //\n    // -----------------------------------------------------------------------\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\n    // |             |                     |                  |              |\n    // |           pair 0                pair 1             pair 2           |\n    // |             |                     |                  |              |\n    // -----------------------------------------------------------------------\n    var pairs = [];\n    elements = ids.map(function (id, i) {\n        // Create the element object.\n        var element = {\n            element: elementOrSelector(id),\n            size: sizes[i],\n            minSize: minSizes[i],\n            maxSize: maxSizes[i],\n            i: i,\n        };\n\n        var pair;\n\n        if (i > 0) {\n            // Create the pair object with its metadata.\n            pair = {\n                a: i - 1,\n                b: i,\n                dragging: false,\n                direction: direction,\n                parent: parent,\n            };\n\n            pair[aGutterSize] = getGutterSize(\n                gutterSize,\n                i - 1 === 0,\n                false,\n                gutterAlign\n            );\n            pair[bGutterSize] = getGutterSize(\n                gutterSize,\n                false,\n                i === ids.length - 1,\n                gutterAlign\n            );\n\n            // if the parent has a reverse flex-direction, switch the pair elements.\n            if (\n                parentFlexDirection === 'row-reverse' ||\n                parentFlexDirection === 'column-reverse'\n            ) {\n                var temp = pair.a;\n                pair.a = pair.b;\n                pair.b = temp;\n            }\n        }\n\n        // Determine the size of the current element. IE8 is supported by\n        // staticly assigning sizes without draggable gutters. Assigns a string\n        // to `size`.\n        //\n        // Create gutter elements for each pair.\n        if (i > 0) {\n            var gutterElement = gutter(i, direction, element.element);\n            setGutterSize(gutterElement, gutterSize, i);\n\n            // Save bound event listener for removal later\n            pair[gutterStartDragging] = startDragging.bind(pair);\n\n            // Attach bound event listener\n            gutterElement[addEventListener](\n                'mousedown',\n                pair[gutterStartDragging]\n            );\n            gutterElement[addEventListener](\n                'touchstart',\n                pair[gutterStartDragging]\n            );\n\n            parent.insertBefore(gutterElement, element.element);\n\n            pair.gutter = gutterElement;\n        }\n\n        setElementSize(\n            element.element,\n            element.size,\n            getGutterSize(\n                gutterSize,\n                i === 0,\n                i === ids.length - 1,\n                gutterAlign\n            ),\n            i\n        );\n\n        // After the first iteration, and we have a pair object, append it to the\n        // list of pairs.\n        if (i > 0) {\n            pairs.push(pair);\n        }\n\n        return element\n    });\n\n    function adjustToMin(element) {\n        var isLast = element.i === pairs.length;\n        var pair = isLast ? pairs[element.i - 1] : pairs[element.i];\n\n        calculateSizes.call(pair);\n\n        var size = isLast\n            ? pair.size - element.minSize - pair[bGutterSize]\n            : element.minSize + pair[aGutterSize];\n\n        adjust.call(pair, size);\n    }\n\n    elements.forEach(function (element) {\n        var computedSize = element.element[getBoundingClientRect]()[dimension];\n\n        if (computedSize < element.minSize) {\n            if (expandToMin) {\n                adjustToMin(element);\n            } else {\n                // eslint-disable-next-line no-param-reassign\n                element.minSize = computedSize;\n            }\n        }\n    });\n\n    function setSizes(newSizes) {\n        var trimmed = trimToMin(newSizes);\n        trimmed.forEach(function (newSize, i) {\n            if (i > 0) {\n                var pair = pairs[i - 1];\n\n                var a = elements[pair.a];\n                var b = elements[pair.b];\n\n                a.size = trimmed[i - 1];\n                b.size = newSize;\n\n                setElementSize(a.element, a.size, pair[aGutterSize], a.i);\n                setElementSize(b.element, b.size, pair[bGutterSize], b.i);\n            }\n        });\n    }\n\n    function destroy(preserveStyles, preserveGutter) {\n        pairs.forEach(function (pair) {\n            if (preserveGutter !== true) {\n                pair.parent.removeChild(pair.gutter);\n            } else {\n                pair.gutter[removeEventListener](\n                    'mousedown',\n                    pair[gutterStartDragging]\n                );\n                pair.gutter[removeEventListener](\n                    'touchstart',\n                    pair[gutterStartDragging]\n                );\n            }\n\n            if (preserveStyles !== true) {\n                var style = elementStyle(\n                    dimension,\n                    pair.a.size,\n                    pair[aGutterSize]\n                );\n\n                Object.keys(style).forEach(function (prop) {\n                    elements[pair.a].element.style[prop] = '';\n                    elements[pair.b].element.style[prop] = '';\n                });\n            }\n        });\n    }\n\n    return {\n        setSizes: setSizes,\n        getSizes: getSizes,\n        collapse: function collapse(i) {\n            adjustToMin(elements[i]);\n        },\n        destroy: destroy,\n        parent: parent,\n        pairs: pairs,\n    }\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Split);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3BsaXQuanMvZGlzdC9zcGxpdC5lcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUVBQXFFLDBCQUEwQjs7QUFFL0Y7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGlCQUFpQjtBQUM3RjtBQUNBLDRFQUE0RSxpQkFBaUI7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGlEQUFpRCxzQkFBc0I7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDOztBQUVBLDhCQUE4Qjs7QUFFOUI7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLGVBQWU7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLEtBQUssRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcGxpdC5qcy9kaXN0L3NwbGl0LmVzLmpzPzE5NzAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhlIHByb2dyYW1taW5nIGdvYWxzIG9mIFNwbGl0LmpzIGFyZSB0byBkZWxpdmVyIHJlYWRhYmxlLCB1bmRlcnN0YW5kYWJsZSBhbmRcbi8vIG1haW50YWluYWJsZSBjb2RlLCB3aGlsZSBhdCB0aGUgc2FtZSB0aW1lIG1hbnVhbGx5IG9wdGltaXppbmcgZm9yIHRpbnkgbWluaWZpZWQgZmlsZSBzaXplLFxuLy8gYnJvd3NlciBjb21wYXRpYmlsaXR5IHdpdGhvdXQgYWRkaXRpb25hbCByZXF1aXJlbWVudHNcbi8vIGFuZCB2ZXJ5IGZldyBhc3N1bXB0aW9ucyBhYm91dCB0aGUgdXNlcidzIHBhZ2UgbGF5b3V0LlxudmFyIGdsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogbnVsbDtcbnZhciBzc3IgPSBnbG9iYWwgPT09IG51bGw7XG52YXIgZG9jdW1lbnQgPSAhc3NyID8gZ2xvYmFsLmRvY3VtZW50IDogdW5kZWZpbmVkO1xuXG4vLyBTYXZlIGEgY291cGxlIGxvbmcgZnVuY3Rpb24gbmFtZXMgdGhhdCBhcmUgdXNlZCBmcmVxdWVudGx5LlxuLy8gVGhpcyBvcHRpbWl6YXRpb24gc2F2ZXMgYXJvdW5kIDQwMCBieXRlcy5cbnZhciBhZGRFdmVudExpc3RlbmVyID0gJ2FkZEV2ZW50TGlzdGVuZXInO1xudmFyIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG52YXIgZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID0gJ2dldEJvdW5kaW5nQ2xpZW50UmVjdCc7XG52YXIgZ3V0dGVyU3RhcnREcmFnZ2luZyA9ICdfYSc7XG52YXIgYUd1dHRlclNpemUgPSAnX2InO1xudmFyIGJHdXR0ZXJTaXplID0gJ19jJztcbnZhciBIT1JJWk9OVEFMID0gJ2hvcml6b250YWwnO1xudmFyIE5PT1AgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIGRldGVybWluZXMgd2hpY2ggcHJlZml4ZXMgb2YgQ1NTIGNhbGMgd2UgbmVlZC5cbi8vIFdlIG9ubHkgbmVlZCB0byBkbyB0aGlzIG9uY2Ugb24gc3RhcnR1cCwgd2hlbiB0aGlzIGFub255bW91cyBmdW5jdGlvbiBpcyBjYWxsZWQuXG4vL1xuLy8gVGVzdHMgLXdlYmtpdCwgLW1veiBhbmQgLW8gcHJlZml4ZXMuIE1vZGlmaWVkIGZyb20gU3RhY2tPdmVyZmxvdzpcbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTY2MjUxNDAvanMtZmVhdHVyZS1kZXRlY3Rpb24tdG8tZGV0ZWN0LXRoZS11c2FnZS1vZi13ZWJraXQtY2FsYy1vdmVyLWNhbGMvMTY2MjUxNjcjMTY2MjUxNjdcbnZhciBjYWxjID0gc3NyXG4gICAgPyAnY2FsYydcbiAgICA6ICgoWycnLCAnLXdlYmtpdC0nLCAnLW1vei0nLCAnLW8tJ11cbiAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgIGVsLnN0eWxlLmNzc1RleHQgPSBcIndpZHRoOlwiICsgcHJlZml4ICsgXCJjYWxjKDlweClcIjtcblxuICAgICAgICAgICAgICByZXR1cm4gISFlbC5zdHlsZS5sZW5ndGhcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5zaGlmdCgpKSArIFwiY2FsY1wiKTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIGNoZWNrcyBpZiBpdHMgYXJndW1lbnQgaXMgYSBzdHJpbmctbGlrZSB0eXBlXG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8IHYgaW5zdGFuY2VvZiBTdHJpbmc7IH07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiBhbGxvd3MgZWxlbWVudHMgYW5kIHN0cmluZyBzZWxlY3RvcnMgdG8gYmUgdXNlZFxuLy8gaW50ZXJjaGFuZ2VhYmx5LiBJbiBlaXRoZXIgY2FzZSBhbiBlbGVtZW50IGlzIHJldHVybmVkLiBUaGlzIGFsbG93cyB1cyB0b1xuLy8gZG8gYFNwbGl0KFtlbGVtMSwgZWxlbTJdKWAgYXMgd2VsbCBhcyBgU3BsaXQoWycjaWQxJywgJyNpZDInXSlgLlxudmFyIGVsZW1lbnRPclNlbGVjdG9yID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGlzU3RyaW5nKGVsKSkge1xuICAgICAgICB2YXIgZWxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgICAgIGlmICghZWxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiU2VsZWN0b3IgXCIgKyBlbCArIFwiIGRpZCBub3QgbWF0Y2ggYSBET00gZWxlbWVudFwiKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlXG4gICAgfVxuXG4gICAgcmV0dXJuIGVsXG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gZ2V0cyBhIHByb3BlcnR5IGZyb20gdGhlIHByb3BlcnRpZXMgb2JqZWN0LCB3aXRoIGEgZGVmYXVsdCBmYWxsYmFja1xudmFyIGdldE9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zLCBwcm9wTmFtZSwgZGVmKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9uc1twcm9wTmFtZV07XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIHJldHVybiBkZWZcbn07XG5cbnZhciBnZXRHdXR0ZXJTaXplID0gZnVuY3Rpb24gKGd1dHRlclNpemUsIGlzRmlyc3QsIGlzTGFzdCwgZ3V0dGVyQWxpZ24pIHtcbiAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICBpZiAoZ3V0dGVyQWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9XG4gICAgICAgIGlmIChndXR0ZXJBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBndXR0ZXJTaXplIC8gMlxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0xhc3QpIHtcbiAgICAgICAgaWYgKGd1dHRlckFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9XG4gICAgICAgIGlmIChndXR0ZXJBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBndXR0ZXJTaXplIC8gMlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGd1dHRlclNpemVcbn07XG5cbi8vIERlZmF1bHQgb3B0aW9uc1xudmFyIGRlZmF1bHRHdXR0ZXJGbiA9IGZ1bmN0aW9uIChpLCBndXR0ZXJEaXJlY3Rpb24pIHtcbiAgICB2YXIgZ3V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZ3V0LmNsYXNzTmFtZSA9IFwiZ3V0dGVyIGd1dHRlci1cIiArIGd1dHRlckRpcmVjdGlvbjtcbiAgICByZXR1cm4gZ3V0XG59O1xuXG52YXIgZGVmYXVsdEVsZW1lbnRTdHlsZUZuID0gZnVuY3Rpb24gKGRpbSwgc2l6ZSwgZ3V0U2l6ZSkge1xuICAgIHZhciBzdHlsZSA9IHt9O1xuXG4gICAgaWYgKCFpc1N0cmluZyhzaXplKSkge1xuICAgICAgICBzdHlsZVtkaW1dID0gY2FsYyArIFwiKFwiICsgc2l6ZSArIFwiJSAtIFwiICsgZ3V0U2l6ZSArIFwicHgpXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVbZGltXSA9IHNpemU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlXG59O1xuXG52YXIgZGVmYXVsdEd1dHRlclN0eWxlRm4gPSBmdW5jdGlvbiAoZGltLCBndXRTaXplKSB7XG4gICAgdmFyIG9iajtcblxuICAgIHJldHVybiAoKCBvYmogPSB7fSwgb2JqW2RpbV0gPSAoZ3V0U2l6ZSArIFwicHhcIiksIG9iaiApKTtcbn07XG5cbi8vIFRoZSBtYWluIGZ1bmN0aW9uIHRvIGluaXRpYWxpemUgYSBzcGxpdC4gU3BsaXQuanMgdGhpbmtzIGFib3V0IGVhY2ggcGFpclxuLy8gb2YgZWxlbWVudHMgYXMgYW4gaW5kZXBlbmRhbnQgcGFpci4gRHJhZ2dpbmcgdGhlIGd1dHRlciBiZXR3ZWVuIHR3byBlbGVtZW50c1xuLy8gb25seSBjaGFuZ2VzIHRoZSBkaW1lbnNpb25zIG9mIGVsZW1lbnRzIGluIHRoYXQgcGFpci4gVGhpcyBpcyBrZXkgdG8gdW5kZXJzdGFuZGluZ1xuLy8gaG93IHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG9wZXJhdGUsIHNpbmNlIGVhY2ggZnVuY3Rpb24gaXMgYm91bmQgdG8gYSBwYWlyLlxuLy9cbi8vIEEgcGFpciBvYmplY3QgaXMgc2hhcGVkIGxpa2UgdGhpczpcbi8vXG4vLyB7XG4vLyAgICAgYTogRE9NIGVsZW1lbnQsXG4vLyAgICAgYjogRE9NIGVsZW1lbnQsXG4vLyAgICAgYU1pbjogTnVtYmVyLFxuLy8gICAgIGJNaW46IE51bWJlcixcbi8vICAgICBkcmFnZ2luZzogQm9vbGVhbixcbi8vICAgICBwYXJlbnQ6IERPTSBlbGVtZW50LFxuLy8gICAgIGRpcmVjdGlvbjogJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJ1xuLy8gfVxuLy9cbi8vIFRoZSBiYXNpYyBzZXF1ZW5jZTpcbi8vXG4vLyAxLiBTZXQgZGVmYXVsdHMgdG8gc29tZXRoaW5nIHNhbmUuIGBvcHRpb25zYCBkb2Vzbid0IGhhdmUgdG8gYmUgcGFzc2VkIGF0IGFsbC5cbi8vIDIuIEluaXRpYWxpemUgYSBidW5jaCBvZiBzdHJpbmdzIGJhc2VkIG9uIHRoZSBkaXJlY3Rpb24gd2UncmUgc3BsaXR0aW5nLlxuLy8gICAgQSBsb3Qgb2YgdGhlIGJlaGF2aW9yIGluIHRoZSByZXN0IG9mIHRoZSBsaWJyYXJ5IGlzIHBhcmFtYXRpemVkIGRvd24gdG9cbi8vICAgIHJlbHkgb24gQ1NTIHN0cmluZ3MgYW5kIGNsYXNzZXMuXG4vLyAzLiBEZWZpbmUgdGhlIGRyYWdnaW5nIGhlbHBlciBmdW5jdGlvbnMsIGFuZCBhIGZldyBoZWxwZXJzIHRvIGdvIHdpdGggdGhlbS5cbi8vIDQuIExvb3AgdGhyb3VnaCB0aGUgZWxlbWVudHMgd2hpbGUgcGFpcmluZyB0aGVtIG9mZi4gRXZlcnkgcGFpciBnZXRzIGFuXG4vLyAgICBgcGFpcmAgb2JqZWN0IGFuZCBhIGd1dHRlci5cbi8vIDUuIEFjdHVhbGx5IHNpemUgdGhlIHBhaXIgZWxlbWVudHMsIGluc2VydCBndXR0ZXJzIGFuZCBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzLlxudmFyIFNwbGl0ID0gZnVuY3Rpb24gKGlkc09wdGlvbiwgb3B0aW9ucykge1xuICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKHNzcikgeyByZXR1cm4ge30gfVxuXG4gICAgdmFyIGlkcyA9IGlkc09wdGlvbjtcbiAgICB2YXIgZGltZW5zaW9uO1xuICAgIHZhciBjbGllbnRBeGlzO1xuICAgIHZhciBwb3NpdGlvbjtcbiAgICB2YXIgcG9zaXRpb25FbmQ7XG4gICAgdmFyIGNsaWVudFNpemU7XG4gICAgdmFyIGVsZW1lbnRzO1xuXG4gICAgLy8gQWxsb3cgSFRNTENvbGxlY3Rpb24gdG8gYmUgdXNlZCBhcyBhbiBhcmd1bWVudCB3aGVuIHN1cHBvcnRlZFxuICAgIGlmIChBcnJheS5mcm9tKSB7XG4gICAgICAgIGlkcyA9IEFycmF5LmZyb20oaWRzKTtcbiAgICB9XG5cbiAgICAvLyBBbGwgRE9NIGVsZW1lbnRzIGluIHRoZSBzcGxpdCBzaG91bGQgaGF2ZSBhIGNvbW1vbiBwYXJlbnQuIFdlIGNhbiBncmFiXG4gICAgLy8gdGhlIGZpcnN0IGVsZW1lbnRzIHBhcmVudCBhbmQgaG9wZSB1c2VycyByZWFkIHRoZSBkb2NzIGJlY2F1c2UgdGhlXG4gICAgLy8gYmVoYXZpb3Igd2lsbCBiZSB3aGFja3kgb3RoZXJ3aXNlLlxuICAgIHZhciBmaXJzdEVsZW1lbnQgPSBlbGVtZW50T3JTZWxlY3RvcihpZHNbMF0pO1xuICAgIHZhciBwYXJlbnQgPSBmaXJzdEVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICB2YXIgcGFyZW50U3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlID8gZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpIDogbnVsbDtcbiAgICB2YXIgcGFyZW50RmxleERpcmVjdGlvbiA9IHBhcmVudFN0eWxlID8gcGFyZW50U3R5bGUuZmxleERpcmVjdGlvbiA6IG51bGw7XG5cbiAgICAvLyBTZXQgZGVmYXVsdCBvcHRpb25zLnNpemVzIHRvIGVxdWFsIHBlcmNlbnRhZ2VzIG9mIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICB2YXIgc2l6ZXMgPSBnZXRPcHRpb24ob3B0aW9ucywgJ3NpemVzJykgfHwgaWRzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiAxMDAgLyBpZHMubGVuZ3RoOyB9KTtcblxuICAgIC8vIFN0YW5kYXJkaXplIG1pblNpemUgYW5kIG1heFNpemUgdG8gYW4gYXJyYXkgaWYgaXQgaXNuJ3QgYWxyZWFkeS5cbiAgICAvLyBUaGlzIGFsbG93cyBtaW5TaXplIGFuZCBtYXhTaXplIHRvIGJlIHBhc3NlZCBhcyBhIG51bWJlci5cbiAgICB2YXIgbWluU2l6ZSA9IGdldE9wdGlvbihvcHRpb25zLCAnbWluU2l6ZScsIDEwMCk7XG4gICAgdmFyIG1pblNpemVzID0gQXJyYXkuaXNBcnJheShtaW5TaXplKSA/IG1pblNpemUgOiBpZHMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1pblNpemU7IH0pO1xuICAgIHZhciBtYXhTaXplID0gZ2V0T3B0aW9uKG9wdGlvbnMsICdtYXhTaXplJywgSW5maW5pdHkpO1xuICAgIHZhciBtYXhTaXplcyA9IEFycmF5LmlzQXJyYXkobWF4U2l6ZSkgPyBtYXhTaXplIDogaWRzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBtYXhTaXplOyB9KTtcblxuICAgIC8vIEdldCBvdGhlciBvcHRpb25zXG4gICAgdmFyIGV4cGFuZFRvTWluID0gZ2V0T3B0aW9uKG9wdGlvbnMsICdleHBhbmRUb01pbicsIGZhbHNlKTtcbiAgICB2YXIgZ3V0dGVyU2l6ZSA9IGdldE9wdGlvbihvcHRpb25zLCAnZ3V0dGVyU2l6ZScsIDEwKTtcbiAgICB2YXIgZ3V0dGVyQWxpZ24gPSBnZXRPcHRpb24ob3B0aW9ucywgJ2d1dHRlckFsaWduJywgJ2NlbnRlcicpO1xuICAgIHZhciBzbmFwT2Zmc2V0ID0gZ2V0T3B0aW9uKG9wdGlvbnMsICdzbmFwT2Zmc2V0JywgMzApO1xuICAgIHZhciBkcmFnSW50ZXJ2YWwgPSBnZXRPcHRpb24ob3B0aW9ucywgJ2RyYWdJbnRlcnZhbCcsIDEpO1xuICAgIHZhciBkaXJlY3Rpb24gPSBnZXRPcHRpb24ob3B0aW9ucywgJ2RpcmVjdGlvbicsIEhPUklaT05UQUwpO1xuICAgIHZhciBjdXJzb3IgPSBnZXRPcHRpb24oXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgICdjdXJzb3InLFxuICAgICAgICBkaXJlY3Rpb24gPT09IEhPUklaT05UQUwgPyAnY29sLXJlc2l6ZScgOiAncm93LXJlc2l6ZSdcbiAgICApO1xuICAgIHZhciBndXR0ZXIgPSBnZXRPcHRpb24ob3B0aW9ucywgJ2d1dHRlcicsIGRlZmF1bHRHdXR0ZXJGbik7XG4gICAgdmFyIGVsZW1lbnRTdHlsZSA9IGdldE9wdGlvbihcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgJ2VsZW1lbnRTdHlsZScsXG4gICAgICAgIGRlZmF1bHRFbGVtZW50U3R5bGVGblxuICAgICk7XG4gICAgdmFyIGd1dHRlclN0eWxlID0gZ2V0T3B0aW9uKG9wdGlvbnMsICdndXR0ZXJTdHlsZScsIGRlZmF1bHRHdXR0ZXJTdHlsZUZuKTtcblxuICAgIC8vIDIuIEluaXRpYWxpemUgYSBidW5jaCBvZiBzdHJpbmdzIGJhc2VkIG9uIHRoZSBkaXJlY3Rpb24gd2UncmUgc3BsaXR0aW5nLlxuICAgIC8vIEEgbG90IG9mIHRoZSBiZWhhdmlvciBpbiB0aGUgcmVzdCBvZiB0aGUgbGlicmFyeSBpcyBwYXJhbWF0aXplZCBkb3duIHRvXG4gICAgLy8gcmVseSBvbiBDU1Mgc3RyaW5ncyBhbmQgY2xhc3Nlcy5cbiAgICBpZiAoZGlyZWN0aW9uID09PSBIT1JJWk9OVEFMKSB7XG4gICAgICAgIGRpbWVuc2lvbiA9ICd3aWR0aCc7XG4gICAgICAgIGNsaWVudEF4aXMgPSAnY2xpZW50WCc7XG4gICAgICAgIHBvc2l0aW9uID0gJ2xlZnQnO1xuICAgICAgICBwb3NpdGlvbkVuZCA9ICdyaWdodCc7XG4gICAgICAgIGNsaWVudFNpemUgPSAnY2xpZW50V2lkdGgnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgIGRpbWVuc2lvbiA9ICdoZWlnaHQnO1xuICAgICAgICBjbGllbnRBeGlzID0gJ2NsaWVudFknO1xuICAgICAgICBwb3NpdGlvbiA9ICd0b3AnO1xuICAgICAgICBwb3NpdGlvbkVuZCA9ICdib3R0b20nO1xuICAgICAgICBjbGllbnRTaXplID0gJ2NsaWVudEhlaWdodCc7XG4gICAgfVxuXG4gICAgLy8gMy4gRGVmaW5lIHRoZSBkcmFnZ2luZyBoZWxwZXIgZnVuY3Rpb25zLCBhbmQgYSBmZXcgaGVscGVycyB0byBnbyB3aXRoIHRoZW0uXG4gICAgLy8gRWFjaCBoZWxwZXIgaXMgYm91bmQgdG8gYSBwYWlyIG9iamVjdCB0aGF0IGNvbnRhaW5zIGl0cyBtZXRhZGF0YS4gVGhpc1xuICAgIC8vIGFsc28gbWFrZXMgaXQgZWFzeSB0byBzdG9yZSByZWZlcmVuY2VzIHRvIGxpc3RlbmVycyB0aGF0IHRoYXQgd2lsbCBiZVxuICAgIC8vIGFkZGVkIGFuZCByZW1vdmVkLlxuICAgIC8vXG4gICAgLy8gRXZlbiB0aG91Z2ggdGhlcmUgYXJlIG5vIG90aGVyIGZ1bmN0aW9ucyBjb250YWluZWQgaW4gdGhlbSwgYWxpYXNpbmdcbiAgICAvLyB0aGlzIHRvIHNlbGYgc2F2ZXMgNTAgYnl0ZXMgb3Igc28gc2luY2UgaXQncyB1c2VkIHNvIGZyZXF1ZW50bHkuXG4gICAgLy9cbiAgICAvLyBUaGUgcGFpciBvYmplY3Qgc2F2ZXMgbWV0YWRhdGEgbGlrZSBkcmFnZ2luZyBzdGF0ZSwgcG9zaXRpb24gYW5kXG4gICAgLy8gZXZlbnQgbGlzdGVuZXIgcmVmZXJlbmNlcy5cblxuICAgIGZ1bmN0aW9uIHNldEVsZW1lbnRTaXplKGVsLCBzaXplLCBndXRTaXplLCBpKSB7XG4gICAgICAgIC8vIFNwbGl0LmpzIGFsbG93cyBzZXR0aW5nIHNpemVzIHZpYSBudW1iZXJzIChpZGVhbGx5KSwgb3IgaWYgeW91IG11c3QsXG4gICAgICAgIC8vIGJ5IHN0cmluZywgbGlrZSAnMzAwcHgnLiBUaGlzIGlzIGxlc3MgdGhhbiBpZGVhbCwgYmVjYXVzZSBpdCBicmVha3NcbiAgICAgICAgLy8gdGhlIGZsdWlkIGxheW91dCB0aGF0IGBjYWxjKCUgLSBweClgIHByb3ZpZGVzLiBZb3UncmUgb24geW91ciBvd24gaWYgeW91IGRvIHRoYXQsXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB5b3UgY2FsY3VsYXRlIHRoZSBndXR0ZXIgc2l6ZSBieSBoYW5kLlxuICAgICAgICB2YXIgc3R5bGUgPSBlbGVtZW50U3R5bGUoZGltZW5zaW9uLCBzaXplLCBndXRTaXplLCBpKTtcblxuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBlbC5zdHlsZVtwcm9wXSA9IHN0eWxlW3Byb3BdO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRHdXR0ZXJTaXplKGd1dHRlckVsZW1lbnQsIGd1dFNpemUsIGkpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gZ3V0dGVyU3R5bGUoZGltZW5zaW9uLCBndXRTaXplLCBpKTtcblxuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBndXR0ZXJFbGVtZW50LnN0eWxlW3Byb3BdID0gc3R5bGVbcHJvcF07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNpemVzKCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudHMubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50LnNpemU7IH0pXG4gICAgfVxuXG4gICAgLy8gU3VwcG9ydHMgdG91Y2ggZXZlbnRzLCBidXQgbm90IG11bHRpdG91Y2gsIHNvIG9ubHkgdGhlIGZpcnN0XG4gICAgLy8gZmluZ2VyIGB0b3VjaGVzWzBdYCBpcyBjb3VudGVkLlxuICAgIGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZSkge1xuICAgICAgICBpZiAoJ3RvdWNoZXMnIGluIGUpIHsgcmV0dXJuIGUudG91Y2hlc1swXVtjbGllbnRBeGlzXSB9XG4gICAgICAgIHJldHVybiBlW2NsaWVudEF4aXNdXG4gICAgfVxuXG4gICAgLy8gQWN0dWFsbHkgYWRqdXN0IHRoZSBzaXplIG9mIGVsZW1lbnRzIGBhYCBhbmQgYGJgIHRvIGBvZmZzZXRgIHdoaWxlIGRyYWdnaW5nLlxuICAgIC8vIGNhbGMgaXMgdXNlZCB0byBhbGxvdyBjYWxjKHBlcmNlbnRhZ2UgKyBndXR0ZXJweCkgb24gdGhlIHdob2xlIHNwbGl0IGluc3RhbmNlLFxuICAgIC8vIHdoaWNoIGFsbG93cyB0aGUgdmlld3BvcnQgdG8gYmUgcmVzaXplZCB3aXRob3V0IGFkZGl0aW9uYWwgbG9naWMuXG4gICAgLy8gRWxlbWVudCBhJ3Mgc2l6ZSBpcyB0aGUgc2FtZSBhcyBvZmZzZXQuIGIncyBzaXplIGlzIHRvdGFsIHNpemUgLSBhIHNpemUuXG4gICAgLy8gQm90aCBzaXplcyBhcmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBpbml0aWFsIHBhcmVudCBwZXJjZW50YWdlLFxuICAgIC8vIHRoZW4gdGhlIGd1dHRlciBzaXplIGlzIHN1YnRyYWN0ZWQuXG4gICAgZnVuY3Rpb24gYWRqdXN0KG9mZnNldCkge1xuICAgICAgICB2YXIgYSA9IGVsZW1lbnRzW3RoaXMuYV07XG4gICAgICAgIHZhciBiID0gZWxlbWVudHNbdGhpcy5iXTtcbiAgICAgICAgdmFyIHBlcmNlbnRhZ2UgPSBhLnNpemUgKyBiLnNpemU7XG5cbiAgICAgICAgYS5zaXplID0gKG9mZnNldCAvIHRoaXMuc2l6ZSkgKiBwZXJjZW50YWdlO1xuICAgICAgICBiLnNpemUgPSBwZXJjZW50YWdlIC0gKG9mZnNldCAvIHRoaXMuc2l6ZSkgKiBwZXJjZW50YWdlO1xuXG4gICAgICAgIHNldEVsZW1lbnRTaXplKGEuZWxlbWVudCwgYS5zaXplLCB0aGlzW2FHdXR0ZXJTaXplXSwgYS5pKTtcbiAgICAgICAgc2V0RWxlbWVudFNpemUoYi5lbGVtZW50LCBiLnNpemUsIHRoaXNbYkd1dHRlclNpemVdLCBiLmkpO1xuICAgIH1cblxuICAgIC8vIGRyYWcsIHdoZXJlIGFsbCB0aGUgbWFnaWMgaGFwcGVucy4gVGhlIGxvZ2ljIGlzIHJlYWxseSBxdWl0ZSBzaW1wbGU6XG4gICAgLy9cbiAgICAvLyAxLiBJZ25vcmUgaWYgdGhlIHBhaXIgaXMgbm90IGRyYWdnaW5nLlxuICAgIC8vIDIuIEdldCB0aGUgb2Zmc2V0IG9mIHRoZSBldmVudC5cbiAgICAvLyAzLiBTbmFwIG9mZnNldCB0byBtaW4gaWYgd2l0aGluIHNuYXBwYWJsZSByYW5nZSAod2l0aGluIG1pbiArIHNuYXBPZmZzZXQpLlxuICAgIC8vIDQuIEFjdHVhbGx5IGFkanVzdCBlYWNoIGVsZW1lbnQgaW4gdGhlIHBhaXIgdG8gb2Zmc2V0LlxuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gfCAgICB8IDwtIGEubWluU2l6ZSAgICAgICAgICAgICAgIHx8ICAgICAgICAgICAgICBiLm1pblNpemUgLT4gfCAgICB8XG4gICAgLy8gfCAgICB8ICB8IDwtIHRoaXMuc25hcE9mZnNldCAgICAgIHx8ICAgICB0aGlzLnNuYXBPZmZzZXQgLT4gfCAgfCAgICB8XG4gICAgLy8gfCAgICB8ICB8ICAgICAgICAgICAgICAgICAgICAgICAgIHx8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgfCAgICB8XG4gICAgLy8gfCAgICB8ICB8ICAgICAgICAgICAgICAgICAgICAgICAgIHx8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgfCAgICB8XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gfCA8LSB0aGlzLnN0YXJ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSAtPiB8XG4gICAgZnVuY3Rpb24gZHJhZyhlKSB7XG4gICAgICAgIHZhciBvZmZzZXQ7XG4gICAgICAgIHZhciBhID0gZWxlbWVudHNbdGhpcy5hXTtcbiAgICAgICAgdmFyIGIgPSBlbGVtZW50c1t0aGlzLmJdO1xuXG4gICAgICAgIGlmICghdGhpcy5kcmFnZ2luZykgeyByZXR1cm4gfVxuXG4gICAgICAgIC8vIEdldCB0aGUgb2Zmc2V0IG9mIHRoZSBldmVudCBmcm9tIHRoZSBmaXJzdCBzaWRlIG9mIHRoZVxuICAgICAgICAvLyBwYWlyIGB0aGlzLnN0YXJ0YC4gVGhlbiBvZmZzZXQgYnkgdGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlXG4gICAgICAgIC8vIG1vdXNlIGNvbXBhcmVkIHRvIHRoZSBndXR0ZXIgc2l6ZS5cbiAgICAgICAgb2Zmc2V0ID1cbiAgICAgICAgICAgIGdldE1vdXNlUG9zaXRpb24oZSkgLVxuICAgICAgICAgICAgdGhpcy5zdGFydCArXG4gICAgICAgICAgICAodGhpc1thR3V0dGVyU2l6ZV0gLSB0aGlzLmRyYWdPZmZzZXQpO1xuXG4gICAgICAgIGlmIChkcmFnSW50ZXJ2YWwgPiAxKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBNYXRoLnJvdW5kKG9mZnNldCAvIGRyYWdJbnRlcnZhbCkgKiBkcmFnSW50ZXJ2YWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3aXRoaW4gc25hcE9mZnNldCBvZiBtaW4gb3IgbWF4LCBzZXQgb2Zmc2V0IHRvIG1pbiBvciBtYXguXG4gICAgICAgIC8vIHNuYXBPZmZzZXQgYnVmZmVycyBhLm1pblNpemUgYW5kIGIubWluU2l6ZSwgc28gbG9naWMgaXMgb3Bwb3NpdGUgZm9yIGJvdGguXG4gICAgICAgIC8vIEluY2x1ZGUgdGhlIGFwcHJvcHJpYXRlIGd1dHRlciBzaXplcyB0byBwcmV2ZW50IG92ZXJmbG93cy5cbiAgICAgICAgaWYgKG9mZnNldCA8PSBhLm1pblNpemUgKyBzbmFwT2Zmc2V0ICsgdGhpc1thR3V0dGVyU2l6ZV0pIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGEubWluU2l6ZSArIHRoaXNbYUd1dHRlclNpemVdO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgb2Zmc2V0ID49XG4gICAgICAgICAgICB0aGlzLnNpemUgLSAoYi5taW5TaXplICsgc25hcE9mZnNldCArIHRoaXNbYkd1dHRlclNpemVdKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuc2l6ZSAtIChiLm1pblNpemUgKyB0aGlzW2JHdXR0ZXJTaXplXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2Zmc2V0ID49IGEubWF4U2l6ZSAtIHNuYXBPZmZzZXQgKyB0aGlzW2FHdXR0ZXJTaXplXSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gYS5tYXhTaXplICsgdGhpc1thR3V0dGVyU2l6ZV07XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBvZmZzZXQgPD1cbiAgICAgICAgICAgIHRoaXMuc2l6ZSAtIChiLm1heFNpemUgLSBzbmFwT2Zmc2V0ICsgdGhpc1tiR3V0dGVyU2l6ZV0pXG4gICAgICAgICkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5zaXplIC0gKGIubWF4U2l6ZSArIHRoaXNbYkd1dHRlclNpemVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFjdHVhbGx5IGFkanVzdCB0aGUgc2l6ZS5cbiAgICAgICAgYWRqdXN0LmNhbGwodGhpcywgb2Zmc2V0KTtcblxuICAgICAgICAvLyBDYWxsIHRoZSBkcmFnIGNhbGxiYWNrIGNvbnRpbm91c2x5LiBEb24ndCBkbyBhbnl0aGluZyB0b28gaW50ZW5zaXZlXG4gICAgICAgIC8vIGluIHRoaXMgY2FsbGJhY2suXG4gICAgICAgIGdldE9wdGlvbihvcHRpb25zLCAnb25EcmFnJywgTk9PUCkoZ2V0U2l6ZXMoKSk7XG4gICAgfVxuXG4gICAgLy8gQ2FjaGUgc29tZSBpbXBvcnRhbnQgc2l6ZXMgd2hlbiBkcmFnIHN0YXJ0cywgc28gd2UgZG9uJ3QgaGF2ZSB0byBkbyB0aGF0XG4gICAgLy8gY29udGlub3VzbHk6XG4gICAgLy9cbiAgICAvLyBgc2l6ZWA6IFRoZSB0b3RhbCBzaXplIG9mIHRoZSBwYWlyLiBGaXJzdCArIHNlY29uZCArIGZpcnN0IGd1dHRlciArIHNlY29uZCBndXR0ZXIuXG4gICAgLy8gYHN0YXJ0YDogVGhlIGxlYWRpbmcgc2lkZSBvZiB0aGUgZmlyc3QgZWxlbWVudC5cbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHwgICAgICBhR3V0dGVyU2l6ZSAtPiB8fHwgICAgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vIHwgICAgICAgICAgICAgICAgICAgICB8fHwgICAgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vIHwgICAgICAgICAgICAgICAgICAgICB8fHwgICAgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vIHwgICAgICAgICAgICAgICAgICAgICB8fHwgPC0gYkd1dHRlclNpemUgICAgICAgfFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHwgPC0gc3RhcnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgLT4gfFxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZVNpemVzKCkge1xuICAgICAgICAvLyBGaWd1cmUgb3V0IHRoZSBwYXJlbnQgc2l6ZSBtaW51cyBwYWRkaW5nLlxuICAgICAgICB2YXIgYSA9IGVsZW1lbnRzW3RoaXMuYV0uZWxlbWVudDtcbiAgICAgICAgdmFyIGIgPSBlbGVtZW50c1t0aGlzLmJdLmVsZW1lbnQ7XG5cbiAgICAgICAgdmFyIGFCb3VuZHMgPSBhW2dldEJvdW5kaW5nQ2xpZW50UmVjdF0oKTtcbiAgICAgICAgdmFyIGJCb3VuZHMgPSBiW2dldEJvdW5kaW5nQ2xpZW50UmVjdF0oKTtcblxuICAgICAgICB0aGlzLnNpemUgPVxuICAgICAgICAgICAgYUJvdW5kc1tkaW1lbnNpb25dICtcbiAgICAgICAgICAgIGJCb3VuZHNbZGltZW5zaW9uXSArXG4gICAgICAgICAgICB0aGlzW2FHdXR0ZXJTaXplXSArXG4gICAgICAgICAgICB0aGlzW2JHdXR0ZXJTaXplXTtcbiAgICAgICAgdGhpcy5zdGFydCA9IGFCb3VuZHNbcG9zaXRpb25dO1xuICAgICAgICB0aGlzLmVuZCA9IGFCb3VuZHNbcG9zaXRpb25FbmRdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlubmVyU2l6ZShlbGVtZW50KSB7XG4gICAgICAgIC8vIFJldHVybiBub3RoaW5nIGlmIGdldENvbXB1dGVkU3R5bGUgaXMgbm90IHN1cHBvcnRlZCAoPCBJRTkpXG4gICAgICAgIC8vIE9yIGlmIHBhcmVudCBlbGVtZW50IGhhcyBubyBsYXlvdXQgeWV0XG4gICAgICAgIGlmICghZ2V0Q29tcHV0ZWRTdHlsZSkgeyByZXR1cm4gbnVsbCB9XG5cbiAgICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgICAgIGlmICghY29tcHV0ZWRTdHlsZSkgeyByZXR1cm4gbnVsbCB9XG5cbiAgICAgICAgdmFyIHNpemUgPSBlbGVtZW50W2NsaWVudFNpemVdO1xuXG4gICAgICAgIGlmIChzaXplID09PSAwKSB7IHJldHVybiBudWxsIH1cblxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBIT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICBzaXplIC09XG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdMZWZ0KSArXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdSaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaXplIC09XG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdUb3ApICtcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ0JvdHRvbSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2l6ZVxuICAgIH1cblxuICAgIC8vIFdoZW4gc3BlY2lmeWluZyBwZXJjZW50YWdlIHNpemVzIHRoYXQgYXJlIGxlc3MgdGhhbiB0aGUgY29tcHV0ZWRcbiAgICAvLyBzaXplIG9mIHRoZSBlbGVtZW50IG1pbnVzIHRoZSBndXR0ZXIsIHRoZSBsZXNzZXIgcGVyY2VudGFnZXMgbXVzdCBiZSBpbmNyZWFzZWRcbiAgICAvLyAoYW5kIGRlY3JlYXNlZCBmcm9tIHRoZSBvdGhlciBlbGVtZW50cykgdG8gbWFrZSBzcGFjZSBmb3IgdGhlIHBpeGVsc1xuICAgIC8vIHN1YnRyYWN0ZWQgYnkgdGhlIGd1dHRlcnMuXG4gICAgZnVuY3Rpb24gdHJpbVRvTWluKHNpemVzVG9UcmltKSB7XG4gICAgICAgIC8vIFRyeSB0byBnZXQgaW5uZXIgc2l6ZSBvZiBwYXJlbnQgZWxlbWVudC5cbiAgICAgICAgLy8gSWYgaXQncyBubyBzdXBwb3J0ZWQsIHJldHVybiBvcmlnaW5hbCBzaXplcy5cbiAgICAgICAgdmFyIHBhcmVudFNpemUgPSBpbm5lclNpemUocGFyZW50KTtcbiAgICAgICAgaWYgKHBhcmVudFNpemUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBzaXplc1RvVHJpbVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pblNpemVzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSArIGI7IH0sIDApID4gcGFyZW50U2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpemVzVG9UcmltXG4gICAgICAgIH1cblxuICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBleGNlc3MgcGl4ZWxzLCB0aGUgYW1vdW50IG9mIHBpeGVscyBvdmVyIHRoZSBkZXNpcmVkIHBlcmNlbnRhZ2VcbiAgICAgICAgLy8gQWxzbyBrZWVwIHRyYWNrIG9mIHRoZSBlbGVtZW50cyB3aXRoIHBpeGVscyB0byBzcGFyZSwgdG8gZGVjcmVhc2UgYWZ0ZXIgaWYgbmVlZGVkXG4gICAgICAgIHZhciBleGNlc3NQaXhlbHMgPSAwO1xuICAgICAgICB2YXIgdG9TcGFyZSA9IFtdO1xuXG4gICAgICAgIHZhciBwaXhlbFNpemVzID0gc2l6ZXNUb1RyaW0ubWFwKGZ1bmN0aW9uIChzaXplLCBpKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHJlcXVlc3RlZCBwZXJjZW50YWdlcyB0byBwaXhlbCBzaXplc1xuICAgICAgICAgICAgdmFyIHBpeGVsU2l6ZSA9IChwYXJlbnRTaXplICogc2l6ZSkgLyAxMDA7XG4gICAgICAgICAgICB2YXIgZWxlbWVudEd1dHRlclNpemUgPSBnZXRHdXR0ZXJTaXplKFxuICAgICAgICAgICAgICAgIGd1dHRlclNpemUsXG4gICAgICAgICAgICAgICAgaSA9PT0gMCxcbiAgICAgICAgICAgICAgICBpID09PSBzaXplc1RvVHJpbS5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgIGd1dHRlckFsaWduXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRNaW5TaXplID0gbWluU2l6ZXNbaV0gKyBlbGVtZW50R3V0dGVyU2l6ZTtcblxuICAgICAgICAgICAgLy8gSWYgZWxlbWVudCBpcyB0b28gc21hbCwgaW5jcmVhc2UgZXhjZXNzIHBpeGVscyBieSB0aGUgZGlmZmVyZW5jZVxuICAgICAgICAgICAgLy8gYW5kIG1hcmsgdGhhdCBpdCBoYXMgbm8gcGl4ZWxzIHRvIHNwYXJlXG4gICAgICAgICAgICBpZiAocGl4ZWxTaXplIDwgZWxlbWVudE1pblNpemUpIHtcbiAgICAgICAgICAgICAgICBleGNlc3NQaXhlbHMgKz0gZWxlbWVudE1pblNpemUgLSBwaXhlbFNpemU7XG4gICAgICAgICAgICAgICAgdG9TcGFyZS5wdXNoKDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50TWluU2l6ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIG1hcmsgdGhlIHBpeGVscyBpdCBoYXMgdG8gc3BhcmUgYW5kIHJldHVybiBpdCdzIG9yaWdpbmFsIHNpemVcbiAgICAgICAgICAgIHRvU3BhcmUucHVzaChwaXhlbFNpemUgLSBlbGVtZW50TWluU2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4gcGl4ZWxTaXplXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIElmIG5vdGhpbmcgd2FzIGFkanVzdGVkLCByZXR1cm4gdGhlIG9yaWdpbmFsIHNpemVzXG4gICAgICAgIGlmIChleGNlc3NQaXhlbHMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzaXplc1RvVHJpbVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBpeGVsU2l6ZXMubWFwKGZ1bmN0aW9uIChwaXhlbFNpemUsIGkpIHtcbiAgICAgICAgICAgIHZhciBuZXdQaXhlbFNpemUgPSBwaXhlbFNpemU7XG5cbiAgICAgICAgICAgIC8vIFdoaWxlIHRoZXJlJ3Mgc3RpbGwgcGl4ZWxzIHRvIHRha2UsIGFuZCB0aGVyZSdzIGVub3VnaCBwaXhlbHMgdG8gc3BhcmUsXG4gICAgICAgICAgICAvLyB0YWtlIGFzIG1hbnkgYXMgcG9zc2libGUgdXAgdG8gdGhlIHRvdGFsIGV4Y2VzcyBwaXhlbHNcbiAgICAgICAgICAgIGlmIChleGNlc3NQaXhlbHMgPiAwICYmIHRvU3BhcmVbaV0gLSBleGNlc3NQaXhlbHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRha2VuUGl4ZWxzID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICAgIGV4Y2Vzc1BpeGVscyxcbiAgICAgICAgICAgICAgICAgICAgdG9TcGFyZVtpXSAtIGV4Y2Vzc1BpeGVsc1xuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgYW1vdW50IHRha2VuIGZvciB0aGUgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICBleGNlc3NQaXhlbHMgLT0gdGFrZW5QaXhlbHM7XG4gICAgICAgICAgICAgICAgbmV3UGl4ZWxTaXplID0gcGl4ZWxTaXplIC0gdGFrZW5QaXhlbHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgcGl4ZWwgc2l6ZSBhZGp1c3RlZCBhcyBhIHBlcmNlbnRhZ2VcbiAgICAgICAgICAgIHJldHVybiAobmV3UGl4ZWxTaXplIC8gcGFyZW50U2l6ZSkgKiAxMDBcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBzdG9wRHJhZ2dpbmcgaXMgdmVyeSBzaW1pbGFyIHRvIHN0YXJ0RHJhZ2dpbmcgaW4gcmV2ZXJzZS5cbiAgICBmdW5jdGlvbiBzdG9wRHJhZ2dpbmcoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGEgPSBlbGVtZW50c1tzZWxmLmFdLmVsZW1lbnQ7XG4gICAgICAgIHZhciBiID0gZWxlbWVudHNbc2VsZi5iXS5lbGVtZW50O1xuXG4gICAgICAgIGlmIChzZWxmLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICBnZXRPcHRpb24ob3B0aW9ucywgJ29uRHJhZ0VuZCcsIE5PT1ApKGdldFNpemVzKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5kcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgc3RvcmVkIGV2ZW50IGxpc3RlbmVycy4gVGhpcyBpcyB3aHkgd2Ugc3RvcmUgdGhlbS5cbiAgICAgICAgZ2xvYmFsW3JlbW92ZUV2ZW50TGlzdGVuZXJdKCdtb3VzZXVwJywgc2VsZi5zdG9wKTtcbiAgICAgICAgZ2xvYmFsW3JlbW92ZUV2ZW50TGlzdGVuZXJdKCd0b3VjaGVuZCcsIHNlbGYuc3RvcCk7XG4gICAgICAgIGdsb2JhbFtyZW1vdmVFdmVudExpc3RlbmVyXSgndG91Y2hjYW5jZWwnLCBzZWxmLnN0b3ApO1xuICAgICAgICBnbG9iYWxbcmVtb3ZlRXZlbnRMaXN0ZW5lcl0oJ21vdXNlbW92ZScsIHNlbGYubW92ZSk7XG4gICAgICAgIGdsb2JhbFtyZW1vdmVFdmVudExpc3RlbmVyXSgndG91Y2htb3ZlJywgc2VsZi5tb3ZlKTtcblxuICAgICAgICAvLyBDbGVhciBib3VuZCBmdW5jdGlvbiByZWZlcmVuY2VzXG4gICAgICAgIHNlbGYuc3RvcCA9IG51bGw7XG4gICAgICAgIHNlbGYubW92ZSA9IG51bGw7XG5cbiAgICAgICAgYVtyZW1vdmVFdmVudExpc3RlbmVyXSgnc2VsZWN0c3RhcnQnLCBOT09QKTtcbiAgICAgICAgYVtyZW1vdmVFdmVudExpc3RlbmVyXSgnZHJhZ3N0YXJ0JywgTk9PUCk7XG4gICAgICAgIGJbcmVtb3ZlRXZlbnRMaXN0ZW5lcl0oJ3NlbGVjdHN0YXJ0JywgTk9PUCk7XG4gICAgICAgIGJbcmVtb3ZlRXZlbnRMaXN0ZW5lcl0oJ2RyYWdzdGFydCcsIE5PT1ApO1xuXG4gICAgICAgIGEuc3R5bGUudXNlclNlbGVjdCA9ICcnO1xuICAgICAgICBhLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnJztcbiAgICAgICAgYS5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gJyc7XG4gICAgICAgIGEuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuXG4gICAgICAgIGIuc3R5bGUudXNlclNlbGVjdCA9ICcnO1xuICAgICAgICBiLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnJztcbiAgICAgICAgYi5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gJyc7XG4gICAgICAgIGIuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuXG4gICAgICAgIHNlbGYuZ3V0dGVyLnN0eWxlLmN1cnNvciA9ICcnO1xuICAgICAgICBzZWxmLnBhcmVudC5zdHlsZS5jdXJzb3IgPSAnJztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnJztcbiAgICB9XG5cbiAgICAvLyBzdGFydERyYWdnaW5nIGNhbGxzIGBjYWxjdWxhdGVTaXplc2AgdG8gc3RvcmUgdGhlIGluaXRhbCBzaXplIGluIHRoZSBwYWlyIG9iamVjdC5cbiAgICAvLyBJdCBhbHNvIGFkZHMgZXZlbnQgbGlzdGVuZXJzIGZvciBtb3VzZS90b3VjaCBldmVudHMsXG4gICAgLy8gYW5kIHByZXZlbnRzIHNlbGVjdGlvbiB3aGlsZSBkcmFnZ2luZyBzbyBhdm9pZCB0aGUgc2VsZWN0aW5nIHRleHQuXG4gICAgZnVuY3Rpb24gc3RhcnREcmFnZ2luZyhlKSB7XG4gICAgICAgIC8vIFJpZ2h0LWNsaWNraW5nIGNhbid0IHN0YXJ0IGRyYWdnaW5nLlxuICAgICAgICBpZiAoJ2J1dHRvbicgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGlhcyBmcmVxdWVudGx5IHVzZWQgdmFyaWFibGVzIHRvIHNhdmUgc3BhY2UuIDIwMCBieXRlcy5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgYSA9IGVsZW1lbnRzW3NlbGYuYV0uZWxlbWVudDtcbiAgICAgICAgdmFyIGIgPSBlbGVtZW50c1tzZWxmLmJdLmVsZW1lbnQ7XG5cbiAgICAgICAgLy8gQ2FsbCB0aGUgb25EcmFnU3RhcnQgY2FsbGJhY2suXG4gICAgICAgIGlmICghc2VsZi5kcmFnZ2luZykge1xuICAgICAgICAgICAgZ2V0T3B0aW9uKG9wdGlvbnMsICdvbkRyYWdTdGFydCcsIE5PT1ApKGdldFNpemVzKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9uJ3QgYWN0dWFsbHkgZHJhZyB0aGUgZWxlbWVudC4gV2UgZW11bGF0ZSB0aGF0IGluIHRoZSBkcmFnIGZ1bmN0aW9uLlxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBkcmFnZ2luZyBwcm9wZXJ0eSBvZiB0aGUgcGFpciBvYmplY3QuXG4gICAgICAgIHNlbGYuZHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0d28gZXZlbnQgbGlzdGVuZXJzIGJvdW5kIHRvIHRoZSBzYW1lIHBhaXIgb2JqZWN0IGFuZCBzdG9yZVxuICAgICAgICAvLyB0aGVtIGluIHRoZSBwYWlyIG9iamVjdC5cbiAgICAgICAgc2VsZi5tb3ZlID0gZHJhZy5iaW5kKHNlbGYpO1xuICAgICAgICBzZWxmLnN0b3AgPSBzdG9wRHJhZ2dpbmcuYmluZChzZWxmKTtcblxuICAgICAgICAvLyBBbGwgdGhlIGJpbmRpbmcuIGB3aW5kb3dgIGdldHMgdGhlIHN0b3AgZXZlbnRzIGluIGNhc2Ugd2UgZHJhZyBvdXQgb2YgdGhlIGVsZW1lbnRzLlxuICAgICAgICBnbG9iYWxbYWRkRXZlbnRMaXN0ZW5lcl0oJ21vdXNldXAnLCBzZWxmLnN0b3ApO1xuICAgICAgICBnbG9iYWxbYWRkRXZlbnRMaXN0ZW5lcl0oJ3RvdWNoZW5kJywgc2VsZi5zdG9wKTtcbiAgICAgICAgZ2xvYmFsW2FkZEV2ZW50TGlzdGVuZXJdKCd0b3VjaGNhbmNlbCcsIHNlbGYuc3RvcCk7XG4gICAgICAgIGdsb2JhbFthZGRFdmVudExpc3RlbmVyXSgnbW91c2Vtb3ZlJywgc2VsZi5tb3ZlKTtcbiAgICAgICAgZ2xvYmFsW2FkZEV2ZW50TGlzdGVuZXJdKCd0b3VjaG1vdmUnLCBzZWxmLm1vdmUpO1xuXG4gICAgICAgIC8vIERpc2FibGUgc2VsZWN0aW9uLiBEaXNhYmxlIVxuICAgICAgICBhW2FkZEV2ZW50TGlzdGVuZXJdKCdzZWxlY3RzdGFydCcsIE5PT1ApO1xuICAgICAgICBhW2FkZEV2ZW50TGlzdGVuZXJdKCdkcmFnc3RhcnQnLCBOT09QKTtcbiAgICAgICAgYlthZGRFdmVudExpc3RlbmVyXSgnc2VsZWN0c3RhcnQnLCBOT09QKTtcbiAgICAgICAgYlthZGRFdmVudExpc3RlbmVyXSgnZHJhZ3N0YXJ0JywgTk9PUCk7XG5cbiAgICAgICAgYS5zdHlsZS51c2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgICAgICBhLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICAgIGEuc3R5bGUuTW96VXNlclNlbGVjdCA9ICdub25lJztcbiAgICAgICAgYS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuXG4gICAgICAgIGIuc3R5bGUudXNlclNlbGVjdCA9ICdub25lJztcbiAgICAgICAgYi5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgICAgICBiLnN0eWxlLk1velVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICAgIGIuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcblxuICAgICAgICAvLyBTZXQgdGhlIGN1cnNvciBhdCBtdWx0aXBsZSBsZXZlbHNcbiAgICAgICAgc2VsZi5ndXR0ZXIuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuICAgICAgICBzZWxmLnBhcmVudC5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuXG4gICAgICAgIC8vIENhY2hlIHRoZSBpbml0aWFsIHNpemVzIG9mIHRoZSBwYWlyLlxuICAgICAgICBjYWxjdWxhdGVTaXplcy5jYWxsKHNlbGYpO1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgdGhlIG1vdXNlIGNvbXBhcmVkIHRvIHRoZSBndXR0ZXJcbiAgICAgICAgc2VsZi5kcmFnT2Zmc2V0ID0gZ2V0TW91c2VQb3NpdGlvbihlKSAtIHNlbGYuZW5kO1xuICAgIH1cblxuICAgIC8vIGFkanVzdCBzaXplcyB0byBlbnN1cmUgcGVyY2VudGFnZSBpcyB3aXRoaW4gbWluIHNpemUgYW5kIGd1dHRlci5cbiAgICBzaXplcyA9IHRyaW1Ub01pbihzaXplcyk7XG5cbiAgICAvLyA1LiBDcmVhdGUgcGFpciBhbmQgZWxlbWVudCBvYmplY3RzLiBFYWNoIHBhaXIgaGFzIGFuIGluZGV4IHJlZmVyZW5jZSB0b1xuICAgIC8vIGVsZW1lbnRzIGBhYCBhbmQgYGJgIG9mIHRoZSBwYWlyIChmaXJzdCBhbmQgc2Vjb25kIGVsZW1lbnRzKS5cbiAgICAvLyBMb29wIHRocm91Z2ggdGhlIGVsZW1lbnRzIHdoaWxlIHBhaXJpbmcgdGhlbSBvZmYuIEV2ZXJ5IHBhaXIgZ2V0cyBhXG4gICAgLy8gYHBhaXJgIG9iamVjdCBhbmQgYSBndXR0ZXIuXG4gICAgLy9cbiAgICAvLyBCYXNpYyBsb2dpYzpcbiAgICAvL1xuICAgIC8vIC0gU3RhcnRpbmcgd2l0aCB0aGUgc2Vjb25kIGVsZW1lbnQgYGkgPiAwYCwgY3JlYXRlIGBwYWlyYCBvYmplY3RzIHdpdGhcbiAgICAvLyAgIGBhID0gaSAtIDFgIGFuZCBgYiA9IGlgXG4gICAgLy8gLSBTZXQgZ3V0dGVyIHNpemVzIGJhc2VkIG9uIHRoZSBfcGFpcl8gYmVpbmcgZmlyc3QvbGFzdC4gVGhlIGZpcnN0IGFuZCBsYXN0XG4gICAgLy8gICBwYWlyIGhhdmUgZ3V0dGVyU2l6ZSAvIDIsIHNpbmNlIHRoZXkgb25seSBoYXZlIG9uZSBoYWxmIGd1dHRlciwgYW5kIG5vdCB0d28uXG4gICAgLy8gLSBDcmVhdGUgZ3V0dGVyIGVsZW1lbnRzIGFuZCBhZGQgZXZlbnQgbGlzdGVuZXJzLlxuICAgIC8vIC0gU2V0IHRoZSBzaXplIG9mIHRoZSBlbGVtZW50cywgbWludXMgdGhlIGd1dHRlciBzaXplcy5cbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gfCAgICAgaT0wICAgICB8ICAgICAgICAgaT0xICAgICAgICAgfCAgICAgICAgaT0yICAgICAgIHwgICAgICBpPTMgICAgIHxcbiAgICAvLyB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICAgIC8vIHwgICAgICAgICAgIHBhaXIgMCAgICAgICAgICAgICAgICBwYWlyIDEgICAgICAgICAgICAgcGFpciAyICAgICAgICAgICB8XG4gICAgLy8gfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBwYWlycyA9IFtdO1xuICAgIGVsZW1lbnRzID0gaWRzLm1hcChmdW5jdGlvbiAoaWQsIGkpIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBlbGVtZW50IG9iamVjdC5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50T3JTZWxlY3RvcihpZCksXG4gICAgICAgICAgICBzaXplOiBzaXplc1tpXSxcbiAgICAgICAgICAgIG1pblNpemU6IG1pblNpemVzW2ldLFxuICAgICAgICAgICAgbWF4U2l6ZTogbWF4U2l6ZXNbaV0sXG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwYWlyO1xuXG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBwYWlyIG9iamVjdCB3aXRoIGl0cyBtZXRhZGF0YS5cbiAgICAgICAgICAgIHBhaXIgPSB7XG4gICAgICAgICAgICAgICAgYTogaSAtIDEsXG4gICAgICAgICAgICAgICAgYjogaSxcbiAgICAgICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBwYWlyW2FHdXR0ZXJTaXplXSA9IGdldEd1dHRlclNpemUoXG4gICAgICAgICAgICAgICAgZ3V0dGVyU2l6ZSxcbiAgICAgICAgICAgICAgICBpIC0gMSA9PT0gMCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBndXR0ZXJBbGlnblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHBhaXJbYkd1dHRlclNpemVdID0gZ2V0R3V0dGVyU2l6ZShcbiAgICAgICAgICAgICAgICBndXR0ZXJTaXplLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGkgPT09IGlkcy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgIGd1dHRlckFsaWduXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgcGFyZW50IGhhcyBhIHJldmVyc2UgZmxleC1kaXJlY3Rpb24sIHN3aXRjaCB0aGUgcGFpciBlbGVtZW50cy5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBwYXJlbnRGbGV4RGlyZWN0aW9uID09PSAncm93LXJldmVyc2UnIHx8XG4gICAgICAgICAgICAgICAgcGFyZW50RmxleERpcmVjdGlvbiA9PT0gJ2NvbHVtbi1yZXZlcnNlJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBwYWlyLmE7XG4gICAgICAgICAgICAgICAgcGFpci5hID0gcGFpci5iO1xuICAgICAgICAgICAgICAgIHBhaXIuYiA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHNpemUgb2YgdGhlIGN1cnJlbnQgZWxlbWVudC4gSUU4IGlzIHN1cHBvcnRlZCBieVxuICAgICAgICAvLyBzdGF0aWNseSBhc3NpZ25pbmcgc2l6ZXMgd2l0aG91dCBkcmFnZ2FibGUgZ3V0dGVycy4gQXNzaWducyBhIHN0cmluZ1xuICAgICAgICAvLyB0byBgc2l6ZWAuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIENyZWF0ZSBndXR0ZXIgZWxlbWVudHMgZm9yIGVhY2ggcGFpci5cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICB2YXIgZ3V0dGVyRWxlbWVudCA9IGd1dHRlcihpLCBkaXJlY3Rpb24sIGVsZW1lbnQuZWxlbWVudCk7XG4gICAgICAgICAgICBzZXRHdXR0ZXJTaXplKGd1dHRlckVsZW1lbnQsIGd1dHRlclNpemUsIGkpO1xuXG4gICAgICAgICAgICAvLyBTYXZlIGJvdW5kIGV2ZW50IGxpc3RlbmVyIGZvciByZW1vdmFsIGxhdGVyXG4gICAgICAgICAgICBwYWlyW2d1dHRlclN0YXJ0RHJhZ2dpbmddID0gc3RhcnREcmFnZ2luZy5iaW5kKHBhaXIpO1xuXG4gICAgICAgICAgICAvLyBBdHRhY2ggYm91bmQgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgICAgIGd1dHRlckVsZW1lbnRbYWRkRXZlbnRMaXN0ZW5lcl0oXG4gICAgICAgICAgICAgICAgJ21vdXNlZG93bicsXG4gICAgICAgICAgICAgICAgcGFpcltndXR0ZXJTdGFydERyYWdnaW5nXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGd1dHRlckVsZW1lbnRbYWRkRXZlbnRMaXN0ZW5lcl0oXG4gICAgICAgICAgICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgICAgICAgICAgIHBhaXJbZ3V0dGVyU3RhcnREcmFnZ2luZ11cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZ3V0dGVyRWxlbWVudCwgZWxlbWVudC5lbGVtZW50KTtcblxuICAgICAgICAgICAgcGFpci5ndXR0ZXIgPSBndXR0ZXJFbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0RWxlbWVudFNpemUoXG4gICAgICAgICAgICBlbGVtZW50LmVsZW1lbnQsXG4gICAgICAgICAgICBlbGVtZW50LnNpemUsXG4gICAgICAgICAgICBnZXRHdXR0ZXJTaXplKFxuICAgICAgICAgICAgICAgIGd1dHRlclNpemUsXG4gICAgICAgICAgICAgICAgaSA9PT0gMCxcbiAgICAgICAgICAgICAgICBpID09PSBpZHMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICBndXR0ZXJBbGlnblxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBBZnRlciB0aGUgZmlyc3QgaXRlcmF0aW9uLCBhbmQgd2UgaGF2ZSBhIHBhaXIgb2JqZWN0LCBhcHBlbmQgaXQgdG8gdGhlXG4gICAgICAgIC8vIGxpc3Qgb2YgcGFpcnMuXG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgcGFpcnMucHVzaChwYWlyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtZW50XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGp1c3RUb01pbihlbGVtZW50KSB7XG4gICAgICAgIHZhciBpc0xhc3QgPSBlbGVtZW50LmkgPT09IHBhaXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIHBhaXIgPSBpc0xhc3QgPyBwYWlyc1tlbGVtZW50LmkgLSAxXSA6IHBhaXJzW2VsZW1lbnQuaV07XG5cbiAgICAgICAgY2FsY3VsYXRlU2l6ZXMuY2FsbChwYWlyKTtcblxuICAgICAgICB2YXIgc2l6ZSA9IGlzTGFzdFxuICAgICAgICAgICAgPyBwYWlyLnNpemUgLSBlbGVtZW50Lm1pblNpemUgLSBwYWlyW2JHdXR0ZXJTaXplXVxuICAgICAgICAgICAgOiBlbGVtZW50Lm1pblNpemUgKyBwYWlyW2FHdXR0ZXJTaXplXTtcblxuICAgICAgICBhZGp1c3QuY2FsbChwYWlyLCBzaXplKTtcbiAgICB9XG5cbiAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBjb21wdXRlZFNpemUgPSBlbGVtZW50LmVsZW1lbnRbZ2V0Qm91bmRpbmdDbGllbnRSZWN0XSgpW2RpbWVuc2lvbl07XG5cbiAgICAgICAgaWYgKGNvbXB1dGVkU2l6ZSA8IGVsZW1lbnQubWluU2l6ZSkge1xuICAgICAgICAgICAgaWYgKGV4cGFuZFRvTWluKSB7XG4gICAgICAgICAgICAgICAgYWRqdXN0VG9NaW4oZWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGVsZW1lbnQubWluU2l6ZSA9IGNvbXB1dGVkU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gc2V0U2l6ZXMobmV3U2l6ZXMpIHtcbiAgICAgICAgdmFyIHRyaW1tZWQgPSB0cmltVG9NaW4obmV3U2l6ZXMpO1xuICAgICAgICB0cmltbWVkLmZvckVhY2goZnVuY3Rpb24gKG5ld1NpemUsIGkpIHtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaSAtIDFdO1xuXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBlbGVtZW50c1twYWlyLmFdO1xuICAgICAgICAgICAgICAgIHZhciBiID0gZWxlbWVudHNbcGFpci5iXTtcblxuICAgICAgICAgICAgICAgIGEuc2l6ZSA9IHRyaW1tZWRbaSAtIDFdO1xuICAgICAgICAgICAgICAgIGIuc2l6ZSA9IG5ld1NpemU7XG5cbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2l6ZShhLmVsZW1lbnQsIGEuc2l6ZSwgcGFpclthR3V0dGVyU2l6ZV0sIGEuaSk7XG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFNpemUoYi5lbGVtZW50LCBiLnNpemUsIHBhaXJbYkd1dHRlclNpemVdLCBiLmkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXN0cm95KHByZXNlcnZlU3R5bGVzLCBwcmVzZXJ2ZUd1dHRlcikge1xuICAgICAgICBwYWlycy5mb3JFYWNoKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgICAgICBpZiAocHJlc2VydmVHdXR0ZXIgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBwYWlyLnBhcmVudC5yZW1vdmVDaGlsZChwYWlyLmd1dHRlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhaXIuZ3V0dGVyW3JlbW92ZUV2ZW50TGlzdGVuZXJdKFxuICAgICAgICAgICAgICAgICAgICAnbW91c2Vkb3duJyxcbiAgICAgICAgICAgICAgICAgICAgcGFpcltndXR0ZXJTdGFydERyYWdnaW5nXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcGFpci5ndXR0ZXJbcmVtb3ZlRXZlbnRMaXN0ZW5lcl0oXG4gICAgICAgICAgICAgICAgICAgICd0b3VjaHN0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgcGFpcltndXR0ZXJTdGFydERyYWdnaW5nXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmVzZXJ2ZVN0eWxlcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGVsZW1lbnRTdHlsZShcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uLFxuICAgICAgICAgICAgICAgICAgICBwYWlyLmEuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgcGFpclthR3V0dGVyU2l6ZV1cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc3R5bGUpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbcGFpci5hXS5lbGVtZW50LnN0eWxlW3Byb3BdID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzW3BhaXIuYl0uZWxlbWVudC5zdHlsZVtwcm9wXSA9ICcnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzZXRTaXplczogc2V0U2l6ZXMsXG4gICAgICAgIGdldFNpemVzOiBnZXRTaXplcyxcbiAgICAgICAgY29sbGFwc2U6IGZ1bmN0aW9uIGNvbGxhcHNlKGkpIHtcbiAgICAgICAgICAgIGFkanVzdFRvTWluKGVsZW1lbnRzW2ldKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveTogZGVzdHJveSxcbiAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgIHBhaXJzOiBwYWlycyxcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTcGxpdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/split.js/dist/split.es.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/vendor/Onix/js/codeEditor/grapeCodeEditor.js");
/******/ 	
/******/ })()
;