/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/vendor/Onix/js/codeEditor/code-editor/index.js":
/*!******************************************************************!*\
  !*** ./resources/vendor/Onix/js/codeEditor/code-editor/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CodeEditor\": () => (/* binding */ CodeEditor)\n/* harmony export */ });\n/* harmony import */ var split_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! split.js */ \"./node_modules/split.js/dist/split.es.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n//Original work Copyright (c) 2018, Duarte Henriques, https://github.com/portablemind/grapesjs-code-editor\n//Modified work Copyright (c) 2020, Brendon Ngirazi,\n//All rights reserved.\n\n\nvar CodeEditor = /*#__PURE__*/function () {\n  function CodeEditor(editor, opts) {\n    _classCallCheck(this, CodeEditor);\n    this.editor = editor;\n    this.$ = editor.$;\n    this.pfx = editor.getConfig(\"stylePrefix\");\n    this.opts = opts;\n    this.canvas = this.findWithinEditor(\".\".concat(this.pfx, \"cv-canvas\"));\n    this.panelViews = opts.appendTo ? this.$(opts.appendTo) : this.findWithinEditor(\".\".concat(this.pfx, \"pn-\").concat(opts.panelId));\n    this.isShowing = true;\n  }\n  _createClass(CodeEditor, [{\n    key: \"findPanel\",\n    value: function findPanel() {\n      var pn = this.editor.Panels;\n      var id = this.opts.panelId;\n      var panel = pn.getPanel(id) || pn.addPanel({\n        id: id\n      });\n      return panel;\n    }\n  }, {\n    key: \"findWithinEditor\",\n    value: function findWithinEditor(selector) {\n      return this.$(selector, this.editor.getEl());\n    }\n  }, {\n    key: \"buildCodeEditor\",\n    value: function buildCodeEditor(type) {\n      var editor = this.editor,\n        opts = this.opts;\n      return editor.CodeManager.createViewer(_objectSpread({\n        codeName: type === \"html\" ? \"htmlmixed\" : \"css\",\n        theme: \"hopscotch\",\n        readOnly: 0,\n        autoBeautify: 1,\n        autoCloseTags: 1,\n        autoCloseBrackets: 1,\n        styleActiveLine: 1,\n        smartIndent: 1\n      }, opts.codeViewOptions));\n    }\n  }, {\n    key: \"buildSection\",\n    value: function buildSection(type, codeViewer) {\n      var $ = this.$,\n        pfx = this.pfx,\n        opts = this.opts;\n      var section = $(\"<section></section>\");\n      var btnText = type === \"html\" ? opts.htmlBtnText : opts.cssBtnText;\n      var cleanCssBtn = opts.cleanCssBtn && type === \"css\" ? \"<button class=\\\"cp-delete-\".concat(type, \" \").concat(pfx, \"btn-prim\\\">\").concat(opts.cleanCssBtnText, \"</button>\") : \"\";\n      section.append($(\"\\n            <div class=\\\"codepanel-separator\\\">\\n                <div class=\\\"codepanel-label\\\">\".concat(type, \"</div>\\n                <div class=\\\"cp-btn-container\\\">\\n                    \").concat(cleanCssBtn, \"\\n                    <button class=\\\"cp-apply-\").concat(type, \" \").concat(pfx, \"btn-prim\\\">\").concat(btnText, \"</button>\\n                </div>\\n            </div>\")));\n      var codeViewerEl = codeViewer.getElement();\n      codeViewerEl.style.height = \"calc(100% - 30px)\";\n      section.append(codeViewerEl);\n      this.codePanel.append(section);\n      return section.get(0);\n    }\n  }, {\n    key: \"buildCodePanel\",\n    value: function buildCodePanel() {\n      var _this = this;\n      var $ = this.$,\n        editor = this.editor;\n      var panel = this.opts.panelId ? this.findPanel() : 0;\n      this.codePanel = $(\"<div></div>\");\n      this.codePanel.addClass(\"code-panel\");\n      this.htmlCodeEditor = this.buildCodeEditor(\"html\");\n      this.cssCodeEditor = this.buildCodeEditor(\"css\");\n      var sections = [this.buildSection(\"html\", this.htmlCodeEditor), this.buildSection(\"css\", this.cssCodeEditor)];\n      panel && !this.opts.appendTo && panel.set(\"appendContent\", this.codePanel).trigger(\"change:appendContent\");\n      this.opts.appendTo && $(this.opts.appendTo).append(this.codePanel);\n      this.updateEditorContents();\n      this.codePanel.find(\".cp-apply-html\").on(\"click\", this.updateHtml.bind(this));\n      this.codePanel.find(\".cp-apply-css\").on(\"click\", this.updateCss.bind(this));\n      this.opts.cleanCssBtn && this.codePanel.find(\".cp-delete-css\").on(\"click\", this.deleteSelectedCss.bind(this));\n      (0,split_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(sections, {\n        direction: \"vertical\",\n        sizes: [50, 50],\n        minSize: 100,\n        gutterSize: 1,\n        onDragEnd: this.refreshEditors.bind(this)\n      });\n      editor.on(\"component:update\", function (model) {\n        return _this.updateEditorContents();\n      });\n    }\n  }, {\n    key: \"showCodePanel\",\n    value: function showCodePanel() {\n      this.isShowing = true;\n      this.updateEditorContents();\n      this.codePanel.css(\"display\", \"block\");\n      // make sure editor is aware of width change after the 300ms effect ends\n      setTimeout(this.refreshEditors.bind(this), 320);\n      if (this.opts.preserveWidth) return;\n      this.panelViews.css(\"width\", this.opts.openState.pn);\n      this.canvas.css(\"width\", this.opts.openState.cv);\n    }\n  }, {\n    key: \"hideCodePanel\",\n    value: function hideCodePanel() {\n      if (this.codePanel) this.codePanel.css(\"display\", \"none\");\n      this.isShowing = false;\n      if (this.opts.preserveWidth) return;\n      this.panelViews.css(\"width\", this.opts.closedState.pn);\n      this.canvas.css(\"width\", this.opts.closedState.cv);\n    }\n  }, {\n    key: \"refreshEditors\",\n    value: function refreshEditors() {\n      this.htmlCodeEditor.refresh();\n      this.cssCodeEditor.refresh();\n    }\n  }, {\n    key: \"updateHtml\",\n    value: function updateHtml(e) {\n      e === null || e === void 0 ? void 0 : e.preventDefault();\n      var editor = this.editor,\n        component = this.component;\n      var htmlCode = this.htmlCodeEditor.getContent().trim();\n      if (!htmlCode || htmlCode === this.previousHtmlCode) return;\n      this.previousHtmlCode = htmlCode;\n      var idStyles = \"\";\n      this.cssCodeEditor.getContent().split(/(?<=}\\n)/g).forEach(function (rule) {\n        if (/^#/.test(rule)) idStyles += rule;\n      });\n      htmlCode += \"<style>\".concat(idStyles, \"</style>\");\n      editor.select(component.replaceWith(htmlCode));\n    }\n  }, {\n    key: \"updateCss\",\n    value: function updateCss(e) {\n      e === null || e === void 0 ? void 0 : e.preventDefault();\n      var cssCode = this.cssCodeEditor.getContent().trim();\n      if (!cssCode || cssCode === this.previousCssCode) return;\n      this.parseRemove(cssCode);\n      this.previousCssCode = cssCode;\n      this.editor.Components.addComponent(\"<style>\".concat(cssCode, \"</style>\"));\n    }\n  }, {\n    key: \"deleteSelectedCss\",\n    value: function deleteSelectedCss(e) {\n      var _this2 = this;\n      e === null || e === void 0 ? void 0 : e.preventDefault();\n      var selections = this.cssCodeEditor.editor.getSelections();\n      selections.forEach(function (selection) {\n        return _this2.parseRemove(selection);\n      });\n      this.cssCodeEditor.editor.deleteH();\n    }\n  }, {\n    key: \"parseRemove\",\n    value: function parseRemove(removeCss) {\n      var _this3 = this;\n      var editor = this.editor;\n      var cssc = editor.CssComposer;\n      var allRules = cssc.getAll();\n      editor.Parser.parseCss(removeCss).forEach(function (p) {\n        var config = {\n          singleAtRule: p.singleAtRule,\n          atRuleType: p.atRuleType,\n          mediaText: p.mediaText,\n          state: p.state\n        };\n        p.selectors.length && p.selectors.forEach(function (selector) {\n          _this3.removeSelector(selector, allRules, cssc, config);\n        });\n        p.selectorsAdd && p.selectorsAdd.split(\", \").forEach(function (selector) {\n          _this3.removeSelector(selector, allRules, cssc, config);\n        });\n      });\n    }\n  }, {\n    key: \"removeSelector\",\n    value: function removeSelector(rule, allRules, cssc) {\n      var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var singleAtRule = opts.singleAtRule,\n        atRuleType = opts.atRuleType,\n        mediaText = opts.mediaText,\n        state = opts.state;\n      var toRemove = allRules.filter(function (r) {\n        if (atRuleType && mediaText) return function (r) {\n          return r.get(\"atRuleType\") == atRuleType && r.get(\"mediaText\") == mediaText;\n        };else if (atRuleType && singleAtRule) return function (r) {\n          return r.get(\"atRuleType\") == atRuleType && r.get(\"singleAtRule\") == singleAtRule;\n        };else if (state) return r == cssc.getRule(\"\".concat(rule, \":\").concat(state));\n        return r == cssc.getRule(rule);\n      });\n      allRules.remove(toRemove);\n    }\n  }, {\n    key: \"updateEditorContents\",\n    value: function updateEditorContents() {\n      if (!this.isShowing) return;\n      this.component = this.editor.getSelected();\n      if (this.component) {\n        this.htmlCodeEditor.setContent(this.getComponentHtml(this.component));\n        this.cssCodeEditor.setContent(this.editor.CodeManager.getCode(this.component, \"css\", {\n          cssc: this.editor.CssComposer\n        }));\n      }\n    }\n  }, {\n    key: \"getComponentHtml\",\n    value: function getComponentHtml(component) {\n      var pfx = this.pfx,\n        opts = this.opts;\n      var result = \"\";\n      var componentEl = component.getEl();\n      !opts.clearData && componentEl.classList.remove(\"\".concat(pfx, \"selected\"));\n      var html = opts.clearData ? component.toHTML() : componentEl.id === \"wrapper\" ? componentEl.innerHTML : componentEl.outerHTML;\n      !opts.clearData && componentEl.classList.add(\"\".concat(pfx, \"selected\"));\n      result += html;\n      var js = opts.editJs ? component.getScriptString() : \"\";\n      result += js ? \"<script>\".concat(js, \"</script>\") : \"\";\n      return result;\n    }\n  }]);\n  return CodeEditor;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvdmVuZG9yL09uaXgvanMvY29kZUVkaXRvci9jb2RlLWVkaXRvci9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFNkI7QUFFdEIsSUFBTUMsVUFBVTtFQUNuQixvQkFBWUMsTUFBTSxFQUFFQyxJQUFJLEVBQUU7SUFBQTtJQUN0QixJQUFJLENBQUNELE1BQU0sR0FBR0EsTUFBTTtJQUNwQixJQUFJLENBQUNFLENBQUMsR0FBR0YsTUFBTSxDQUFDRSxDQUFDO0lBQ2pCLElBQUksQ0FBQ0MsR0FBRyxHQUFHSCxNQUFNLENBQUNJLFNBQVMsQ0FBQyxhQUFhLENBQUM7SUFDMUMsSUFBSSxDQUFDSCxJQUFJLEdBQUdBLElBQUk7SUFDaEIsSUFBSSxDQUFDSSxNQUFNLEdBQUcsSUFBSSxDQUFDQyxnQkFBZ0IsWUFBSyxJQUFJLENBQUNILEdBQUcsZUFBWTtJQUM1RCxJQUFJLENBQUNJLFVBQVUsR0FBR04sSUFBSSxDQUFDTyxRQUFRLEdBQ3pCLElBQUksQ0FBQ04sQ0FBQyxDQUFDRCxJQUFJLENBQUNPLFFBQVEsQ0FBQyxHQUNyQixJQUFJLENBQUNGLGdCQUFnQixZQUFLLElBQUksQ0FBQ0gsR0FBRyxnQkFBTUYsSUFBSSxDQUFDUSxPQUFPLEVBQUc7SUFDN0QsSUFBSSxDQUFDQyxTQUFTLEdBQUcsSUFBSTtFQUN6QjtFQUFDO0lBQUE7SUFBQSxPQUVELHFCQUFZO01BQ1IsSUFBTUMsRUFBRSxHQUFHLElBQUksQ0FBQ1gsTUFBTSxDQUFDWSxNQUFNO01BQzdCLElBQU1DLEVBQUUsR0FBRyxJQUFJLENBQUNaLElBQUksQ0FBQ1EsT0FBTztNQUM1QixJQUFNSyxLQUFLLEdBQUdILEVBQUUsQ0FBQ0ksUUFBUSxDQUFDRixFQUFFLENBQUMsSUFBSUYsRUFBRSxDQUFDSyxRQUFRLENBQUM7UUFBRUgsRUFBRSxFQUFGQTtNQUFHLENBQUMsQ0FBQztNQUNwRCxPQUFPQyxLQUFLO0lBQ2hCO0VBQUM7SUFB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U0FBUyxFQUFFO01BQ3hCLElBQVExRSxHQUFHLEdBQVcsSUFBSSxDQUFsQkEsR0FBRztRQUFFRixJQUFJLEdBQUssSUFBSSxDQUFiQSxJQUFJO01BQ2pCLElBQUkySCxNQUFNLEdBQUcsRUFBRTtNQUNmLElBQU1DLFdBQVcsR0FBR2hELFNBQVMsQ0FBQzNELEtBQUssRUFBRTtNQUVyQyxDQUFDakIsSUFBSSxDQUFDNkgsU0FBUyxJQUFJRCxXQUFXLENBQUNFLFNBQVMsQ0FBQ1IsTUFBTSxXQUFJcEgsR0FBRyxjQUFXO01BQ2pFLElBQU02SCxJQUFJLEdBQUcvSCxJQUFJLENBQUM2SCxTQUFTLEdBQ3JCakQsU0FBUyxDQUFDb0QsTUFBTSxFQUFFLEdBQ2xCSixXQUFXLENBQUNoSCxFQUFFLEtBQUssU0FBUyxHQUM1QmdILFdBQVcsQ0FBQ0ssU0FBUyxHQUNyQkwsV0FBVyxDQUFDTSxTQUFTO01BQzNCLENBQUNsSSxJQUFJLENBQUM2SCxTQUFTLElBQUlELFdBQVcsQ0FBQ0UsU0FBUyxDQUFDSyxHQUFHLFdBQUlqSSxHQUFHLGNBQVc7TUFDOUR5SCxNQUFNLElBQUlJLElBQUk7TUFFZCxJQUFNSyxFQUFFLEdBQUdwSSxJQUFJLENBQUNxSSxNQUFNLEdBQUd6RCxTQUFTLENBQUMwRCxlQUFlLEVBQUUsR0FBRyxFQUFFO01BQ3pEWCxNQUFNLElBQUlTLEVBQUUscUJBQWNBLEVBQUUsaUJBQWMsRUFBRTtNQUU1QyxPQUFPVCxNQUFNO0lBQ2pCO0VBQUM7RUFBQTtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3ZlbmRvci9Pbml4L2pzL2NvZGVFZGl0b3IvY29kZS1lZGl0b3IvaW5kZXguanM/Yjg5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvL09yaWdpbmFsIHdvcmsgQ29weXJpZ2h0IChjKSAyMDE4LCBEdWFydGUgSGVucmlxdWVzLCBodHRwczovL2dpdGh1Yi5jb20vcG9ydGFibGVtaW5kL2dyYXBlc2pzLWNvZGUtZWRpdG9yXHJcbi8vTW9kaWZpZWQgd29yayBDb3B5cmlnaHQgKGMpIDIwMjAsIEJyZW5kb24gTmdpcmF6aSxcclxuLy9BbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5cclxuaW1wb3J0IFNwbGl0IGZyb20gXCJzcGxpdC5qc1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIENvZGVFZGl0b3Ige1xyXG4gICAgY29uc3RydWN0b3IoZWRpdG9yLCBvcHRzKSB7XHJcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XHJcbiAgICAgICAgdGhpcy4kID0gZWRpdG9yLiQ7XHJcbiAgICAgICAgdGhpcy5wZnggPSBlZGl0b3IuZ2V0Q29uZmlnKFwic3R5bGVQcmVmaXhcIik7XHJcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcclxuICAgICAgICB0aGlzLmNhbnZhcyA9IHRoaXMuZmluZFdpdGhpbkVkaXRvcihgLiR7dGhpcy5wZnh9Y3YtY2FudmFzYCk7XHJcbiAgICAgICAgdGhpcy5wYW5lbFZpZXdzID0gb3B0cy5hcHBlbmRUb1xyXG4gICAgICAgICAgICA/IHRoaXMuJChvcHRzLmFwcGVuZFRvKVxyXG4gICAgICAgICAgICA6IHRoaXMuZmluZFdpdGhpbkVkaXRvcihgLiR7dGhpcy5wZnh9cG4tJHtvcHRzLnBhbmVsSWR9YCk7XHJcbiAgICAgICAgdGhpcy5pc1Nob3dpbmcgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZpbmRQYW5lbCgpIHtcclxuICAgICAgICBjb25zdCBwbiA9IHRoaXMuZWRpdG9yLlBhbmVscztcclxuICAgICAgICBjb25zdCBpZCA9IHRoaXMub3B0cy5wYW5lbElkO1xyXG4gICAgICAgIGNvbnN0IHBhbmVsID0gcG4uZ2V0UGFuZWwoaWQpIHx8IHBuLmFkZFBhbmVsKHsgaWQgfSk7XHJcbiAgICAgICAgcmV0dXJuIHBhbmVsO1xyXG4gICAgfVxyXG5cclxuICAgIGZpbmRXaXRoaW5FZGl0b3Ioc2VsZWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4kKHNlbGVjdG9yLCB0aGlzLmVkaXRvci5nZXRFbCgpKTtcclxuICAgIH1cclxuXHJcbiAgICBidWlsZENvZGVFZGl0b3IodHlwZSkge1xyXG4gICAgICAgIGNvbnN0IHsgZWRpdG9yLCBvcHRzIH0gPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gZWRpdG9yLkNvZGVNYW5hZ2VyLmNyZWF0ZVZpZXdlcih7XHJcbiAgICAgICAgICAgIGNvZGVOYW1lOiB0eXBlID09PSBcImh0bWxcIiA/IFwiaHRtbG1peGVkXCIgOiBcImNzc1wiLFxyXG4gICAgICAgICAgICB0aGVtZTogXCJob3BzY290Y2hcIixcclxuICAgICAgICAgICAgcmVhZE9ubHk6IDAsXHJcbiAgICAgICAgICAgIGF1dG9CZWF1dGlmeTogMSxcclxuICAgICAgICAgICAgYXV0b0Nsb3NlVGFnczogMSxcclxuICAgICAgICAgICAgYXV0b0Nsb3NlQnJhY2tldHM6IDEsXHJcbiAgICAgICAgICAgIHN0eWxlQWN0aXZlTGluZTogMSxcclxuICAgICAgICAgICAgc21hcnRJbmRlbnQ6IDEsXHJcbiAgICAgICAgICAgIC4uLm9wdHMuY29kZVZpZXdPcHRpb25zLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGJ1aWxkU2VjdGlvbih0eXBlLCBjb2RlVmlld2VyKSB7XHJcbiAgICAgICAgY29uc3QgeyAkLCBwZngsIG9wdHMgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3Qgc2VjdGlvbiA9ICQoXCI8c2VjdGlvbj48L3NlY3Rpb24+XCIpO1xyXG4gICAgICAgIGNvbnN0IGJ0blRleHQgPSB0eXBlID09PSBcImh0bWxcIiA/IG9wdHMuaHRtbEJ0blRleHQgOiBvcHRzLmNzc0J0blRleHQ7XHJcbiAgICAgICAgY29uc3QgY2xlYW5Dc3NCdG4gPVxyXG4gICAgICAgICAgICBvcHRzLmNsZWFuQ3NzQnRuICYmIHR5cGUgPT09IFwiY3NzXCJcclxuICAgICAgICAgICAgICAgID8gYDxidXR0b24gY2xhc3M9XCJjcC1kZWxldGUtJHt0eXBlfSAke3BmeH1idG4tcHJpbVwiPiR7b3B0cy5jbGVhbkNzc0J0blRleHR9PC9idXR0b24+YFxyXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xyXG4gICAgICAgIHNlY3Rpb24uYXBwZW5kKFxyXG4gICAgICAgICAgICAkKGBcclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvZGVwYW5lbC1zZXBhcmF0b3JcIj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2RlcGFuZWwtbGFiZWxcIj4ke3R5cGV9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY3AtYnRuLWNvbnRhaW5lclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICR7Y2xlYW5Dc3NCdG59XHJcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImNwLWFwcGx5LSR7dHlwZX0gJHtwZnh9YnRuLXByaW1cIj4ke2J0blRleHR9PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+YClcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnN0IGNvZGVWaWV3ZXJFbCA9IGNvZGVWaWV3ZXIuZ2V0RWxlbWVudCgpO1xyXG4gICAgICAgIGNvZGVWaWV3ZXJFbC5zdHlsZS5oZWlnaHQgPSBcImNhbGMoMTAwJSAtIDMwcHgpXCI7XHJcbiAgICAgICAgc2VjdGlvbi5hcHBlbmQoY29kZVZpZXdlckVsKTtcclxuICAgICAgICB0aGlzLmNvZGVQYW5lbC5hcHBlbmQoc2VjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIHNlY3Rpb24uZ2V0KDApO1xyXG4gICAgfVxyXG5cclxuICAgIGJ1aWxkQ29kZVBhbmVsKCkge1xyXG4gICAgICAgIGNvbnN0IHsgJCwgZWRpdG9yIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHBhbmVsID0gdGhpcy5vcHRzLnBhbmVsSWQgPyB0aGlzLmZpbmRQYW5lbCgpIDogMDtcclxuICAgICAgICB0aGlzLmNvZGVQYW5lbCA9ICQoXCI8ZGl2PjwvZGl2PlwiKTtcclxuICAgICAgICB0aGlzLmNvZGVQYW5lbC5hZGRDbGFzcyhcImNvZGUtcGFuZWxcIik7XHJcblxyXG4gICAgICAgIHRoaXMuaHRtbENvZGVFZGl0b3IgPSB0aGlzLmJ1aWxkQ29kZUVkaXRvcihcImh0bWxcIik7XHJcbiAgICAgICAgdGhpcy5jc3NDb2RlRWRpdG9yID0gdGhpcy5idWlsZENvZGVFZGl0b3IoXCJjc3NcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IHNlY3Rpb25zID0gW1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkU2VjdGlvbihcImh0bWxcIiwgdGhpcy5odG1sQ29kZUVkaXRvciksXHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRTZWN0aW9uKFwiY3NzXCIsIHRoaXMuY3NzQ29kZUVkaXRvciksXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgcGFuZWwgJiZcclxuICAgICAgICAgICAgIXRoaXMub3B0cy5hcHBlbmRUbyAmJlxyXG4gICAgICAgICAgICBwYW5lbFxyXG4gICAgICAgICAgICAgICAgLnNldChcImFwcGVuZENvbnRlbnRcIiwgdGhpcy5jb2RlUGFuZWwpXHJcbiAgICAgICAgICAgICAgICAudHJpZ2dlcihcImNoYW5nZTphcHBlbmRDb250ZW50XCIpO1xyXG4gICAgICAgIHRoaXMub3B0cy5hcHBlbmRUbyAmJiAkKHRoaXMub3B0cy5hcHBlbmRUbykuYXBwZW5kKHRoaXMuY29kZVBhbmVsKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvckNvbnRlbnRzKCk7XHJcblxyXG4gICAgICAgIHRoaXMuY29kZVBhbmVsXHJcbiAgICAgICAgICAgIC5maW5kKFwiLmNwLWFwcGx5LWh0bWxcIilcclxuICAgICAgICAgICAgLm9uKFwiY2xpY2tcIiwgdGhpcy51cGRhdGVIdG1sLmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICB0aGlzLmNvZGVQYW5lbFxyXG4gICAgICAgICAgICAuZmluZChcIi5jcC1hcHBseS1jc3NcIilcclxuICAgICAgICAgICAgLm9uKFwiY2xpY2tcIiwgdGhpcy51cGRhdGVDc3MuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgIHRoaXMub3B0cy5jbGVhbkNzc0J0biAmJlxyXG4gICAgICAgICAgICB0aGlzLmNvZGVQYW5lbFxyXG4gICAgICAgICAgICAgICAgLmZpbmQoXCIuY3AtZGVsZXRlLWNzc1wiKVxyXG4gICAgICAgICAgICAgICAgLm9uKFwiY2xpY2tcIiwgdGhpcy5kZWxldGVTZWxlY3RlZENzcy5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgU3BsaXQoc2VjdGlvbnMsIHtcclxuICAgICAgICAgICAgZGlyZWN0aW9uOiBcInZlcnRpY2FsXCIsXHJcbiAgICAgICAgICAgIHNpemVzOiBbNTAsIDUwXSxcclxuICAgICAgICAgICAgbWluU2l6ZTogMTAwLFxyXG4gICAgICAgICAgICBndXR0ZXJTaXplOiAxLFxyXG4gICAgICAgICAgICBvbkRyYWdFbmQ6IHRoaXMucmVmcmVzaEVkaXRvcnMuYmluZCh0aGlzKSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZWRpdG9yLm9uKFwiY29tcG9uZW50OnVwZGF0ZVwiLCAobW9kZWwpID0+IHRoaXMudXBkYXRlRWRpdG9yQ29udGVudHMoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2hvd0NvZGVQYW5lbCgpIHtcclxuICAgICAgICB0aGlzLmlzU2hvd2luZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3JDb250ZW50cygpO1xyXG4gICAgICAgIHRoaXMuY29kZVBhbmVsLmNzcyhcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcclxuICAgICAgICAvLyBtYWtlIHN1cmUgZWRpdG9yIGlzIGF3YXJlIG9mIHdpZHRoIGNoYW5nZSBhZnRlciB0aGUgMzAwbXMgZWZmZWN0IGVuZHNcclxuICAgICAgICBzZXRUaW1lb3V0KHRoaXMucmVmcmVzaEVkaXRvcnMuYmluZCh0aGlzKSwgMzIwKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMub3B0cy5wcmVzZXJ2ZVdpZHRoKSByZXR1cm47XHJcblxyXG4gICAgICAgIHRoaXMucGFuZWxWaWV3cy5jc3MoXCJ3aWR0aFwiLCB0aGlzLm9wdHMub3BlblN0YXRlLnBuKTtcclxuICAgICAgICB0aGlzLmNhbnZhcy5jc3MoXCJ3aWR0aFwiLCB0aGlzLm9wdHMub3BlblN0YXRlLmN2KTtcclxuICAgIH1cclxuXHJcbiAgICBoaWRlQ29kZVBhbmVsKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvZGVQYW5lbCkgdGhpcy5jb2RlUGFuZWwuY3NzKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XHJcbiAgICAgICAgdGhpcy5pc1Nob3dpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMub3B0cy5wcmVzZXJ2ZVdpZHRoKSByZXR1cm47XHJcblxyXG4gICAgICAgIHRoaXMucGFuZWxWaWV3cy5jc3MoXCJ3aWR0aFwiLCB0aGlzLm9wdHMuY2xvc2VkU3RhdGUucG4pO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLmNzcyhcIndpZHRoXCIsIHRoaXMub3B0cy5jbG9zZWRTdGF0ZS5jdik7XHJcbiAgICB9XHJcblxyXG4gICAgcmVmcmVzaEVkaXRvcnMoKSB7XHJcbiAgICAgICAgdGhpcy5odG1sQ29kZUVkaXRvci5yZWZyZXNoKCk7XHJcbiAgICAgICAgdGhpcy5jc3NDb2RlRWRpdG9yLnJlZnJlc2goKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVIdG1sKGUpIHtcclxuICAgICAgICBlPy5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGNvbnN0IHsgZWRpdG9yLCBjb21wb25lbnQgfSA9IHRoaXM7XHJcbiAgICAgICAgbGV0IGh0bWxDb2RlID0gdGhpcy5odG1sQ29kZUVkaXRvci5nZXRDb250ZW50KCkudHJpbSgpO1xyXG4gICAgICAgIGlmICghaHRtbENvZGUgfHwgaHRtbENvZGUgPT09IHRoaXMucHJldmlvdXNIdG1sQ29kZSkgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNIdG1sQ29kZSA9IGh0bWxDb2RlO1xyXG5cclxuICAgICAgICBsZXQgaWRTdHlsZXMgPSBcIlwiO1xyXG4gICAgICAgIHRoaXMuY3NzQ29kZUVkaXRvclxyXG4gICAgICAgICAgICAuZ2V0Q29udGVudCgpXHJcbiAgICAgICAgICAgIC5zcGxpdCgvKD88PX1cXG4pL2cpXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKChydWxlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoL14jLy50ZXN0KHJ1bGUpKSBpZFN0eWxlcyArPSBydWxlO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaHRtbENvZGUgKz0gYDxzdHlsZT4ke2lkU3R5bGVzfTwvc3R5bGU+YDtcclxuXHJcbiAgICAgICAgZWRpdG9yLnNlbGVjdChjb21wb25lbnQucmVwbGFjZVdpdGgoaHRtbENvZGUpKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVDc3MoZSkge1xyXG4gICAgICAgIGU/LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgY29uc3QgY3NzQ29kZSA9IHRoaXMuY3NzQ29kZUVkaXRvci5nZXRDb250ZW50KCkudHJpbSgpO1xyXG4gICAgICAgIGlmICghY3NzQ29kZSB8fCBjc3NDb2RlID09PSB0aGlzLnByZXZpb3VzQ3NzQ29kZSkgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMucGFyc2VSZW1vdmUoY3NzQ29kZSk7XHJcbiAgICAgICAgdGhpcy5wcmV2aW91c0Nzc0NvZGUgPSBjc3NDb2RlO1xyXG4gICAgICAgIHRoaXMuZWRpdG9yLkNvbXBvbmVudHMuYWRkQ29tcG9uZW50KGA8c3R5bGU+JHtjc3NDb2RlfTwvc3R5bGU+YCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVsZXRlU2VsZWN0ZWRDc3MoZSkge1xyXG4gICAgICAgIGU/LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9ucyA9IHRoaXMuY3NzQ29kZUVkaXRvci5lZGl0b3IuZ2V0U2VsZWN0aW9ucygpO1xyXG4gICAgICAgIHNlbGVjdGlvbnMuZm9yRWFjaCgoc2VsZWN0aW9uKSA9PiB0aGlzLnBhcnNlUmVtb3ZlKHNlbGVjdGlvbikpO1xyXG4gICAgICAgIHRoaXMuY3NzQ29kZUVkaXRvci5lZGl0b3IuZGVsZXRlSCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHBhcnNlUmVtb3ZlKHJlbW92ZUNzcykge1xyXG4gICAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGNzc2MgPSBlZGl0b3IuQ3NzQ29tcG9zZXI7XHJcbiAgICAgICAgY29uc3QgYWxsUnVsZXMgPSBjc3NjLmdldEFsbCgpO1xyXG4gICAgICAgIGVkaXRvci5QYXJzZXIucGFyc2VDc3MocmVtb3ZlQ3NzKS5mb3JFYWNoKChwKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcclxuICAgICAgICAgICAgICAgIHNpbmdsZUF0UnVsZTogcC5zaW5nbGVBdFJ1bGUsXHJcbiAgICAgICAgICAgICAgICBhdFJ1bGVUeXBlOiBwLmF0UnVsZVR5cGUsXHJcbiAgICAgICAgICAgICAgICBtZWRpYVRleHQ6IHAubWVkaWFUZXh0LFxyXG4gICAgICAgICAgICAgICAgc3RhdGU6IHAuc3RhdGUsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHAuc2VsZWN0b3JzLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAgICAgcC5zZWxlY3RvcnMuZm9yRWFjaCgoc2VsZWN0b3IpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVNlbGVjdG9yKHNlbGVjdG9yLCBhbGxSdWxlcywgY3NzYywgY29uZmlnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBwLnNlbGVjdG9yc0FkZCAmJlxyXG4gICAgICAgICAgICAgICAgcC5zZWxlY3RvcnNBZGQuc3BsaXQoXCIsIFwiKS5mb3JFYWNoKChzZWxlY3RvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU2VsZWN0b3Ioc2VsZWN0b3IsIGFsbFJ1bGVzLCBjc3NjLCBjb25maWcpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlU2VsZWN0b3IocnVsZSwgYWxsUnVsZXMsIGNzc2MsIG9wdHMgPSB7fSkge1xyXG4gICAgICAgIGNvbnN0IHsgc2luZ2xlQXRSdWxlLCBhdFJ1bGVUeXBlLCBtZWRpYVRleHQsIHN0YXRlIH0gPSBvcHRzO1xyXG4gICAgICAgIGNvbnN0IHRvUmVtb3ZlID0gYWxsUnVsZXMuZmlsdGVyKChyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChhdFJ1bGVUeXBlICYmIG1lZGlhVGV4dClcclxuICAgICAgICAgICAgICAgIHJldHVybiAocikgPT5cclxuICAgICAgICAgICAgICAgICAgICByLmdldChcImF0UnVsZVR5cGVcIikgPT0gYXRSdWxlVHlwZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHIuZ2V0KFwibWVkaWFUZXh0XCIpID09IG1lZGlhVGV4dDtcclxuICAgICAgICAgICAgZWxzZSBpZiAoYXRSdWxlVHlwZSAmJiBzaW5nbGVBdFJ1bGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHIpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgci5nZXQoXCJhdFJ1bGVUeXBlXCIpID09IGF0UnVsZVR5cGUgJiZcclxuICAgICAgICAgICAgICAgICAgICByLmdldChcInNpbmdsZUF0UnVsZVwiKSA9PSBzaW5nbGVBdFJ1bGU7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlKSByZXR1cm4gciA9PSBjc3NjLmdldFJ1bGUoYCR7cnVsZX06JHtzdGF0ZX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIHIgPT0gY3NzYy5nZXRSdWxlKHJ1bGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFsbFJ1bGVzLnJlbW92ZSh0b1JlbW92ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlRWRpdG9yQ29udGVudHMoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzU2hvd2luZykgcmV0dXJuO1xyXG5cclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IHRoaXMuZWRpdG9yLmdldFNlbGVjdGVkKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaHRtbENvZGVFZGl0b3Iuc2V0Q29udGVudChcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50SHRtbCh0aGlzLmNvbXBvbmVudClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhpcy5jc3NDb2RlRWRpdG9yLnNldENvbnRlbnQoXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5Db2RlTWFuYWdlci5nZXRDb2RlKHRoaXMuY29tcG9uZW50LCBcImNzc1wiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3NzYzogdGhpcy5lZGl0b3IuQ3NzQ29tcG9zZXIsXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXRDb21wb25lbnRIdG1sKGNvbXBvbmVudCkge1xyXG4gICAgICAgIGNvbnN0IHsgcGZ4LCBvcHRzIH0gPSB0aGlzO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xyXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudEVsID0gY29tcG9uZW50LmdldEVsKCk7XHJcblxyXG4gICAgICAgICFvcHRzLmNsZWFyRGF0YSAmJiBjb21wb25lbnRFbC5jbGFzc0xpc3QucmVtb3ZlKGAke3BmeH1zZWxlY3RlZGApO1xyXG4gICAgICAgIGNvbnN0IGh0bWwgPSBvcHRzLmNsZWFyRGF0YVxyXG4gICAgICAgICAgICA/IGNvbXBvbmVudC50b0hUTUwoKVxyXG4gICAgICAgICAgICA6IGNvbXBvbmVudEVsLmlkID09PSBcIndyYXBwZXJcIlxyXG4gICAgICAgICAgICA/IGNvbXBvbmVudEVsLmlubmVySFRNTFxyXG4gICAgICAgICAgICA6IGNvbXBvbmVudEVsLm91dGVySFRNTDtcclxuICAgICAgICAhb3B0cy5jbGVhckRhdGEgJiYgY29tcG9uZW50RWwuY2xhc3NMaXN0LmFkZChgJHtwZnh9c2VsZWN0ZWRgKTtcclxuICAgICAgICByZXN1bHQgKz0gaHRtbDtcclxuXHJcbiAgICAgICAgY29uc3QganMgPSBvcHRzLmVkaXRKcyA/IGNvbXBvbmVudC5nZXRTY3JpcHRTdHJpbmcoKSA6IFwiXCI7XHJcbiAgICAgICAgcmVzdWx0ICs9IGpzID8gYDxzY3JpcHQ+JHtqc308L3NjcmlwdD5gIDogXCJcIjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOlsiU3BsaXQiLCJDb2RlRWRpdG9yIiwiZWRpdG9yIiwib3B0cyIsIiQiLCJwZngiLCJnZXRDb25maWciLCJjYW52YXMiLCJmaW5kV2l0aGluRWRpdG9yIiwicGFuZWxWaWV3cyIsImFwcGVuZFRvIiwicGFuZWxJZCIsImlzU2hvd2luZyIsInBuIiwiUGFuZWxzIiwiaWQiLCJwYW5lbCIsImdldFBhbmVsIiwiYWRkUGFuZWwiLCJzZWxlY3RvciIsImdldEVsIiwidHlwZSIsIkNvZGVNYW5hZ2VyIiwiY3JlYXRlVmlld2VyIiwiY29kZU5hbWUiLCJ0aGVtZSIsInJlYWRPbmx5IiwiYXV0b0JlYXV0aWZ5IiwiYXV0b0Nsb3NlVGFncyIsImF1dG9DbG9zZUJyYWNrZXRzIiwic3R5bGVBY3RpdmVMaW5lIiwic21hcnRJbmRlbnQiLCJjb2RlVmlld09wdGlvbnMiLCJjb2RlVmlld2VyIiwic2VjdGlvbiIsImJ0blRleHQiLCJodG1sQnRuVGV4dCIsImNzc0J0blRleHQiLCJjbGVhbkNzc0J0biIsImNsZWFuQ3NzQnRuVGV4dCIsImFwcGVuZCIsImNvZGVWaWV3ZXJFbCIsImdldEVsZW1lbnQiLCJzdHlsZSIsImhlaWdodCIsImNvZGVQYW5lbCIsImdldCIsImZpbmRQYW5lbCIsImFkZENsYXNzIiwiaHRtbENvZGVFZGl0b3IiLCJidWlsZENvZGVFZGl0b3IiLCJjc3NDb2RlRWRpdG9yIiwic2VjdGlvbnMiLCJidWlsZFNlY3Rpb24iLCJzZXQiLCJ0cmlnZ2VyIiwidXBkYXRlRWRpdG9yQ29udGVudHMiLCJmaW5kIiwib24iLCJ1cGRhdGVIdG1sIiwiYmluZCIsInVwZGF0ZUNzcyIsImRlbGV0ZVNlbGVjdGVkQ3NzIiwiZGlyZWN0aW9uIiwic2l6ZXMiLCJtaW5TaXplIiwiZ3V0dGVyU2l6ZSIsIm9uRHJhZ0VuZCIsInJlZnJlc2hFZGl0b3JzIiwibW9kZWwiLCJjc3MiLCJzZXRUaW1lb3V0IiwicHJlc2VydmVXaWR0aCIsIm9wZW5TdGF0ZSIsImN2IiwiY2xvc2VkU3RhdGUiLCJyZWZyZXNoIiwiZSIsInByZXZlbnREZWZhdWx0IiwiY29tcG9uZW50IiwiaHRtbENvZGUiLCJnZXRDb250ZW50IiwidHJpbSIsInByZXZpb3VzSHRtbENvZGUiLCJpZFN0eWxlcyIsInNwbGl0IiwiZm9yRWFjaCIsInJ1bGUiLCJ0ZXN0Iiwic2VsZWN0IiwicmVwbGFjZVdpdGgiLCJjc3NDb2RlIiwicHJldmlvdXNDc3NDb2RlIiwicGFyc2VSZW1vdmUiLCJDb21wb25lbnRzIiwiYWRkQ29tcG9uZW50Iiwic2VsZWN0aW9ucyIsImdldFNlbGVjdGlvbnMiLCJzZWxlY3Rpb24iLCJkZWxldGVIIiwicmVtb3ZlQ3NzIiwiY3NzYyIsIkNzc0NvbXBvc2VyIiwiYWxsUnVsZXMiLCJnZXRBbGwiLCJQYXJzZXIiLCJwYXJzZUNzcyIsInAiLCJjb25maWciLCJzaW5nbGVBdFJ1bGUiLCJhdFJ1bGVUeXBlIiwibWVkaWFUZXh0Iiwic3RhdGUiLCJzZWxlY3RvcnMiLCJsZW5ndGgiLCJyZW1vdmVTZWxlY3RvciIsInNlbGVjdG9yc0FkZCIsInRvUmVtb3ZlIiwiZmlsdGVyIiwiciIsImdldFJ1bGUiLCJyZW1vdmUiLCJnZXRTZWxlY3RlZCIsInNldENvbnRlbnQiLCJnZXRDb21wb25lbnRIdG1sIiwiZ2V0Q29kZSIsInJlc3VsdCIsImNvbXBvbmVudEVsIiwiY2xlYXJEYXRhIiwiY2xhc3NMaXN0IiwiaHRtbCIsInRvSFRNTCIsImlubmVySFRNTCIsIm91dGVySFRNTCIsImFkZCIsImpzIiwiZWRpdEpzIiwiZ2V0U2NyaXB0U3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/vendor/Onix/js/codeEditor/code-editor/index.js\n");

/***/ }),

/***/ "./resources/vendor/Onix/js/codeEditor/commands.js":
/*!*********************************************************!*\
  !*** ./resources/vendor/Onix/js/codeEditor/commands.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _code_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./code-editor */ \"./resources/vendor/Onix/js/codeEditor/code-editor/index.js\");\n/* harmony import */ var _consts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./consts */ \"./resources/vendor/Onix/js/codeEditor/consts.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function (editor, opts) {\n  var cm = editor.Commands;\n  var codeEditor = null;\n  cm.add(_consts__WEBPACK_IMPORTED_MODULE_1__.openCodeStr, {\n    run: function run(editor) {\n      !codeEditor && (codeEditor = new _code_editor__WEBPACK_IMPORTED_MODULE_0__.CodeEditor(editor, opts)) && codeEditor.buildCodePanel();\n      codeEditor.showCodePanel();\n    },\n    stop: function stop(editor) {\n      codeEditor && codeEditor.hideCodePanel();\n    }\n  });\n  cm.add(_consts__WEBPACK_IMPORTED_MODULE_1__.getObject, function (editor, sender) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return new _code_editor__WEBPACK_IMPORTED_MODULE_0__.CodeEditor(editor, _objectSpread(_objectSpread({}, options), opts));\n  });\n  cm.add(_consts__WEBPACK_IMPORTED_MODULE_1__.getConstuctor, function () {\n    return _code_editor__WEBPACK_IMPORTED_MODULE_0__.CodeEditor;\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvdmVuZG9yL09uaXgvanMvY29kZUVkaXRvci9jb21tYW5kcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBMkM7QUFDc0I7QUFFakUsaUVBQWUsVUFBQ0ksTUFBTSxFQUFFQyxJQUFJLEVBQUs7RUFDN0IsSUFBTUMsRUFBRSxHQUFHRixNQUFNLENBQUNHLFFBQVE7RUFDMUIsSUFBSUMsVUFBVSxHQUFHLElBQUk7RUFFckJGLEVBQUUsQ0FBQ0csR0FBRyxDQUFDUixnREFBVyxFQUFFO0lBQ2hCUyxHQUFHLEVBQUUsYUFBQU4sTUFBTSxFQUFJO01BQ1gsQ0FBQ0ksVUFBVSxLQUFLQSxVQUFVLEdBQUcsSUFBSVIsb0RBQVUsQ0FBQ0ksTUFBTSxFQUFFQyxJQUFJLENBQUMsQ0FBQyxJQUFJRyxVQUFVLENBQUNHLGNBQWMsRUFBRTtNQUN6RkgsVUFBVSxDQUFDSSxhQUFhLEVBQUU7SUFDOUIsQ0FBQztJQUNEQyxJQUFJLEVBQUUsY0FBQVQsTUFBTSxFQUFJO01BQ1pJLFVBQVUsSUFBSUEsVUFBVSxDQUFDTSxhQUFhLEVBQUU7SUFDNUM7RUFDSixDQUFDLENBQUM7RUFFRlIsRUFBRSxDQUFDRyxHQUFHLENBQUNQLDhDQUFTLEVBQUUsVUFBQ0UsTUFBTSxFQUFFVyxNQUFNLEVBQW1CO0lBQUEsSUFBakJDLE9BQU8sdUVBQUcsQ0FBQyxDQUFDO0lBQzNDLE9BQU8sSUFBSWhCLG9EQUFVLENBQUNJLE1BQU0sa0NBQU9ZLE9BQU8sR0FBS1gsSUFBSSxFQUFHO0VBQzFELENBQUMsQ0FBQztFQUVGQyxFQUFFLENBQUNHLEdBQUcsQ0FBQ04sa0RBQWEsRUFBRSxZQUFNO0lBQ3hCLE9BQU9ILG9EQUFVO0VBQ3JCLENBQUMsQ0FBQztBQUNOLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdmVuZG9yL09uaXgvanMvY29kZUVkaXRvci9jb21tYW5kcy5qcz85YjM5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvZGVFZGl0b3IgfSBmcm9tICcuL2NvZGUtZWRpdG9yJztcclxuaW1wb3J0IHsgb3BlbkNvZGVTdHIsIGdldE9iamVjdCwgZ2V0Q29uc3R1Y3RvciB9IGZyb20gJy4vY29uc3RzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IChlZGl0b3IsIG9wdHMpID0+IHtcclxuICAgIGNvbnN0IGNtID0gZWRpdG9yLkNvbW1hbmRzO1xyXG4gICAgbGV0IGNvZGVFZGl0b3IgPSBudWxsO1xyXG5cclxuICAgIGNtLmFkZChvcGVuQ29kZVN0ciwge1xyXG4gICAgICAgIHJ1bjogZWRpdG9yID0+IHtcclxuICAgICAgICAgICAgIWNvZGVFZGl0b3IgJiYgKGNvZGVFZGl0b3IgPSBuZXcgQ29kZUVkaXRvcihlZGl0b3IsIG9wdHMpKSAmJiBjb2RlRWRpdG9yLmJ1aWxkQ29kZVBhbmVsKCk7XHJcbiAgICAgICAgICAgIGNvZGVFZGl0b3Iuc2hvd0NvZGVQYW5lbCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RvcDogZWRpdG9yID0+IHtcclxuICAgICAgICAgICAgY29kZUVkaXRvciAmJiBjb2RlRWRpdG9yLmhpZGVDb2RlUGFuZWwoKTtcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgY20uYWRkKGdldE9iamVjdCwgKGVkaXRvciwgc2VuZGVyLCBvcHRpb25zID0ge30pID0+IHtcclxuICAgICAgICByZXR1cm4gbmV3IENvZGVFZGl0b3IoZWRpdG9yLCB7IC4uLm9wdGlvbnMsIC4uLm9wdHMgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjbS5hZGQoZ2V0Q29uc3R1Y3RvciwgKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBDb2RlRWRpdG9yO1xyXG4gICAgfSk7XHJcbn0iXSwibmFtZXMiOlsiQ29kZUVkaXRvciIsIm9wZW5Db2RlU3RyIiwiZ2V0T2JqZWN0IiwiZ2V0Q29uc3R1Y3RvciIsImVkaXRvciIsIm9wdHMiLCJjbSIsIkNvbW1hbmRzIiwiY29kZUVkaXRvciIsImFkZCIsInJ1biIsImJ1aWxkQ29kZVBhbmVsIiwic2hvd0NvZGVQYW5lbCIsInN0b3AiLCJoaWRlQ29kZVBhbmVsIiwic2VuZGVyIiwib3B0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/vendor/Onix/js/codeEditor/commands.js\n");

/***/ }),

/***/ "./resources/vendor/Onix/js/codeEditor/consts.js":
/*!*******************************************************!*\
  !*** ./resources/vendor/Onix/js/codeEditor/consts.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getConstuctor\": () => (/* binding */ getConstuctor),\n/* harmony export */   \"getObject\": () => (/* binding */ getObject),\n/* harmony export */   \"openCodeStr\": () => (/* binding */ openCodeStr)\n/* harmony export */ });\nvar openCodeStr = 'open-code',\n  getObject = 'code-editor-object',\n  getConstuctor = 'code-editor-constructor';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvdmVuZG9yL09uaXgvanMvY29kZUVkaXRvci9jb25zdHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQU8sSUFDSEEsV0FBVyxHQUFHLFdBQVc7RUFDekJDLFNBQVMsR0FBRyxvQkFBb0I7RUFDaENDLGFBQWEsR0FBRyx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdmVuZG9yL09uaXgvanMvY29kZUVkaXRvci9jb25zdHMuanM/ZmM0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3RcclxuICAgIG9wZW5Db2RlU3RyID0gJ29wZW4tY29kZScsXHJcbiAgICBnZXRPYmplY3QgPSAnY29kZS1lZGl0b3Itb2JqZWN0JyxcclxuICAgIGdldENvbnN0dWN0b3IgPSAnY29kZS1lZGl0b3ItY29uc3RydWN0b3InOyJdLCJuYW1lcyI6WyJvcGVuQ29kZVN0ciIsImdldE9iamVjdCIsImdldENvbnN0dWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/vendor/Onix/js/codeEditor/consts.js\n");

/***/ }),

/***/ "./resources/vendor/Onix/js/codeEditor/grapeCodeEditor.js":
/*!****************************************************************!*\
  !*** ./resources/vendor/Onix/js/codeEditor/grapeCodeEditor.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _commands__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commands */ \"./resources/vendor/Onix/js/codeEditor/commands.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nwindow.grapesjs.plugins.add('code-editor', function (editor) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var options = _objectSpread(_objectSpread({}, {\n    //Panel to append the code editor\n    panelId: 'views-container',\n    //Append to element instead of views-container\n    appendTo: '',\n    //State when open\n    openState: {\n      cv: '65%',\n      pn: '35%'\n    },\n    //State when closed\n    closedState: {\n      cv: '85%',\n      pn: '15%'\n    },\n    //Allow editing of javascript, set allowScripts to true for this to work\n    editJs: false,\n    //Remove component data eg data-gjs-type=\"...\"\n    clearData: false,\n    //Code viewer options\n    codeViewOptions: {},\n    //Used to remove css from the Selector Manager\n    cleanCssBtn: true,\n    //Save HTML button text\n    htmlBtnText: 'Apply',\n    //Save CSS button text\n    cssBtnText: 'Apply',\n    //Clean CSS button text\n    cleanCssBtnText: 'Delete'\n  }), opts);\n\n  // Load commands\n  (0,_commands__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(editor, options);\n});\n\n// export default (editor, opts = {}) => {\n//     const options = {\n//         ...{\n//             //Panel to append the code editor\n//             panelId: 'views-container',\n//             //Append to element instead of views-container\n//             appendTo: '',\n//             //State when open\n//             openState: {\n//                 cv: '65%',\n//                 pn: '35%'\n//             },\n//             //State when closed\n//             closedState: {\n//                 cv: '85%',\n//                 pn: '15%'\n//             },\n//             //Allow editing of javascript, set allowScripts to true for this to work\n//             editJs: false,\n//             //Remove component data eg data-gjs-type=\"...\"\n//             clearData: false,\n//             //Code viewer options\n//             codeViewOptions: {},\n//             //Used to remove css from the Selector Manager\n//             cleanCssBtn: true,\n//             //Save HTML button text\n//             htmlBtnText: 'Apply',\n//             //Save CSS button text\n//             cssBtnText: 'Apply',\n//             //Clean CSS button text\n//             cleanCssBtnText: 'Delete'\n//         },\n//         ...opts\n//     };\n\n//     // Load commands\n//     commands(editor, options);\n// };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvdmVuZG9yL09uaXgvanMvY29kZUVkaXRvci9ncmFwZUNvZGVFZGl0b3IuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBa0M7QUFFbENDLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDQyxPQUFPLENBQUNDLEdBQUcsQ0FBQyxhQUFhLEVBQUUsVUFBQ0MsTUFBTSxFQUFnQjtFQUFBLElBQWRDLElBQUksdUVBQUcsQ0FBQyxDQUFDO0VBQ3pELElBQU1DLE9BQU8sbUNBQ047SUFDQztJQUNBQyxPQUFPLEVBQUUsaUJBQWlCO0lBQzFCO0lBQ0FDLFFBQVEsRUFBRSxFQUFFO0lBQ1o7SUFDQUMsU0FBUyxFQUFFO01BQ1BDLEVBQUUsRUFBRSxLQUFLO01BQ1RDLEVBQUUsRUFBRTtJQUNSLENBQUM7SUFDRDtJQUNBQyxXQUFXLEVBQUU7TUFDVEYsRUFBRSxFQUFFLEtBQUs7TUFDVEMsRUFBRSxFQUFFO0lBQ1IsQ0FBQztJQUNEO0lBQ0FFLE1BQU0sRUFBRSxLQUFLO0lBQ2I7SUFDQUMsU0FBUyxFQUFFLEtBQUs7SUFDaEI7SUFDQUMsZUFBZSxFQUFFLENBQUMsQ0FBQztJQUNuQjtJQUNBQyxXQUFXLEVBQUUsSUFBSTtJQUNqQjtJQUNBQyxXQUFXLEVBQUUsT0FBTztJQUNwQjtJQUNBQyxVQUFVLEVBQUUsT0FBTztJQUNuQjtJQUNBQyxlQUFlLEVBQUU7RUFDckIsQ0FBQyxHQUNFZCxJQUFJLENBQ1Y7O0VBRUQ7RUFDQU4scURBQVEsQ0FBQ0ssTUFBTSxFQUFFRSxPQUFPLENBQUM7QUFDN0IsQ0FBQyxDQUFDOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy92ZW5kb3IvT25peC9qcy9jb2RlRWRpdG9yL2dyYXBlQ29kZUVkaXRvci5qcz82MjkyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjb21tYW5kcyBmcm9tICcuL2NvbW1hbmRzJztcclxuXHJcbndpbmRvdy5ncmFwZXNqcy5wbHVnaW5zLmFkZCgnY29kZS1lZGl0b3InLCAoZWRpdG9yLCBvcHRzID0ge30pID0+IHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgLi4ue1xyXG4gICAgICAgICAgICAvL1BhbmVsIHRvIGFwcGVuZCB0aGUgY29kZSBlZGl0b3JcclxuICAgICAgICAgICAgcGFuZWxJZDogJ3ZpZXdzLWNvbnRhaW5lcicsXHJcbiAgICAgICAgICAgIC8vQXBwZW5kIHRvIGVsZW1lbnQgaW5zdGVhZCBvZiB2aWV3cy1jb250YWluZXJcclxuICAgICAgICAgICAgYXBwZW5kVG86ICcnLFxyXG4gICAgICAgICAgICAvL1N0YXRlIHdoZW4gb3BlblxyXG4gICAgICAgICAgICBvcGVuU3RhdGU6IHtcclxuICAgICAgICAgICAgICAgIGN2OiAnNjUlJyxcclxuICAgICAgICAgICAgICAgIHBuOiAnMzUlJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvL1N0YXRlIHdoZW4gY2xvc2VkXHJcbiAgICAgICAgICAgIGNsb3NlZFN0YXRlOiB7XHJcbiAgICAgICAgICAgICAgICBjdjogJzg1JScsXHJcbiAgICAgICAgICAgICAgICBwbjogJzE1JSdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy9BbGxvdyBlZGl0aW5nIG9mIGphdmFzY3JpcHQsIHNldCBhbGxvd1NjcmlwdHMgdG8gdHJ1ZSBmb3IgdGhpcyB0byB3b3JrXHJcbiAgICAgICAgICAgIGVkaXRKczogZmFsc2UsXHJcbiAgICAgICAgICAgIC8vUmVtb3ZlIGNvbXBvbmVudCBkYXRhIGVnIGRhdGEtZ2pzLXR5cGU9XCIuLi5cIlxyXG4gICAgICAgICAgICBjbGVhckRhdGE6IGZhbHNlLFxyXG4gICAgICAgICAgICAvL0NvZGUgdmlld2VyIG9wdGlvbnNcclxuICAgICAgICAgICAgY29kZVZpZXdPcHRpb25zOiB7fSxcclxuICAgICAgICAgICAgLy9Vc2VkIHRvIHJlbW92ZSBjc3MgZnJvbSB0aGUgU2VsZWN0b3IgTWFuYWdlclxyXG4gICAgICAgICAgICBjbGVhbkNzc0J0bjogdHJ1ZSxcclxuICAgICAgICAgICAgLy9TYXZlIEhUTUwgYnV0dG9uIHRleHRcclxuICAgICAgICAgICAgaHRtbEJ0blRleHQ6ICdBcHBseScsXHJcbiAgICAgICAgICAgIC8vU2F2ZSBDU1MgYnV0dG9uIHRleHRcclxuICAgICAgICAgICAgY3NzQnRuVGV4dDogJ0FwcGx5JyxcclxuICAgICAgICAgICAgLy9DbGVhbiBDU1MgYnV0dG9uIHRleHRcclxuICAgICAgICAgICAgY2xlYW5Dc3NCdG5UZXh0OiAnRGVsZXRlJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLi4ub3B0c1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBMb2FkIGNvbW1hbmRzXHJcbiAgICBjb21tYW5kcyhlZGl0b3IsIG9wdGlvbnMpO1xyXG59KTtcclxuXHJcbi8vIGV4cG9ydCBkZWZhdWx0IChlZGl0b3IsIG9wdHMgPSB7fSkgPT4ge1xyXG4vLyAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuLy8gICAgICAgICAuLi57XHJcbi8vICAgICAgICAgICAgIC8vUGFuZWwgdG8gYXBwZW5kIHRoZSBjb2RlIGVkaXRvclxyXG4vLyAgICAgICAgICAgICBwYW5lbElkOiAndmlld3MtY29udGFpbmVyJyxcclxuLy8gICAgICAgICAgICAgLy9BcHBlbmQgdG8gZWxlbWVudCBpbnN0ZWFkIG9mIHZpZXdzLWNvbnRhaW5lclxyXG4vLyAgICAgICAgICAgICBhcHBlbmRUbzogJycsXHJcbi8vICAgICAgICAgICAgIC8vU3RhdGUgd2hlbiBvcGVuXHJcbi8vICAgICAgICAgICAgIG9wZW5TdGF0ZToge1xyXG4vLyAgICAgICAgICAgICAgICAgY3Y6ICc2NSUnLFxyXG4vLyAgICAgICAgICAgICAgICAgcG46ICczNSUnXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICAgIC8vU3RhdGUgd2hlbiBjbG9zZWRcclxuLy8gICAgICAgICAgICAgY2xvc2VkU3RhdGU6IHtcclxuLy8gICAgICAgICAgICAgICAgIGN2OiAnODUlJyxcclxuLy8gICAgICAgICAgICAgICAgIHBuOiAnMTUlJ1xyXG4vLyAgICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgICAgICAvL0FsbG93IGVkaXRpbmcgb2YgamF2YXNjcmlwdCwgc2V0IGFsbG93U2NyaXB0cyB0byB0cnVlIGZvciB0aGlzIHRvIHdvcmtcclxuLy8gICAgICAgICAgICAgZWRpdEpzOiBmYWxzZSxcclxuLy8gICAgICAgICAgICAgLy9SZW1vdmUgY29tcG9uZW50IGRhdGEgZWcgZGF0YS1nanMtdHlwZT1cIi4uLlwiXHJcbi8vICAgICAgICAgICAgIGNsZWFyRGF0YTogZmFsc2UsXHJcbi8vICAgICAgICAgICAgIC8vQ29kZSB2aWV3ZXIgb3B0aW9uc1xyXG4vLyAgICAgICAgICAgICBjb2RlVmlld09wdGlvbnM6IHt9LFxyXG4vLyAgICAgICAgICAgICAvL1VzZWQgdG8gcmVtb3ZlIGNzcyBmcm9tIHRoZSBTZWxlY3RvciBNYW5hZ2VyXHJcbi8vICAgICAgICAgICAgIGNsZWFuQ3NzQnRuOiB0cnVlLFxyXG4vLyAgICAgICAgICAgICAvL1NhdmUgSFRNTCBidXR0b24gdGV4dFxyXG4vLyAgICAgICAgICAgICBodG1sQnRuVGV4dDogJ0FwcGx5JyxcclxuLy8gICAgICAgICAgICAgLy9TYXZlIENTUyBidXR0b24gdGV4dFxyXG4vLyAgICAgICAgICAgICBjc3NCdG5UZXh0OiAnQXBwbHknLFxyXG4vLyAgICAgICAgICAgICAvL0NsZWFuIENTUyBidXR0b24gdGV4dFxyXG4vLyAgICAgICAgICAgICBjbGVhbkNzc0J0blRleHQ6ICdEZWxldGUnXHJcbi8vICAgICAgICAgfSxcclxuLy8gICAgICAgICAuLi5vcHRzXHJcbi8vICAgICB9O1xyXG5cclxuLy8gICAgIC8vIExvYWQgY29tbWFuZHNcclxuLy8gICAgIGNvbW1hbmRzKGVkaXRvciwgb3B0aW9ucyk7XHJcbi8vIH07XHJcbiJdLCJuYW1lcyI6WyJjb21tYW5kcyIsIndpbmRvdyIsImdyYXBlc2pzIiwicGx1Z2lucyIsImFkZCIsImVkaXRvciIsIm9wdHMiLCJvcHRpb25zIiwicGFuZWxJZCIsImFwcGVuZFRvIiwib3BlblN0YXRlIiwiY3YiLCJwbiIsImNsb3NlZFN0YXRlIiwiZWRpdEpzIiwiY2xlYXJEYXRhIiwiY29kZVZpZXdPcHRpb25zIiwiY2xlYW5Dc3NCdG4iLCJodG1sQnRuVGV4dCIsImNzc0J0blRleHQiLCJjbGVhbkNzc0J0blRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/vendor/Onix/js/codeEditor/grapeCodeEditor.js\n");

/***/ }),

/***/ "./node_modules/split.js/dist/split.es.js":
/*!************************************************!*\
  !*** ./node_modules/split.js/dist/split.es.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// The programming goals of Split.js are to deliver readable, understandable and\n// maintainable code, while at the same time manually optimizing for tiny minified file size,\n// browser compatibility without additional requirements\n// and very few assumptions about the user's page layout.\nvar global = typeof window !== 'undefined' ? window : null;\nvar ssr = global === null;\nvar document = !ssr ? global.document : undefined;\n\n// Save a couple long function names that are used frequently.\n// This optimization saves around 400 bytes.\nvar addEventListener = 'addEventListener';\nvar removeEventListener = 'removeEventListener';\nvar getBoundingClientRect = 'getBoundingClientRect';\nvar gutterStartDragging = '_a';\nvar aGutterSize = '_b';\nvar bGutterSize = '_c';\nvar HORIZONTAL = 'horizontal';\nvar NOOP = function () { return false; };\n\n// Helper function determines which prefixes of CSS calc we need.\n// We only need to do this once on startup, when this anonymous function is called.\n//\n// Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\n// http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\nvar calc = ssr\n    ? 'calc'\n    : ((['', '-webkit-', '-moz-', '-o-']\n          .filter(function (prefix) {\n              var el = document.createElement('div');\n              el.style.cssText = \"width:\" + prefix + \"calc(9px)\";\n\n              return !!el.style.length\n          })\n          .shift()) + \"calc\");\n\n// Helper function checks if its argument is a string-like type\nvar isString = function (v) { return typeof v === 'string' || v instanceof String; };\n\n// Helper function allows elements and string selectors to be used\n// interchangeably. In either case an element is returned. This allows us to\n// do `Split([elem1, elem2])` as well as `Split(['#id1', '#id2'])`.\nvar elementOrSelector = function (el) {\n    if (isString(el)) {\n        var ele = document.querySelector(el);\n        if (!ele) {\n            throw new Error((\"Selector \" + el + \" did not match a DOM element\"))\n        }\n        return ele\n    }\n\n    return el\n};\n\n// Helper function gets a property from the properties object, with a default fallback\nvar getOption = function (options, propName, def) {\n    var value = options[propName];\n    if (value !== undefined) {\n        return value\n    }\n    return def\n};\n\nvar getGutterSize = function (gutterSize, isFirst, isLast, gutterAlign) {\n    if (isFirst) {\n        if (gutterAlign === 'end') {\n            return 0\n        }\n        if (gutterAlign === 'center') {\n            return gutterSize / 2\n        }\n    } else if (isLast) {\n        if (gutterAlign === 'start') {\n            return 0\n        }\n        if (gutterAlign === 'center') {\n            return gutterSize / 2\n        }\n    }\n\n    return gutterSize\n};\n\n// Default options\nvar defaultGutterFn = function (i, gutterDirection) {\n    var gut = document.createElement('div');\n    gut.className = \"gutter gutter-\" + gutterDirection;\n    return gut\n};\n\nvar defaultElementStyleFn = function (dim, size, gutSize) {\n    var style = {};\n\n    if (!isString(size)) {\n        style[dim] = calc + \"(\" + size + \"% - \" + gutSize + \"px)\";\n    } else {\n        style[dim] = size;\n    }\n\n    return style\n};\n\nvar defaultGutterStyleFn = function (dim, gutSize) {\n    var obj;\n\n    return (( obj = {}, obj[dim] = (gutSize + \"px\"), obj ));\n};\n\n// The main function to initialize a split. Split.js thinks about each pair\n// of elements as an independant pair. Dragging the gutter between two elements\n// only changes the dimensions of elements in that pair. This is key to understanding\n// how the following functions operate, since each function is bound to a pair.\n//\n// A pair object is shaped like this:\n//\n// {\n//     a: DOM element,\n//     b: DOM element,\n//     aMin: Number,\n//     bMin: Number,\n//     dragging: Boolean,\n//     parent: DOM element,\n//     direction: 'horizontal' | 'vertical'\n// }\n//\n// The basic sequence:\n//\n// 1. Set defaults to something sane. `options` doesn't have to be passed at all.\n// 2. Initialize a bunch of strings based on the direction we're splitting.\n//    A lot of the behavior in the rest of the library is paramatized down to\n//    rely on CSS strings and classes.\n// 3. Define the dragging helper functions, and a few helpers to go with them.\n// 4. Loop through the elements while pairing them off. Every pair gets an\n//    `pair` object and a gutter.\n// 5. Actually size the pair elements, insert gutters and attach event listeners.\nvar Split = function (idsOption, options) {\n    if ( options === void 0 ) options = {};\n\n    if (ssr) { return {} }\n\n    var ids = idsOption;\n    var dimension;\n    var clientAxis;\n    var position;\n    var positionEnd;\n    var clientSize;\n    var elements;\n\n    // Allow HTMLCollection to be used as an argument when supported\n    if (Array.from) {\n        ids = Array.from(ids);\n    }\n\n    // All DOM elements in the split should have a common parent. We can grab\n    // the first elements parent and hope users read the docs because the\n    // behavior will be whacky otherwise.\n    var firstElement = elementOrSelector(ids[0]);\n    var parent = firstElement.parentNode;\n    var parentStyle = getComputedStyle ? getComputedStyle(parent) : null;\n    var parentFlexDirection = parentStyle ? parentStyle.flexDirection : null;\n\n    // Set default options.sizes to equal percentages of the parent element.\n    var sizes = getOption(options, 'sizes') || ids.map(function () { return 100 / ids.length; });\n\n    // Standardize minSize and maxSize to an array if it isn't already.\n    // This allows minSize and maxSize to be passed as a number.\n    var minSize = getOption(options, 'minSize', 100);\n    var minSizes = Array.isArray(minSize) ? minSize : ids.map(function () { return minSize; });\n    var maxSize = getOption(options, 'maxSize', Infinity);\n    var maxSizes = Array.isArray(maxSize) ? maxSize : ids.map(function () { return maxSize; });\n\n    // Get other options\n    var expandToMin = getOption(options, 'expandToMin', false);\n    var gutterSize = getOption(options, 'gutterSize', 10);\n    var gutterAlign = getOption(options, 'gutterAlign', 'center');\n    var snapOffset = getOption(options, 'snapOffset', 30);\n    var snapOffsets = Array.isArray(snapOffset) ? snapOffset : ids.map(function () { return snapOffset; });\n    var dragInterval = getOption(options, 'dragInterval', 1);\n    var direction = getOption(options, 'direction', HORIZONTAL);\n    var cursor = getOption(\n        options,\n        'cursor',\n        direction === HORIZONTAL ? 'col-resize' : 'row-resize'\n    );\n    var gutter = getOption(options, 'gutter', defaultGutterFn);\n    var elementStyle = getOption(\n        options,\n        'elementStyle',\n        defaultElementStyleFn\n    );\n    var gutterStyle = getOption(options, 'gutterStyle', defaultGutterStyleFn);\n\n    // 2. Initialize a bunch of strings based on the direction we're splitting.\n    // A lot of the behavior in the rest of the library is paramatized down to\n    // rely on CSS strings and classes.\n    if (direction === HORIZONTAL) {\n        dimension = 'width';\n        clientAxis = 'clientX';\n        position = 'left';\n        positionEnd = 'right';\n        clientSize = 'clientWidth';\n    } else if (direction === 'vertical') {\n        dimension = 'height';\n        clientAxis = 'clientY';\n        position = 'top';\n        positionEnd = 'bottom';\n        clientSize = 'clientHeight';\n    }\n\n    // 3. Define the dragging helper functions, and a few helpers to go with them.\n    // Each helper is bound to a pair object that contains its metadata. This\n    // also makes it easy to store references to listeners that that will be\n    // added and removed.\n    //\n    // Even though there are no other functions contained in them, aliasing\n    // this to self saves 50 bytes or so since it's used so frequently.\n    //\n    // The pair object saves metadata like dragging state, position and\n    // event listener references.\n\n    function setElementSize(el, size, gutSize, i) {\n        // Split.js allows setting sizes via numbers (ideally), or if you must,\n        // by string, like '300px'. This is less than ideal, because it breaks\n        // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\n        // make sure you calculate the gutter size by hand.\n        var style = elementStyle(dimension, size, gutSize, i);\n\n        Object.keys(style).forEach(function (prop) {\n            // eslint-disable-next-line no-param-reassign\n            el.style[prop] = style[prop];\n        });\n    }\n\n    function setGutterSize(gutterElement, gutSize, i) {\n        var style = gutterStyle(dimension, gutSize, i);\n\n        Object.keys(style).forEach(function (prop) {\n            // eslint-disable-next-line no-param-reassign\n            gutterElement.style[prop] = style[prop];\n        });\n    }\n\n    function getSizes() {\n        return elements.map(function (element) { return element.size; })\n    }\n\n    // Supports touch events, but not multitouch, so only the first\n    // finger `touches[0]` is counted.\n    function getMousePosition(e) {\n        if ('touches' in e) { return e.touches[0][clientAxis] }\n        return e[clientAxis]\n    }\n\n    // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\n    // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\n    // which allows the viewport to be resized without additional logic.\n    // Element a's size is the same as offset. b's size is total size - a size.\n    // Both sizes are calculated from the initial parent percentage,\n    // then the gutter size is subtracted.\n    function adjust(offset) {\n        var a = elements[this.a];\n        var b = elements[this.b];\n        var percentage = a.size + b.size;\n\n        a.size = (offset / this.size) * percentage;\n        b.size = percentage - (offset / this.size) * percentage;\n\n        setElementSize(a.element, a.size, this[aGutterSize], a.i);\n        setElementSize(b.element, b.size, this[bGutterSize], b.i);\n    }\n\n    // drag, where all the magic happens. The logic is really quite simple:\n    //\n    // 1. Ignore if the pair is not dragging.\n    // 2. Get the offset of the event.\n    // 3. Snap offset to min if within snappable range (within min + snapOffset).\n    // 4. Actually adjust each element in the pair to offset.\n    //\n    // ---------------------------------------------------------------------\n    // |    | <- a.minSize               ||              b.minSize -> |    |\n    // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\n    // |    |  |                         ||                        |  |    |\n    // |    |  |                         ||                        |  |    |\n    // ---------------------------------------------------------------------\n    // | <- this.start                                        this.size -> |\n    function drag(e) {\n        var offset;\n        var a = elements[this.a];\n        var b = elements[this.b];\n\n        if (!this.dragging) { return }\n\n        // Get the offset of the event from the first side of the\n        // pair `this.start`. Then offset by the initial position of the\n        // mouse compared to the gutter size.\n        offset =\n            getMousePosition(e) -\n            this.start +\n            (this[aGutterSize] - this.dragOffset);\n\n        if (dragInterval > 1) {\n            offset = Math.round(offset / dragInterval) * dragInterval;\n        }\n\n        // If within snapOffset of min or max, set offset to min or max.\n        // snapOffset buffers a.minSize and b.minSize, so logic is opposite for both.\n        // Include the appropriate gutter sizes to prevent overflows.\n        if (offset <= a.minSize + a.snapOffset + this[aGutterSize]) {\n            offset = a.minSize + this[aGutterSize];\n        } else if (\n            offset >=\n            this.size - (b.minSize + b.snapOffset + this[bGutterSize])\n        ) {\n            offset = this.size - (b.minSize + this[bGutterSize]);\n        }\n\n        if (offset >= a.maxSize - a.snapOffset + this[aGutterSize]) {\n            offset = a.maxSize + this[aGutterSize];\n        } else if (\n            offset <=\n            this.size - (b.maxSize - b.snapOffset + this[bGutterSize])\n        ) {\n            offset = this.size - (b.maxSize + this[bGutterSize]);\n        }\n\n        // Actually adjust the size.\n        adjust.call(this, offset);\n\n        // Call the drag callback continously. Don't do anything too intensive\n        // in this callback.\n        getOption(options, 'onDrag', NOOP)(getSizes());\n    }\n\n    // Cache some important sizes when drag starts, so we don't have to do that\n    // continously:\n    //\n    // `size`: The total size of the pair. First + second + first gutter + second gutter.\n    // `start`: The leading side of the first element.\n    //\n    // ------------------------------------------------\n    // |      aGutterSize -> |||                      |\n    // |                     |||                      |\n    // |                     |||                      |\n    // |                     ||| <- bGutterSize       |\n    // ------------------------------------------------\n    // | <- start                             size -> |\n    function calculateSizes() {\n        // Figure out the parent size minus padding.\n        var a = elements[this.a].element;\n        var b = elements[this.b].element;\n\n        var aBounds = a[getBoundingClientRect]();\n        var bBounds = b[getBoundingClientRect]();\n\n        this.size =\n            aBounds[dimension] +\n            bBounds[dimension] +\n            this[aGutterSize] +\n            this[bGutterSize];\n        this.start = aBounds[position];\n        this.end = aBounds[positionEnd];\n    }\n\n    function innerSize(element) {\n        // Return nothing if getComputedStyle is not supported (< IE9)\n        // Or if parent element has no layout yet\n        if (!getComputedStyle) { return null }\n\n        var computedStyle = getComputedStyle(element);\n\n        if (!computedStyle) { return null }\n\n        var size = element[clientSize];\n\n        if (size === 0) { return null }\n\n        if (direction === HORIZONTAL) {\n            size -=\n                parseFloat(computedStyle.paddingLeft) +\n                parseFloat(computedStyle.paddingRight);\n        } else {\n            size -=\n                parseFloat(computedStyle.paddingTop) +\n                parseFloat(computedStyle.paddingBottom);\n        }\n\n        return size\n    }\n\n    // When specifying percentage sizes that are less than the computed\n    // size of the element minus the gutter, the lesser percentages must be increased\n    // (and decreased from the other elements) to make space for the pixels\n    // subtracted by the gutters.\n    function trimToMin(sizesToTrim) {\n        // Try to get inner size of parent element.\n        // If it's no supported, return original sizes.\n        var parentSize = innerSize(parent);\n        if (parentSize === null) {\n            return sizesToTrim\n        }\n\n        if (minSizes.reduce(function (a, b) { return a + b; }, 0) > parentSize) {\n            return sizesToTrim\n        }\n\n        // Keep track of the excess pixels, the amount of pixels over the desired percentage\n        // Also keep track of the elements with pixels to spare, to decrease after if needed\n        var excessPixels = 0;\n        var toSpare = [];\n\n        var pixelSizes = sizesToTrim.map(function (size, i) {\n            // Convert requested percentages to pixel sizes\n            var pixelSize = (parentSize * size) / 100;\n            var elementGutterSize = getGutterSize(\n                gutterSize,\n                i === 0,\n                i === sizesToTrim.length - 1,\n                gutterAlign\n            );\n            var elementMinSize = minSizes[i] + elementGutterSize;\n\n            // If element is too smal, increase excess pixels by the difference\n            // and mark that it has no pixels to spare\n            if (pixelSize < elementMinSize) {\n                excessPixels += elementMinSize - pixelSize;\n                toSpare.push(0);\n                return elementMinSize\n            }\n\n            // Otherwise, mark the pixels it has to spare and return it's original size\n            toSpare.push(pixelSize - elementMinSize);\n            return pixelSize\n        });\n\n        // If nothing was adjusted, return the original sizes\n        if (excessPixels === 0) {\n            return sizesToTrim\n        }\n\n        return pixelSizes.map(function (pixelSize, i) {\n            var newPixelSize = pixelSize;\n\n            // While there's still pixels to take, and there's enough pixels to spare,\n            // take as many as possible up to the total excess pixels\n            if (excessPixels > 0 && toSpare[i] - excessPixels > 0) {\n                var takenPixels = Math.min(\n                    excessPixels,\n                    toSpare[i] - excessPixels\n                );\n\n                // Subtract the amount taken for the next iteration\n                excessPixels -= takenPixels;\n                newPixelSize = pixelSize - takenPixels;\n            }\n\n            // Return the pixel size adjusted as a percentage\n            return (newPixelSize / parentSize) * 100\n        })\n    }\n\n    // stopDragging is very similar to startDragging in reverse.\n    function stopDragging() {\n        var self = this;\n        var a = elements[self.a].element;\n        var b = elements[self.b].element;\n\n        if (self.dragging) {\n            getOption(options, 'onDragEnd', NOOP)(getSizes());\n        }\n\n        self.dragging = false;\n\n        // Remove the stored event listeners. This is why we store them.\n        global[removeEventListener]('mouseup', self.stop);\n        global[removeEventListener]('touchend', self.stop);\n        global[removeEventListener]('touchcancel', self.stop);\n        global[removeEventListener]('mousemove', self.move);\n        global[removeEventListener]('touchmove', self.move);\n\n        // Clear bound function references\n        self.stop = null;\n        self.move = null;\n\n        a[removeEventListener]('selectstart', NOOP);\n        a[removeEventListener]('dragstart', NOOP);\n        b[removeEventListener]('selectstart', NOOP);\n        b[removeEventListener]('dragstart', NOOP);\n\n        a.style.userSelect = '';\n        a.style.webkitUserSelect = '';\n        a.style.MozUserSelect = '';\n        a.style.pointerEvents = '';\n\n        b.style.userSelect = '';\n        b.style.webkitUserSelect = '';\n        b.style.MozUserSelect = '';\n        b.style.pointerEvents = '';\n\n        self.gutter.style.cursor = '';\n        self.parent.style.cursor = '';\n        document.body.style.cursor = '';\n    }\n\n    // startDragging calls `calculateSizes` to store the inital size in the pair object.\n    // It also adds event listeners for mouse/touch events,\n    // and prevents selection while dragging so avoid the selecting text.\n    function startDragging(e) {\n        // Right-clicking can't start dragging.\n        if ('button' in e && e.button !== 0) {\n            return\n        }\n\n        // Alias frequently used variables to save space. 200 bytes.\n        var self = this;\n        var a = elements[self.a].element;\n        var b = elements[self.b].element;\n\n        // Call the onDragStart callback.\n        if (!self.dragging) {\n            getOption(options, 'onDragStart', NOOP)(getSizes());\n        }\n\n        // Don't actually drag the element. We emulate that in the drag function.\n        e.preventDefault();\n\n        // Set the dragging property of the pair object.\n        self.dragging = true;\n\n        // Create two event listeners bound to the same pair object and store\n        // them in the pair object.\n        self.move = drag.bind(self);\n        self.stop = stopDragging.bind(self);\n\n        // All the binding. `window` gets the stop events in case we drag out of the elements.\n        global[addEventListener]('mouseup', self.stop);\n        global[addEventListener]('touchend', self.stop);\n        global[addEventListener]('touchcancel', self.stop);\n        global[addEventListener]('mousemove', self.move);\n        global[addEventListener]('touchmove', self.move);\n\n        // Disable selection. Disable!\n        a[addEventListener]('selectstart', NOOP);\n        a[addEventListener]('dragstart', NOOP);\n        b[addEventListener]('selectstart', NOOP);\n        b[addEventListener]('dragstart', NOOP);\n\n        a.style.userSelect = 'none';\n        a.style.webkitUserSelect = 'none';\n        a.style.MozUserSelect = 'none';\n        a.style.pointerEvents = 'none';\n\n        b.style.userSelect = 'none';\n        b.style.webkitUserSelect = 'none';\n        b.style.MozUserSelect = 'none';\n        b.style.pointerEvents = 'none';\n\n        // Set the cursor at multiple levels\n        self.gutter.style.cursor = cursor;\n        self.parent.style.cursor = cursor;\n        document.body.style.cursor = cursor;\n\n        // Cache the initial sizes of the pair.\n        calculateSizes.call(self);\n\n        // Determine the position of the mouse compared to the gutter\n        self.dragOffset = getMousePosition(e) - self.end;\n    }\n\n    // adjust sizes to ensure percentage is within min size and gutter.\n    sizes = trimToMin(sizes);\n\n    // 5. Create pair and element objects. Each pair has an index reference to\n    // elements `a` and `b` of the pair (first and second elements).\n    // Loop through the elements while pairing them off. Every pair gets a\n    // `pair` object and a gutter.\n    //\n    // Basic logic:\n    //\n    // - Starting with the second element `i > 0`, create `pair` objects with\n    //   `a = i - 1` and `b = i`\n    // - Set gutter sizes based on the _pair_ being first/last. The first and last\n    //   pair have gutterSize / 2, since they only have one half gutter, and not two.\n    // - Create gutter elements and add event listeners.\n    // - Set the size of the elements, minus the gutter sizes.\n    //\n    // -----------------------------------------------------------------------\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\n    // |             |                     |                  |              |\n    // |           pair 0                pair 1             pair 2           |\n    // |             |                     |                  |              |\n    // -----------------------------------------------------------------------\n    var pairs = [];\n    elements = ids.map(function (id, i) {\n        // Create the element object.\n        var element = {\n            element: elementOrSelector(id),\n            size: sizes[i],\n            minSize: minSizes[i],\n            maxSize: maxSizes[i],\n            snapOffset: snapOffsets[i],\n            i: i,\n        };\n\n        var pair;\n\n        if (i > 0) {\n            // Create the pair object with its metadata.\n            pair = {\n                a: i - 1,\n                b: i,\n                dragging: false,\n                direction: direction,\n                parent: parent,\n            };\n\n            pair[aGutterSize] = getGutterSize(\n                gutterSize,\n                i - 1 === 0,\n                false,\n                gutterAlign\n            );\n            pair[bGutterSize] = getGutterSize(\n                gutterSize,\n                false,\n                i === ids.length - 1,\n                gutterAlign\n            );\n\n            // if the parent has a reverse flex-direction, switch the pair elements.\n            if (\n                parentFlexDirection === 'row-reverse' ||\n                parentFlexDirection === 'column-reverse'\n            ) {\n                var temp = pair.a;\n                pair.a = pair.b;\n                pair.b = temp;\n            }\n        }\n\n        // Determine the size of the current element. IE8 is supported by\n        // staticly assigning sizes without draggable gutters. Assigns a string\n        // to `size`.\n        //\n        // Create gutter elements for each pair.\n        if (i > 0) {\n            var gutterElement = gutter(i, direction, element.element);\n            setGutterSize(gutterElement, gutterSize, i);\n\n            // Save bound event listener for removal later\n            pair[gutterStartDragging] = startDragging.bind(pair);\n\n            // Attach bound event listener\n            gutterElement[addEventListener](\n                'mousedown',\n                pair[gutterStartDragging]\n            );\n            gutterElement[addEventListener](\n                'touchstart',\n                pair[gutterStartDragging]\n            );\n\n            parent.insertBefore(gutterElement, element.element);\n\n            pair.gutter = gutterElement;\n        }\n\n        setElementSize(\n            element.element,\n            element.size,\n            getGutterSize(\n                gutterSize,\n                i === 0,\n                i === ids.length - 1,\n                gutterAlign\n            ),\n            i\n        );\n\n        // After the first iteration, and we have a pair object, append it to the\n        // list of pairs.\n        if (i > 0) {\n            pairs.push(pair);\n        }\n\n        return element\n    });\n\n    function adjustToMin(element) {\n        var isLast = element.i === pairs.length;\n        var pair = isLast ? pairs[element.i - 1] : pairs[element.i];\n\n        calculateSizes.call(pair);\n\n        var size = isLast\n            ? pair.size - element.minSize - pair[bGutterSize]\n            : element.minSize + pair[aGutterSize];\n\n        adjust.call(pair, size);\n    }\n\n    elements.forEach(function (element) {\n        var computedSize = element.element[getBoundingClientRect]()[dimension];\n\n        if (computedSize < element.minSize) {\n            if (expandToMin) {\n                adjustToMin(element);\n            } else {\n                // eslint-disable-next-line no-param-reassign\n                element.minSize = computedSize;\n            }\n        }\n    });\n\n    function setSizes(newSizes) {\n        var trimmed = trimToMin(newSizes);\n        trimmed.forEach(function (newSize, i) {\n            if (i > 0) {\n                var pair = pairs[i - 1];\n\n                var a = elements[pair.a];\n                var b = elements[pair.b];\n\n                a.size = trimmed[i - 1];\n                b.size = newSize;\n\n                setElementSize(a.element, a.size, pair[aGutterSize], a.i);\n                setElementSize(b.element, b.size, pair[bGutterSize], b.i);\n            }\n        });\n    }\n\n    function destroy(preserveStyles, preserveGutter) {\n        pairs.forEach(function (pair) {\n            if (preserveGutter !== true) {\n                pair.parent.removeChild(pair.gutter);\n            } else {\n                pair.gutter[removeEventListener](\n                    'mousedown',\n                    pair[gutterStartDragging]\n                );\n                pair.gutter[removeEventListener](\n                    'touchstart',\n                    pair[gutterStartDragging]\n                );\n            }\n\n            if (preserveStyles !== true) {\n                var style = elementStyle(\n                    dimension,\n                    pair.a.size,\n                    pair[aGutterSize]\n                );\n\n                Object.keys(style).forEach(function (prop) {\n                    elements[pair.a].element.style[prop] = '';\n                    elements[pair.b].element.style[prop] = '';\n                });\n            }\n        });\n    }\n\n    return {\n        setSizes: setSizes,\n        getSizes: getSizes,\n        collapse: function collapse(i) {\n            adjustToMin(elements[i]);\n        },\n        destroy: destroy,\n        parent: parent,\n        pairs: pairs,\n    }\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Split);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3BsaXQuanMvZGlzdC9zcGxpdC5lcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUVBQXFFLDBCQUEwQjs7QUFFL0Y7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGlCQUFpQjtBQUM3RjtBQUNBLDRFQUE0RSxpQkFBaUI7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsb0JBQW9CO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsaURBQWlELHNCQUFzQjtBQUN2RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7O0FBRUEsOEJBQThCOztBQUU5Qjs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsZUFBZTtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxLQUFLLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3BsaXQuanMvZGlzdC9zcGxpdC5lcy5qcz8xZDAyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoZSBwcm9ncmFtbWluZyBnb2FscyBvZiBTcGxpdC5qcyBhcmUgdG8gZGVsaXZlciByZWFkYWJsZSwgdW5kZXJzdGFuZGFibGUgYW5kXG4vLyBtYWludGFpbmFibGUgY29kZSwgd2hpbGUgYXQgdGhlIHNhbWUgdGltZSBtYW51YWxseSBvcHRpbWl6aW5nIGZvciB0aW55IG1pbmlmaWVkIGZpbGUgc2l6ZSxcbi8vIGJyb3dzZXIgY29tcGF0aWJpbGl0eSB3aXRob3V0IGFkZGl0aW9uYWwgcmVxdWlyZW1lbnRzXG4vLyBhbmQgdmVyeSBmZXcgYXNzdW1wdGlvbnMgYWJvdXQgdGhlIHVzZXIncyBwYWdlIGxheW91dC5cbnZhciBnbG9iYWwgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IG51bGw7XG52YXIgc3NyID0gZ2xvYmFsID09PSBudWxsO1xudmFyIGRvY3VtZW50ID0gIXNzciA/IGdsb2JhbC5kb2N1bWVudCA6IHVuZGVmaW5lZDtcblxuLy8gU2F2ZSBhIGNvdXBsZSBsb25nIGZ1bmN0aW9uIG5hbWVzIHRoYXQgYXJlIHVzZWQgZnJlcXVlbnRseS5cbi8vIFRoaXMgb3B0aW1pemF0aW9uIHNhdmVzIGFyb3VuZCA0MDAgYnl0ZXMuXG52YXIgYWRkRXZlbnRMaXN0ZW5lciA9ICdhZGRFdmVudExpc3RlbmVyJztcbnZhciByZW1vdmVFdmVudExpc3RlbmVyID0gJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xudmFyIGdldEJvdW5kaW5nQ2xpZW50UmVjdCA9ICdnZXRCb3VuZGluZ0NsaWVudFJlY3QnO1xudmFyIGd1dHRlclN0YXJ0RHJhZ2dpbmcgPSAnX2EnO1xudmFyIGFHdXR0ZXJTaXplID0gJ19iJztcbnZhciBiR3V0dGVyU2l6ZSA9ICdfYyc7XG52YXIgSE9SSVpPTlRBTCA9ICdob3Jpem9udGFsJztcbnZhciBOT09QID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiBkZXRlcm1pbmVzIHdoaWNoIHByZWZpeGVzIG9mIENTUyBjYWxjIHdlIG5lZWQuXG4vLyBXZSBvbmx5IG5lZWQgdG8gZG8gdGhpcyBvbmNlIG9uIHN0YXJ0dXAsIHdoZW4gdGhpcyBhbm9ueW1vdXMgZnVuY3Rpb24gaXMgY2FsbGVkLlxuLy9cbi8vIFRlc3RzIC13ZWJraXQsIC1tb3ogYW5kIC1vIHByZWZpeGVzLiBNb2RpZmllZCBmcm9tIFN0YWNrT3ZlcmZsb3c6XG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2NjI1MTQwL2pzLWZlYXR1cmUtZGV0ZWN0aW9uLXRvLWRldGVjdC10aGUtdXNhZ2Utb2Ytd2Via2l0LWNhbGMtb3Zlci1jYWxjLzE2NjI1MTY3IzE2NjI1MTY3XG52YXIgY2FsYyA9IHNzclxuICAgID8gJ2NhbGMnXG4gICAgOiAoKFsnJywgJy13ZWJraXQtJywgJy1tb3otJywgJy1vLSddXG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgICAgICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICBlbC5zdHlsZS5jc3NUZXh0ID0gXCJ3aWR0aDpcIiArIHByZWZpeCArIFwiY2FsYyg5cHgpXCI7XG5cbiAgICAgICAgICAgICAgcmV0dXJuICEhZWwuc3R5bGUubGVuZ3RoXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuc2hpZnQoKSkgKyBcImNhbGNcIik7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiBjaGVja3MgaWYgaXRzIGFyZ3VtZW50IGlzIGEgc3RyaW5nLWxpa2UgdHlwZVxudmFyIGlzU3RyaW5nID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHR5cGVvZiB2ID09PSAnc3RyaW5nJyB8fCB2IGluc3RhbmNlb2YgU3RyaW5nOyB9O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gYWxsb3dzIGVsZW1lbnRzIGFuZCBzdHJpbmcgc2VsZWN0b3JzIHRvIGJlIHVzZWRcbi8vIGludGVyY2hhbmdlYWJseS4gSW4gZWl0aGVyIGNhc2UgYW4gZWxlbWVudCBpcyByZXR1cm5lZC4gVGhpcyBhbGxvd3MgdXMgdG9cbi8vIGRvIGBTcGxpdChbZWxlbTEsIGVsZW0yXSlgIGFzIHdlbGwgYXMgYFNwbGl0KFsnI2lkMScsICcjaWQyJ10pYC5cbnZhciBlbGVtZW50T3JTZWxlY3RvciA9IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChpc1N0cmluZyhlbCkpIHtcbiAgICAgICAgdmFyIGVsZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgICAgICBpZiAoIWVsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIlNlbGVjdG9yIFwiICsgZWwgKyBcIiBkaWQgbm90IG1hdGNoIGEgRE9NIGVsZW1lbnRcIikpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZVxuICAgIH1cblxuICAgIHJldHVybiBlbFxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIGdldHMgYSBwcm9wZXJ0eSBmcm9tIHRoZSBwcm9wZXJ0aWVzIG9iamVjdCwgd2l0aCBhIGRlZmF1bHQgZmFsbGJhY2tcbnZhciBnZXRPcHRpb24gPSBmdW5jdGlvbiAob3B0aW9ucywgcHJvcE5hbWUsIGRlZikge1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnNbcHJvcE5hbWVdO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgICByZXR1cm4gZGVmXG59O1xuXG52YXIgZ2V0R3V0dGVyU2l6ZSA9IGZ1bmN0aW9uIChndXR0ZXJTaXplLCBpc0ZpcnN0LCBpc0xhc3QsIGd1dHRlckFsaWduKSB7XG4gICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgaWYgKGd1dHRlckFsaWduID09PSAnZW5kJykge1xuICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3V0dGVyQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3V0dGVyU2l6ZSAvIDJcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNMYXN0KSB7XG4gICAgICAgIGlmIChndXR0ZXJBbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3V0dGVyQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3V0dGVyU2l6ZSAvIDJcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBndXR0ZXJTaXplXG59O1xuXG4vLyBEZWZhdWx0IG9wdGlvbnNcbnZhciBkZWZhdWx0R3V0dGVyRm4gPSBmdW5jdGlvbiAoaSwgZ3V0dGVyRGlyZWN0aW9uKSB7XG4gICAgdmFyIGd1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGd1dC5jbGFzc05hbWUgPSBcImd1dHRlciBndXR0ZXItXCIgKyBndXR0ZXJEaXJlY3Rpb247XG4gICAgcmV0dXJuIGd1dFxufTtcblxudmFyIGRlZmF1bHRFbGVtZW50U3R5bGVGbiA9IGZ1bmN0aW9uIChkaW0sIHNpemUsIGd1dFNpemUpIHtcbiAgICB2YXIgc3R5bGUgPSB7fTtcblxuICAgIGlmICghaXNTdHJpbmcoc2l6ZSkpIHtcbiAgICAgICAgc3R5bGVbZGltXSA9IGNhbGMgKyBcIihcIiArIHNpemUgKyBcIiUgLSBcIiArIGd1dFNpemUgKyBcInB4KVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlW2RpbV0gPSBzaXplO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZVxufTtcblxudmFyIGRlZmF1bHRHdXR0ZXJTdHlsZUZuID0gZnVuY3Rpb24gKGRpbSwgZ3V0U2l6ZSkge1xuICAgIHZhciBvYmo7XG5cbiAgICByZXR1cm4gKCggb2JqID0ge30sIG9ialtkaW1dID0gKGd1dFNpemUgKyBcInB4XCIpLCBvYmogKSk7XG59O1xuXG4vLyBUaGUgbWFpbiBmdW5jdGlvbiB0byBpbml0aWFsaXplIGEgc3BsaXQuIFNwbGl0LmpzIHRoaW5rcyBhYm91dCBlYWNoIHBhaXJcbi8vIG9mIGVsZW1lbnRzIGFzIGFuIGluZGVwZW5kYW50IHBhaXIuIERyYWdnaW5nIHRoZSBndXR0ZXIgYmV0d2VlbiB0d28gZWxlbWVudHNcbi8vIG9ubHkgY2hhbmdlcyB0aGUgZGltZW5zaW9ucyBvZiBlbGVtZW50cyBpbiB0aGF0IHBhaXIuIFRoaXMgaXMga2V5IHRvIHVuZGVyc3RhbmRpbmdcbi8vIGhvdyB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBvcGVyYXRlLCBzaW5jZSBlYWNoIGZ1bmN0aW9uIGlzIGJvdW5kIHRvIGEgcGFpci5cbi8vXG4vLyBBIHBhaXIgb2JqZWN0IGlzIHNoYXBlZCBsaWtlIHRoaXM6XG4vL1xuLy8ge1xuLy8gICAgIGE6IERPTSBlbGVtZW50LFxuLy8gICAgIGI6IERPTSBlbGVtZW50LFxuLy8gICAgIGFNaW46IE51bWJlcixcbi8vICAgICBiTWluOiBOdW1iZXIsXG4vLyAgICAgZHJhZ2dpbmc6IEJvb2xlYW4sXG4vLyAgICAgcGFyZW50OiBET00gZWxlbWVudCxcbi8vICAgICBkaXJlY3Rpb246ICdob3Jpem9udGFsJyB8ICd2ZXJ0aWNhbCdcbi8vIH1cbi8vXG4vLyBUaGUgYmFzaWMgc2VxdWVuY2U6XG4vL1xuLy8gMS4gU2V0IGRlZmF1bHRzIHRvIHNvbWV0aGluZyBzYW5lLiBgb3B0aW9uc2AgZG9lc24ndCBoYXZlIHRvIGJlIHBhc3NlZCBhdCBhbGwuXG4vLyAyLiBJbml0aWFsaXplIGEgYnVuY2ggb2Ygc3RyaW5ncyBiYXNlZCBvbiB0aGUgZGlyZWN0aW9uIHdlJ3JlIHNwbGl0dGluZy5cbi8vICAgIEEgbG90IG9mIHRoZSBiZWhhdmlvciBpbiB0aGUgcmVzdCBvZiB0aGUgbGlicmFyeSBpcyBwYXJhbWF0aXplZCBkb3duIHRvXG4vLyAgICByZWx5IG9uIENTUyBzdHJpbmdzIGFuZCBjbGFzc2VzLlxuLy8gMy4gRGVmaW5lIHRoZSBkcmFnZ2luZyBoZWxwZXIgZnVuY3Rpb25zLCBhbmQgYSBmZXcgaGVscGVycyB0byBnbyB3aXRoIHRoZW0uXG4vLyA0LiBMb29wIHRocm91Z2ggdGhlIGVsZW1lbnRzIHdoaWxlIHBhaXJpbmcgdGhlbSBvZmYuIEV2ZXJ5IHBhaXIgZ2V0cyBhblxuLy8gICAgYHBhaXJgIG9iamVjdCBhbmQgYSBndXR0ZXIuXG4vLyA1LiBBY3R1YWxseSBzaXplIHRoZSBwYWlyIGVsZW1lbnRzLCBpbnNlcnQgZ3V0dGVycyBhbmQgYXR0YWNoIGV2ZW50IGxpc3RlbmVycy5cbnZhciBTcGxpdCA9IGZ1bmN0aW9uIChpZHNPcHRpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICAgIGlmIChzc3IpIHsgcmV0dXJuIHt9IH1cblxuICAgIHZhciBpZHMgPSBpZHNPcHRpb247XG4gICAgdmFyIGRpbWVuc2lvbjtcbiAgICB2YXIgY2xpZW50QXhpcztcbiAgICB2YXIgcG9zaXRpb247XG4gICAgdmFyIHBvc2l0aW9uRW5kO1xuICAgIHZhciBjbGllbnRTaXplO1xuICAgIHZhciBlbGVtZW50cztcblxuICAgIC8vIEFsbG93IEhUTUxDb2xsZWN0aW9uIHRvIGJlIHVzZWQgYXMgYW4gYXJndW1lbnQgd2hlbiBzdXBwb3J0ZWRcbiAgICBpZiAoQXJyYXkuZnJvbSkge1xuICAgICAgICBpZHMgPSBBcnJheS5mcm9tKGlkcyk7XG4gICAgfVxuXG4gICAgLy8gQWxsIERPTSBlbGVtZW50cyBpbiB0aGUgc3BsaXQgc2hvdWxkIGhhdmUgYSBjb21tb24gcGFyZW50LiBXZSBjYW4gZ3JhYlxuICAgIC8vIHRoZSBmaXJzdCBlbGVtZW50cyBwYXJlbnQgYW5kIGhvcGUgdXNlcnMgcmVhZCB0aGUgZG9jcyBiZWNhdXNlIHRoZVxuICAgIC8vIGJlaGF2aW9yIHdpbGwgYmUgd2hhY2t5IG90aGVyd2lzZS5cbiAgICB2YXIgZmlyc3RFbGVtZW50ID0gZWxlbWVudE9yU2VsZWN0b3IoaWRzWzBdKTtcbiAgICB2YXIgcGFyZW50ID0gZmlyc3RFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgdmFyIHBhcmVudFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSA/IGdldENvbXB1dGVkU3R5bGUocGFyZW50KSA6IG51bGw7XG4gICAgdmFyIHBhcmVudEZsZXhEaXJlY3Rpb24gPSBwYXJlbnRTdHlsZSA/IHBhcmVudFN0eWxlLmZsZXhEaXJlY3Rpb24gOiBudWxsO1xuXG4gICAgLy8gU2V0IGRlZmF1bHQgb3B0aW9ucy5zaXplcyB0byBlcXVhbCBwZXJjZW50YWdlcyBvZiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgdmFyIHNpemVzID0gZ2V0T3B0aW9uKG9wdGlvbnMsICdzaXplcycpIHx8IGlkcy5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gMTAwIC8gaWRzLmxlbmd0aDsgfSk7XG5cbiAgICAvLyBTdGFuZGFyZGl6ZSBtaW5TaXplIGFuZCBtYXhTaXplIHRvIGFuIGFycmF5IGlmIGl0IGlzbid0IGFscmVhZHkuXG4gICAgLy8gVGhpcyBhbGxvd3MgbWluU2l6ZSBhbmQgbWF4U2l6ZSB0byBiZSBwYXNzZWQgYXMgYSBudW1iZXIuXG4gICAgdmFyIG1pblNpemUgPSBnZXRPcHRpb24ob3B0aW9ucywgJ21pblNpemUnLCAxMDApO1xuICAgIHZhciBtaW5TaXplcyA9IEFycmF5LmlzQXJyYXkobWluU2l6ZSkgPyBtaW5TaXplIDogaWRzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBtaW5TaXplOyB9KTtcbiAgICB2YXIgbWF4U2l6ZSA9IGdldE9wdGlvbihvcHRpb25zLCAnbWF4U2l6ZScsIEluZmluaXR5KTtcbiAgICB2YXIgbWF4U2l6ZXMgPSBBcnJheS5pc0FycmF5KG1heFNpemUpID8gbWF4U2l6ZSA6IGlkcy5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF4U2l6ZTsgfSk7XG5cbiAgICAvLyBHZXQgb3RoZXIgb3B0aW9uc1xuICAgIHZhciBleHBhbmRUb01pbiA9IGdldE9wdGlvbihvcHRpb25zLCAnZXhwYW5kVG9NaW4nLCBmYWxzZSk7XG4gICAgdmFyIGd1dHRlclNpemUgPSBnZXRPcHRpb24ob3B0aW9ucywgJ2d1dHRlclNpemUnLCAxMCk7XG4gICAgdmFyIGd1dHRlckFsaWduID0gZ2V0T3B0aW9uKG9wdGlvbnMsICdndXR0ZXJBbGlnbicsICdjZW50ZXInKTtcbiAgICB2YXIgc25hcE9mZnNldCA9IGdldE9wdGlvbihvcHRpb25zLCAnc25hcE9mZnNldCcsIDMwKTtcbiAgICB2YXIgc25hcE9mZnNldHMgPSBBcnJheS5pc0FycmF5KHNuYXBPZmZzZXQpID8gc25hcE9mZnNldCA6IGlkcy5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gc25hcE9mZnNldDsgfSk7XG4gICAgdmFyIGRyYWdJbnRlcnZhbCA9IGdldE9wdGlvbihvcHRpb25zLCAnZHJhZ0ludGVydmFsJywgMSk7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGdldE9wdGlvbihvcHRpb25zLCAnZGlyZWN0aW9uJywgSE9SSVpPTlRBTCk7XG4gICAgdmFyIGN1cnNvciA9IGdldE9wdGlvbihcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgJ2N1cnNvcicsXG4gICAgICAgIGRpcmVjdGlvbiA9PT0gSE9SSVpPTlRBTCA/ICdjb2wtcmVzaXplJyA6ICdyb3ctcmVzaXplJ1xuICAgICk7XG4gICAgdmFyIGd1dHRlciA9IGdldE9wdGlvbihvcHRpb25zLCAnZ3V0dGVyJywgZGVmYXVsdEd1dHRlckZuKTtcbiAgICB2YXIgZWxlbWVudFN0eWxlID0gZ2V0T3B0aW9uKFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICAnZWxlbWVudFN0eWxlJyxcbiAgICAgICAgZGVmYXVsdEVsZW1lbnRTdHlsZUZuXG4gICAgKTtcbiAgICB2YXIgZ3V0dGVyU3R5bGUgPSBnZXRPcHRpb24ob3B0aW9ucywgJ2d1dHRlclN0eWxlJywgZGVmYXVsdEd1dHRlclN0eWxlRm4pO1xuXG4gICAgLy8gMi4gSW5pdGlhbGl6ZSBhIGJ1bmNoIG9mIHN0cmluZ3MgYmFzZWQgb24gdGhlIGRpcmVjdGlvbiB3ZSdyZSBzcGxpdHRpbmcuXG4gICAgLy8gQSBsb3Qgb2YgdGhlIGJlaGF2aW9yIGluIHRoZSByZXN0IG9mIHRoZSBsaWJyYXJ5IGlzIHBhcmFtYXRpemVkIGRvd24gdG9cbiAgICAvLyByZWx5IG9uIENTUyBzdHJpbmdzIGFuZCBjbGFzc2VzLlxuICAgIGlmIChkaXJlY3Rpb24gPT09IEhPUklaT05UQUwpIHtcbiAgICAgICAgZGltZW5zaW9uID0gJ3dpZHRoJztcbiAgICAgICAgY2xpZW50QXhpcyA9ICdjbGllbnRYJztcbiAgICAgICAgcG9zaXRpb24gPSAnbGVmdCc7XG4gICAgICAgIHBvc2l0aW9uRW5kID0gJ3JpZ2h0JztcbiAgICAgICAgY2xpZW50U2l6ZSA9ICdjbGllbnRXaWR0aCc7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgZGltZW5zaW9uID0gJ2hlaWdodCc7XG4gICAgICAgIGNsaWVudEF4aXMgPSAnY2xpZW50WSc7XG4gICAgICAgIHBvc2l0aW9uID0gJ3RvcCc7XG4gICAgICAgIHBvc2l0aW9uRW5kID0gJ2JvdHRvbSc7XG4gICAgICAgIGNsaWVudFNpemUgPSAnY2xpZW50SGVpZ2h0JztcbiAgICB9XG5cbiAgICAvLyAzLiBEZWZpbmUgdGhlIGRyYWdnaW5nIGhlbHBlciBmdW5jdGlvbnMsIGFuZCBhIGZldyBoZWxwZXJzIHRvIGdvIHdpdGggdGhlbS5cbiAgICAvLyBFYWNoIGhlbHBlciBpcyBib3VuZCB0byBhIHBhaXIgb2JqZWN0IHRoYXQgY29udGFpbnMgaXRzIG1ldGFkYXRhLiBUaGlzXG4gICAgLy8gYWxzbyBtYWtlcyBpdCBlYXN5IHRvIHN0b3JlIHJlZmVyZW5jZXMgdG8gbGlzdGVuZXJzIHRoYXQgdGhhdCB3aWxsIGJlXG4gICAgLy8gYWRkZWQgYW5kIHJlbW92ZWQuXG4gICAgLy9cbiAgICAvLyBFdmVuIHRob3VnaCB0aGVyZSBhcmUgbm8gb3RoZXIgZnVuY3Rpb25zIGNvbnRhaW5lZCBpbiB0aGVtLCBhbGlhc2luZ1xuICAgIC8vIHRoaXMgdG8gc2VsZiBzYXZlcyA1MCBieXRlcyBvciBzbyBzaW5jZSBpdCdzIHVzZWQgc28gZnJlcXVlbnRseS5cbiAgICAvL1xuICAgIC8vIFRoZSBwYWlyIG9iamVjdCBzYXZlcyBtZXRhZGF0YSBsaWtlIGRyYWdnaW5nIHN0YXRlLCBwb3NpdGlvbiBhbmRcbiAgICAvLyBldmVudCBsaXN0ZW5lciByZWZlcmVuY2VzLlxuXG4gICAgZnVuY3Rpb24gc2V0RWxlbWVudFNpemUoZWwsIHNpemUsIGd1dFNpemUsIGkpIHtcbiAgICAgICAgLy8gU3BsaXQuanMgYWxsb3dzIHNldHRpbmcgc2l6ZXMgdmlhIG51bWJlcnMgKGlkZWFsbHkpLCBvciBpZiB5b3UgbXVzdCxcbiAgICAgICAgLy8gYnkgc3RyaW5nLCBsaWtlICczMDBweCcuIFRoaXMgaXMgbGVzcyB0aGFuIGlkZWFsLCBiZWNhdXNlIGl0IGJyZWFrc1xuICAgICAgICAvLyB0aGUgZmx1aWQgbGF5b3V0IHRoYXQgYGNhbGMoJSAtIHB4KWAgcHJvdmlkZXMuIFlvdSdyZSBvbiB5b3VyIG93biBpZiB5b3UgZG8gdGhhdCxcbiAgICAgICAgLy8gbWFrZSBzdXJlIHlvdSBjYWxjdWxhdGUgdGhlIGd1dHRlciBzaXplIGJ5IGhhbmQuXG4gICAgICAgIHZhciBzdHlsZSA9IGVsZW1lbnRTdHlsZShkaW1lbnNpb24sIHNpemUsIGd1dFNpemUsIGkpO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGVsLnN0eWxlW3Byb3BdID0gc3R5bGVbcHJvcF07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEd1dHRlclNpemUoZ3V0dGVyRWxlbWVudCwgZ3V0U2l6ZSwgaSkge1xuICAgICAgICB2YXIgc3R5bGUgPSBndXR0ZXJTdHlsZShkaW1lbnNpb24sIGd1dFNpemUsIGkpO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGd1dHRlckVsZW1lbnQuc3R5bGVbcHJvcF0gPSBzdHlsZVtwcm9wXTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2l6ZXMoKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50cy5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIGVsZW1lbnQuc2l6ZTsgfSlcbiAgICB9XG5cbiAgICAvLyBTdXBwb3J0cyB0b3VjaCBldmVudHMsIGJ1dCBub3QgbXVsdGl0b3VjaCwgc28gb25seSB0aGUgZmlyc3RcbiAgICAvLyBmaW5nZXIgYHRvdWNoZXNbMF1gIGlzIGNvdW50ZWQuXG4gICAgZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihlKSB7XG4gICAgICAgIGlmICgndG91Y2hlcycgaW4gZSkgeyByZXR1cm4gZS50b3VjaGVzWzBdW2NsaWVudEF4aXNdIH1cbiAgICAgICAgcmV0dXJuIGVbY2xpZW50QXhpc11cbiAgICB9XG5cbiAgICAvLyBBY3R1YWxseSBhZGp1c3QgdGhlIHNpemUgb2YgZWxlbWVudHMgYGFgIGFuZCBgYmAgdG8gYG9mZnNldGAgd2hpbGUgZHJhZ2dpbmcuXG4gICAgLy8gY2FsYyBpcyB1c2VkIHRvIGFsbG93IGNhbGMocGVyY2VudGFnZSArIGd1dHRlcnB4KSBvbiB0aGUgd2hvbGUgc3BsaXQgaW5zdGFuY2UsXG4gICAgLy8gd2hpY2ggYWxsb3dzIHRoZSB2aWV3cG9ydCB0byBiZSByZXNpemVkIHdpdGhvdXQgYWRkaXRpb25hbCBsb2dpYy5cbiAgICAvLyBFbGVtZW50IGEncyBzaXplIGlzIHRoZSBzYW1lIGFzIG9mZnNldC4gYidzIHNpemUgaXMgdG90YWwgc2l6ZSAtIGEgc2l6ZS5cbiAgICAvLyBCb3RoIHNpemVzIGFyZSBjYWxjdWxhdGVkIGZyb20gdGhlIGluaXRpYWwgcGFyZW50IHBlcmNlbnRhZ2UsXG4gICAgLy8gdGhlbiB0aGUgZ3V0dGVyIHNpemUgaXMgc3VidHJhY3RlZC5cbiAgICBmdW5jdGlvbiBhZGp1c3Qob2Zmc2V0KSB7XG4gICAgICAgIHZhciBhID0gZWxlbWVudHNbdGhpcy5hXTtcbiAgICAgICAgdmFyIGIgPSBlbGVtZW50c1t0aGlzLmJdO1xuICAgICAgICB2YXIgcGVyY2VudGFnZSA9IGEuc2l6ZSArIGIuc2l6ZTtcblxuICAgICAgICBhLnNpemUgPSAob2Zmc2V0IC8gdGhpcy5zaXplKSAqIHBlcmNlbnRhZ2U7XG4gICAgICAgIGIuc2l6ZSA9IHBlcmNlbnRhZ2UgLSAob2Zmc2V0IC8gdGhpcy5zaXplKSAqIHBlcmNlbnRhZ2U7XG5cbiAgICAgICAgc2V0RWxlbWVudFNpemUoYS5lbGVtZW50LCBhLnNpemUsIHRoaXNbYUd1dHRlclNpemVdLCBhLmkpO1xuICAgICAgICBzZXRFbGVtZW50U2l6ZShiLmVsZW1lbnQsIGIuc2l6ZSwgdGhpc1tiR3V0dGVyU2l6ZV0sIGIuaSk7XG4gICAgfVxuXG4gICAgLy8gZHJhZywgd2hlcmUgYWxsIHRoZSBtYWdpYyBoYXBwZW5zLiBUaGUgbG9naWMgaXMgcmVhbGx5IHF1aXRlIHNpbXBsZTpcbiAgICAvL1xuICAgIC8vIDEuIElnbm9yZSBpZiB0aGUgcGFpciBpcyBub3QgZHJhZ2dpbmcuXG4gICAgLy8gMi4gR2V0IHRoZSBvZmZzZXQgb2YgdGhlIGV2ZW50LlxuICAgIC8vIDMuIFNuYXAgb2Zmc2V0IHRvIG1pbiBpZiB3aXRoaW4gc25hcHBhYmxlIHJhbmdlICh3aXRoaW4gbWluICsgc25hcE9mZnNldCkuXG4gICAgLy8gNC4gQWN0dWFsbHkgYWRqdXN0IGVhY2ggZWxlbWVudCBpbiB0aGUgcGFpciB0byBvZmZzZXQuXG4gICAgLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB8ICAgIHwgPC0gYS5taW5TaXplICAgICAgICAgICAgICAgfHwgICAgICAgICAgICAgIGIubWluU2l6ZSAtPiB8ICAgIHxcbiAgICAvLyB8ICAgIHwgIHwgPC0gdGhpcy5zbmFwT2Zmc2V0ICAgICAgfHwgICAgIHRoaXMuc25hcE9mZnNldCAtPiB8ICB8ICAgIHxcbiAgICAvLyB8ICAgIHwgIHwgICAgICAgICAgICAgICAgICAgICAgICAgfHwgICAgICAgICAgICAgICAgICAgICAgICB8ICB8ICAgIHxcbiAgICAvLyB8ICAgIHwgIHwgICAgICAgICAgICAgICAgICAgICAgICAgfHwgICAgICAgICAgICAgICAgICAgICAgICB8ICB8ICAgIHxcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB8IDwtIHRoaXMuc3RhcnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplIC0+IHxcbiAgICBmdW5jdGlvbiBkcmFnKGUpIHtcbiAgICAgICAgdmFyIG9mZnNldDtcbiAgICAgICAgdmFyIGEgPSBlbGVtZW50c1t0aGlzLmFdO1xuICAgICAgICB2YXIgYiA9IGVsZW1lbnRzW3RoaXMuYl07XG5cbiAgICAgICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7IHJldHVybiB9XG5cbiAgICAgICAgLy8gR2V0IHRoZSBvZmZzZXQgb2YgdGhlIGV2ZW50IGZyb20gdGhlIGZpcnN0IHNpZGUgb2YgdGhlXG4gICAgICAgIC8vIHBhaXIgYHRoaXMuc3RhcnRgLiBUaGVuIG9mZnNldCBieSB0aGUgaW5pdGlhbCBwb3NpdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gbW91c2UgY29tcGFyZWQgdG8gdGhlIGd1dHRlciBzaXplLlxuICAgICAgICBvZmZzZXQgPVxuICAgICAgICAgICAgZ2V0TW91c2VQb3NpdGlvbihlKSAtXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ICtcbiAgICAgICAgICAgICh0aGlzW2FHdXR0ZXJTaXplXSAtIHRoaXMuZHJhZ09mZnNldCk7XG5cbiAgICAgICAgaWYgKGRyYWdJbnRlcnZhbCA+IDEpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IE1hdGgucm91bmQob2Zmc2V0IC8gZHJhZ0ludGVydmFsKSAqIGRyYWdJbnRlcnZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdpdGhpbiBzbmFwT2Zmc2V0IG9mIG1pbiBvciBtYXgsIHNldCBvZmZzZXQgdG8gbWluIG9yIG1heC5cbiAgICAgICAgLy8gc25hcE9mZnNldCBidWZmZXJzIGEubWluU2l6ZSBhbmQgYi5taW5TaXplLCBzbyBsb2dpYyBpcyBvcHBvc2l0ZSBmb3IgYm90aC5cbiAgICAgICAgLy8gSW5jbHVkZSB0aGUgYXBwcm9wcmlhdGUgZ3V0dGVyIHNpemVzIHRvIHByZXZlbnQgb3ZlcmZsb3dzLlxuICAgICAgICBpZiAob2Zmc2V0IDw9IGEubWluU2l6ZSArIGEuc25hcE9mZnNldCArIHRoaXNbYUd1dHRlclNpemVdKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBhLm1pblNpemUgKyB0aGlzW2FHdXR0ZXJTaXplXTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIG9mZnNldCA+PVxuICAgICAgICAgICAgdGhpcy5zaXplIC0gKGIubWluU2l6ZSArIGIuc25hcE9mZnNldCArIHRoaXNbYkd1dHRlclNpemVdKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuc2l6ZSAtIChiLm1pblNpemUgKyB0aGlzW2JHdXR0ZXJTaXplXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2Zmc2V0ID49IGEubWF4U2l6ZSAtIGEuc25hcE9mZnNldCArIHRoaXNbYUd1dHRlclNpemVdKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBhLm1heFNpemUgKyB0aGlzW2FHdXR0ZXJTaXplXTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIG9mZnNldCA8PVxuICAgICAgICAgICAgdGhpcy5zaXplIC0gKGIubWF4U2l6ZSAtIGIuc25hcE9mZnNldCArIHRoaXNbYkd1dHRlclNpemVdKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuc2l6ZSAtIChiLm1heFNpemUgKyB0aGlzW2JHdXR0ZXJTaXplXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBY3R1YWxseSBhZGp1c3QgdGhlIHNpemUuXG4gICAgICAgIGFkanVzdC5jYWxsKHRoaXMsIG9mZnNldCk7XG5cbiAgICAgICAgLy8gQ2FsbCB0aGUgZHJhZyBjYWxsYmFjayBjb250aW5vdXNseS4gRG9uJ3QgZG8gYW55dGhpbmcgdG9vIGludGVuc2l2ZVxuICAgICAgICAvLyBpbiB0aGlzIGNhbGxiYWNrLlxuICAgICAgICBnZXRPcHRpb24ob3B0aW9ucywgJ29uRHJhZycsIE5PT1ApKGdldFNpemVzKCkpO1xuICAgIH1cblxuICAgIC8vIENhY2hlIHNvbWUgaW1wb3J0YW50IHNpemVzIHdoZW4gZHJhZyBzdGFydHMsIHNvIHdlIGRvbid0IGhhdmUgdG8gZG8gdGhhdFxuICAgIC8vIGNvbnRpbm91c2x5OlxuICAgIC8vXG4gICAgLy8gYHNpemVgOiBUaGUgdG90YWwgc2l6ZSBvZiB0aGUgcGFpci4gRmlyc3QgKyBzZWNvbmQgKyBmaXJzdCBndXR0ZXIgKyBzZWNvbmQgZ3V0dGVyLlxuICAgIC8vIGBzdGFydGA6IFRoZSBsZWFkaW5nIHNpZGUgb2YgdGhlIGZpcnN0IGVsZW1lbnQuXG4gICAgLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB8ICAgICAgYUd1dHRlclNpemUgLT4gfHx8ICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyB8ICAgICAgICAgICAgICAgICAgICAgfHx8ICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyB8ICAgICAgICAgICAgICAgICAgICAgfHx8ICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyB8ICAgICAgICAgICAgICAgICAgICAgfHx8IDwtIGJHdXR0ZXJTaXplICAgICAgIHxcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB8IDwtIHN0YXJ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplIC0+IHxcbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVTaXplcygpIHtcbiAgICAgICAgLy8gRmlndXJlIG91dCB0aGUgcGFyZW50IHNpemUgbWludXMgcGFkZGluZy5cbiAgICAgICAgdmFyIGEgPSBlbGVtZW50c1t0aGlzLmFdLmVsZW1lbnQ7XG4gICAgICAgIHZhciBiID0gZWxlbWVudHNbdGhpcy5iXS5lbGVtZW50O1xuXG4gICAgICAgIHZhciBhQm91bmRzID0gYVtnZXRCb3VuZGluZ0NsaWVudFJlY3RdKCk7XG4gICAgICAgIHZhciBiQm91bmRzID0gYltnZXRCb3VuZGluZ0NsaWVudFJlY3RdKCk7XG5cbiAgICAgICAgdGhpcy5zaXplID1cbiAgICAgICAgICAgIGFCb3VuZHNbZGltZW5zaW9uXSArXG4gICAgICAgICAgICBiQm91bmRzW2RpbWVuc2lvbl0gK1xuICAgICAgICAgICAgdGhpc1thR3V0dGVyU2l6ZV0gK1xuICAgICAgICAgICAgdGhpc1tiR3V0dGVyU2l6ZV07XG4gICAgICAgIHRoaXMuc3RhcnQgPSBhQm91bmRzW3Bvc2l0aW9uXTtcbiAgICAgICAgdGhpcy5lbmQgPSBhQm91bmRzW3Bvc2l0aW9uRW5kXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbm5lclNpemUoZWxlbWVudCkge1xuICAgICAgICAvLyBSZXR1cm4gbm90aGluZyBpZiBnZXRDb21wdXRlZFN0eWxlIGlzIG5vdCBzdXBwb3J0ZWQgKDwgSUU5KVxuICAgICAgICAvLyBPciBpZiBwYXJlbnQgZWxlbWVudCBoYXMgbm8gbGF5b3V0IHlldFxuICAgICAgICBpZiAoIWdldENvbXB1dGVkU3R5bGUpIHsgcmV0dXJuIG51bGwgfVxuXG4gICAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgICAgICBpZiAoIWNvbXB1dGVkU3R5bGUpIHsgcmV0dXJuIG51bGwgfVxuXG4gICAgICAgIHZhciBzaXplID0gZWxlbWVudFtjbGllbnRTaXplXTtcblxuICAgICAgICBpZiAoc2l6ZSA9PT0gMCkgeyByZXR1cm4gbnVsbCB9XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgc2l6ZSAtPVxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nTGVmdCkgK1xuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2l6ZSAtPVxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nVG9wKSArXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdCb3R0b20pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNpemVcbiAgICB9XG5cbiAgICAvLyBXaGVuIHNwZWNpZnlpbmcgcGVyY2VudGFnZSBzaXplcyB0aGF0IGFyZSBsZXNzIHRoYW4gdGhlIGNvbXB1dGVkXG4gICAgLy8gc2l6ZSBvZiB0aGUgZWxlbWVudCBtaW51cyB0aGUgZ3V0dGVyLCB0aGUgbGVzc2VyIHBlcmNlbnRhZ2VzIG11c3QgYmUgaW5jcmVhc2VkXG4gICAgLy8gKGFuZCBkZWNyZWFzZWQgZnJvbSB0aGUgb3RoZXIgZWxlbWVudHMpIHRvIG1ha2Ugc3BhY2UgZm9yIHRoZSBwaXhlbHNcbiAgICAvLyBzdWJ0cmFjdGVkIGJ5IHRoZSBndXR0ZXJzLlxuICAgIGZ1bmN0aW9uIHRyaW1Ub01pbihzaXplc1RvVHJpbSkge1xuICAgICAgICAvLyBUcnkgdG8gZ2V0IGlubmVyIHNpemUgb2YgcGFyZW50IGVsZW1lbnQuXG4gICAgICAgIC8vIElmIGl0J3Mgbm8gc3VwcG9ydGVkLCByZXR1cm4gb3JpZ2luYWwgc2l6ZXMuXG4gICAgICAgIHZhciBwYXJlbnRTaXplID0gaW5uZXJTaXplKHBhcmVudCk7XG4gICAgICAgIGlmIChwYXJlbnRTaXplID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZXNUb1RyaW1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaW5TaXplcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgKyBiOyB9LCAwKSA+IHBhcmVudFNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBzaXplc1RvVHJpbVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgZXhjZXNzIHBpeGVscywgdGhlIGFtb3VudCBvZiBwaXhlbHMgb3ZlciB0aGUgZGVzaXJlZCBwZXJjZW50YWdlXG4gICAgICAgIC8vIEFsc28ga2VlcCB0cmFjayBvZiB0aGUgZWxlbWVudHMgd2l0aCBwaXhlbHMgdG8gc3BhcmUsIHRvIGRlY3JlYXNlIGFmdGVyIGlmIG5lZWRlZFxuICAgICAgICB2YXIgZXhjZXNzUGl4ZWxzID0gMDtcbiAgICAgICAgdmFyIHRvU3BhcmUgPSBbXTtcblxuICAgICAgICB2YXIgcGl4ZWxTaXplcyA9IHNpemVzVG9UcmltLm1hcChmdW5jdGlvbiAoc2l6ZSwgaSkge1xuICAgICAgICAgICAgLy8gQ29udmVydCByZXF1ZXN0ZWQgcGVyY2VudGFnZXMgdG8gcGl4ZWwgc2l6ZXNcbiAgICAgICAgICAgIHZhciBwaXhlbFNpemUgPSAocGFyZW50U2l6ZSAqIHNpemUpIC8gMTAwO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRHdXR0ZXJTaXplID0gZ2V0R3V0dGVyU2l6ZShcbiAgICAgICAgICAgICAgICBndXR0ZXJTaXplLFxuICAgICAgICAgICAgICAgIGkgPT09IDAsXG4gICAgICAgICAgICAgICAgaSA9PT0gc2l6ZXNUb1RyaW0ubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICBndXR0ZXJBbGlnblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50TWluU2l6ZSA9IG1pblNpemVzW2ldICsgZWxlbWVudEd1dHRlclNpemU7XG5cbiAgICAgICAgICAgIC8vIElmIGVsZW1lbnQgaXMgdG9vIHNtYWwsIGluY3JlYXNlIGV4Y2VzcyBwaXhlbHMgYnkgdGhlIGRpZmZlcmVuY2VcbiAgICAgICAgICAgIC8vIGFuZCBtYXJrIHRoYXQgaXQgaGFzIG5vIHBpeGVscyB0byBzcGFyZVxuICAgICAgICAgICAgaWYgKHBpeGVsU2l6ZSA8IGVsZW1lbnRNaW5TaXplKSB7XG4gICAgICAgICAgICAgICAgZXhjZXNzUGl4ZWxzICs9IGVsZW1lbnRNaW5TaXplIC0gcGl4ZWxTaXplO1xuICAgICAgICAgICAgICAgIHRvU3BhcmUucHVzaCgwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudE1pblNpemVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBtYXJrIHRoZSBwaXhlbHMgaXQgaGFzIHRvIHNwYXJlIGFuZCByZXR1cm4gaXQncyBvcmlnaW5hbCBzaXplXG4gICAgICAgICAgICB0b1NwYXJlLnB1c2gocGl4ZWxTaXplIC0gZWxlbWVudE1pblNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIHBpeGVsU2l6ZVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJZiBub3RoaW5nIHdhcyBhZGp1c3RlZCwgcmV0dXJuIHRoZSBvcmlnaW5hbCBzaXplc1xuICAgICAgICBpZiAoZXhjZXNzUGl4ZWxzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZXNUb1RyaW1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwaXhlbFNpemVzLm1hcChmdW5jdGlvbiAocGl4ZWxTaXplLCBpKSB7XG4gICAgICAgICAgICB2YXIgbmV3UGl4ZWxTaXplID0gcGl4ZWxTaXplO1xuXG4gICAgICAgICAgICAvLyBXaGlsZSB0aGVyZSdzIHN0aWxsIHBpeGVscyB0byB0YWtlLCBhbmQgdGhlcmUncyBlbm91Z2ggcGl4ZWxzIHRvIHNwYXJlLFxuICAgICAgICAgICAgLy8gdGFrZSBhcyBtYW55IGFzIHBvc3NpYmxlIHVwIHRvIHRoZSB0b3RhbCBleGNlc3MgcGl4ZWxzXG4gICAgICAgICAgICBpZiAoZXhjZXNzUGl4ZWxzID4gMCAmJiB0b1NwYXJlW2ldIC0gZXhjZXNzUGl4ZWxzID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWtlblBpeGVscyA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgICBleGNlc3NQaXhlbHMsXG4gICAgICAgICAgICAgICAgICAgIHRvU3BhcmVbaV0gLSBleGNlc3NQaXhlbHNcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgdGhlIGFtb3VudCB0YWtlbiBmb3IgdGhlIG5leHQgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgZXhjZXNzUGl4ZWxzIC09IHRha2VuUGl4ZWxzO1xuICAgICAgICAgICAgICAgIG5ld1BpeGVsU2l6ZSA9IHBpeGVsU2l6ZSAtIHRha2VuUGl4ZWxzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHBpeGVsIHNpemUgYWRqdXN0ZWQgYXMgYSBwZXJjZW50YWdlXG4gICAgICAgICAgICByZXR1cm4gKG5ld1BpeGVsU2l6ZSAvIHBhcmVudFNpemUpICogMTAwXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gc3RvcERyYWdnaW5nIGlzIHZlcnkgc2ltaWxhciB0byBzdGFydERyYWdnaW5nIGluIHJldmVyc2UuXG4gICAgZnVuY3Rpb24gc3RvcERyYWdnaW5nKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBhID0gZWxlbWVudHNbc2VsZi5hXS5lbGVtZW50O1xuICAgICAgICB2YXIgYiA9IGVsZW1lbnRzW3NlbGYuYl0uZWxlbWVudDtcblxuICAgICAgICBpZiAoc2VsZi5kcmFnZ2luZykge1xuICAgICAgICAgICAgZ2V0T3B0aW9uKG9wdGlvbnMsICdvbkRyYWdFbmQnLCBOT09QKShnZXRTaXplcygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuZHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIHN0b3JlZCBldmVudCBsaXN0ZW5lcnMuIFRoaXMgaXMgd2h5IHdlIHN0b3JlIHRoZW0uXG4gICAgICAgIGdsb2JhbFtyZW1vdmVFdmVudExpc3RlbmVyXSgnbW91c2V1cCcsIHNlbGYuc3RvcCk7XG4gICAgICAgIGdsb2JhbFtyZW1vdmVFdmVudExpc3RlbmVyXSgndG91Y2hlbmQnLCBzZWxmLnN0b3ApO1xuICAgICAgICBnbG9iYWxbcmVtb3ZlRXZlbnRMaXN0ZW5lcl0oJ3RvdWNoY2FuY2VsJywgc2VsZi5zdG9wKTtcbiAgICAgICAgZ2xvYmFsW3JlbW92ZUV2ZW50TGlzdGVuZXJdKCdtb3VzZW1vdmUnLCBzZWxmLm1vdmUpO1xuICAgICAgICBnbG9iYWxbcmVtb3ZlRXZlbnRMaXN0ZW5lcl0oJ3RvdWNobW92ZScsIHNlbGYubW92ZSk7XG5cbiAgICAgICAgLy8gQ2xlYXIgYm91bmQgZnVuY3Rpb24gcmVmZXJlbmNlc1xuICAgICAgICBzZWxmLnN0b3AgPSBudWxsO1xuICAgICAgICBzZWxmLm1vdmUgPSBudWxsO1xuXG4gICAgICAgIGFbcmVtb3ZlRXZlbnRMaXN0ZW5lcl0oJ3NlbGVjdHN0YXJ0JywgTk9PUCk7XG4gICAgICAgIGFbcmVtb3ZlRXZlbnRMaXN0ZW5lcl0oJ2RyYWdzdGFydCcsIE5PT1ApO1xuICAgICAgICBiW3JlbW92ZUV2ZW50TGlzdGVuZXJdKCdzZWxlY3RzdGFydCcsIE5PT1ApO1xuICAgICAgICBiW3JlbW92ZUV2ZW50TGlzdGVuZXJdKCdkcmFnc3RhcnQnLCBOT09QKTtcblxuICAgICAgICBhLnN0eWxlLnVzZXJTZWxlY3QgPSAnJztcbiAgICAgICAgYS5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gJyc7XG4gICAgICAgIGEuc3R5bGUuTW96VXNlclNlbGVjdCA9ICcnO1xuICAgICAgICBhLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcblxuICAgICAgICBiLnN0eWxlLnVzZXJTZWxlY3QgPSAnJztcbiAgICAgICAgYi5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gJyc7XG4gICAgICAgIGIuc3R5bGUuTW96VXNlclNlbGVjdCA9ICcnO1xuICAgICAgICBiLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcblxuICAgICAgICBzZWxmLmd1dHRlci5zdHlsZS5jdXJzb3IgPSAnJztcbiAgICAgICAgc2VsZi5wYXJlbnQuc3R5bGUuY3Vyc29yID0gJyc7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJyc7XG4gICAgfVxuXG4gICAgLy8gc3RhcnREcmFnZ2luZyBjYWxscyBgY2FsY3VsYXRlU2l6ZXNgIHRvIHN0b3JlIHRoZSBpbml0YWwgc2l6ZSBpbiB0aGUgcGFpciBvYmplY3QuXG4gICAgLy8gSXQgYWxzbyBhZGRzIGV2ZW50IGxpc3RlbmVycyBmb3IgbW91c2UvdG91Y2ggZXZlbnRzLFxuICAgIC8vIGFuZCBwcmV2ZW50cyBzZWxlY3Rpb24gd2hpbGUgZHJhZ2dpbmcgc28gYXZvaWQgdGhlIHNlbGVjdGluZyB0ZXh0LlxuICAgIGZ1bmN0aW9uIHN0YXJ0RHJhZ2dpbmcoZSkge1xuICAgICAgICAvLyBSaWdodC1jbGlja2luZyBjYW4ndCBzdGFydCBkcmFnZ2luZy5cbiAgICAgICAgaWYgKCdidXR0b24nIGluIGUgJiYgZS5idXR0b24gIT09IDApIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWxpYXMgZnJlcXVlbnRseSB1c2VkIHZhcmlhYmxlcyB0byBzYXZlIHNwYWNlLiAyMDAgYnl0ZXMuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGEgPSBlbGVtZW50c1tzZWxmLmFdLmVsZW1lbnQ7XG4gICAgICAgIHZhciBiID0gZWxlbWVudHNbc2VsZi5iXS5lbGVtZW50O1xuXG4gICAgICAgIC8vIENhbGwgdGhlIG9uRHJhZ1N0YXJ0IGNhbGxiYWNrLlxuICAgICAgICBpZiAoIXNlbGYuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGdldE9wdGlvbihvcHRpb25zLCAnb25EcmFnU3RhcnQnLCBOT09QKShnZXRTaXplcygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvbid0IGFjdHVhbGx5IGRyYWcgdGhlIGVsZW1lbnQuIFdlIGVtdWxhdGUgdGhhdCBpbiB0aGUgZHJhZyBmdW5jdGlvbi5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIFNldCB0aGUgZHJhZ2dpbmcgcHJvcGVydHkgb2YgdGhlIHBhaXIgb2JqZWN0LlxuICAgICAgICBzZWxmLmRyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICAvLyBDcmVhdGUgdHdvIGV2ZW50IGxpc3RlbmVycyBib3VuZCB0byB0aGUgc2FtZSBwYWlyIG9iamVjdCBhbmQgc3RvcmVcbiAgICAgICAgLy8gdGhlbSBpbiB0aGUgcGFpciBvYmplY3QuXG4gICAgICAgIHNlbGYubW92ZSA9IGRyYWcuYmluZChzZWxmKTtcbiAgICAgICAgc2VsZi5zdG9wID0gc3RvcERyYWdnaW5nLmJpbmQoc2VsZik7XG5cbiAgICAgICAgLy8gQWxsIHRoZSBiaW5kaW5nLiBgd2luZG93YCBnZXRzIHRoZSBzdG9wIGV2ZW50cyBpbiBjYXNlIHdlIGRyYWcgb3V0IG9mIHRoZSBlbGVtZW50cy5cbiAgICAgICAgZ2xvYmFsW2FkZEV2ZW50TGlzdGVuZXJdKCdtb3VzZXVwJywgc2VsZi5zdG9wKTtcbiAgICAgICAgZ2xvYmFsW2FkZEV2ZW50TGlzdGVuZXJdKCd0b3VjaGVuZCcsIHNlbGYuc3RvcCk7XG4gICAgICAgIGdsb2JhbFthZGRFdmVudExpc3RlbmVyXSgndG91Y2hjYW5jZWwnLCBzZWxmLnN0b3ApO1xuICAgICAgICBnbG9iYWxbYWRkRXZlbnRMaXN0ZW5lcl0oJ21vdXNlbW92ZScsIHNlbGYubW92ZSk7XG4gICAgICAgIGdsb2JhbFthZGRFdmVudExpc3RlbmVyXSgndG91Y2htb3ZlJywgc2VsZi5tb3ZlKTtcblxuICAgICAgICAvLyBEaXNhYmxlIHNlbGVjdGlvbi4gRGlzYWJsZSFcbiAgICAgICAgYVthZGRFdmVudExpc3RlbmVyXSgnc2VsZWN0c3RhcnQnLCBOT09QKTtcbiAgICAgICAgYVthZGRFdmVudExpc3RlbmVyXSgnZHJhZ3N0YXJ0JywgTk9PUCk7XG4gICAgICAgIGJbYWRkRXZlbnRMaXN0ZW5lcl0oJ3NlbGVjdHN0YXJ0JywgTk9PUCk7XG4gICAgICAgIGJbYWRkRXZlbnRMaXN0ZW5lcl0oJ2RyYWdzdGFydCcsIE5PT1ApO1xuXG4gICAgICAgIGEuc3R5bGUudXNlclNlbGVjdCA9ICdub25lJztcbiAgICAgICAgYS5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgICAgICBhLnN0eWxlLk1velVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICAgIGEuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcblxuICAgICAgICBiLnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICAgIGIuc3R5bGUud2Via2l0VXNlclNlbGVjdCA9ICdub25lJztcbiAgICAgICAgYi5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgICAgICBiLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBjdXJzb3IgYXQgbXVsdGlwbGUgbGV2ZWxzXG4gICAgICAgIHNlbGYuZ3V0dGVyLnN0eWxlLmN1cnNvciA9IGN1cnNvcjtcbiAgICAgICAgc2VsZi5wYXJlbnQuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9IGN1cnNvcjtcblxuICAgICAgICAvLyBDYWNoZSB0aGUgaW5pdGlhbCBzaXplcyBvZiB0aGUgcGFpci5cbiAgICAgICAgY2FsY3VsYXRlU2l6ZXMuY2FsbChzZWxmKTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIHRoZSBtb3VzZSBjb21wYXJlZCB0byB0aGUgZ3V0dGVyXG4gICAgICAgIHNlbGYuZHJhZ09mZnNldCA9IGdldE1vdXNlUG9zaXRpb24oZSkgLSBzZWxmLmVuZDtcbiAgICB9XG5cbiAgICAvLyBhZGp1c3Qgc2l6ZXMgdG8gZW5zdXJlIHBlcmNlbnRhZ2UgaXMgd2l0aGluIG1pbiBzaXplIGFuZCBndXR0ZXIuXG4gICAgc2l6ZXMgPSB0cmltVG9NaW4oc2l6ZXMpO1xuXG4gICAgLy8gNS4gQ3JlYXRlIHBhaXIgYW5kIGVsZW1lbnQgb2JqZWN0cy4gRWFjaCBwYWlyIGhhcyBhbiBpbmRleCByZWZlcmVuY2UgdG9cbiAgICAvLyBlbGVtZW50cyBgYWAgYW5kIGBiYCBvZiB0aGUgcGFpciAoZmlyc3QgYW5kIHNlY29uZCBlbGVtZW50cykuXG4gICAgLy8gTG9vcCB0aHJvdWdoIHRoZSBlbGVtZW50cyB3aGlsZSBwYWlyaW5nIHRoZW0gb2ZmLiBFdmVyeSBwYWlyIGdldHMgYVxuICAgIC8vIGBwYWlyYCBvYmplY3QgYW5kIGEgZ3V0dGVyLlxuICAgIC8vXG4gICAgLy8gQmFzaWMgbG9naWM6XG4gICAgLy9cbiAgICAvLyAtIFN0YXJ0aW5nIHdpdGggdGhlIHNlY29uZCBlbGVtZW50IGBpID4gMGAsIGNyZWF0ZSBgcGFpcmAgb2JqZWN0cyB3aXRoXG4gICAgLy8gICBgYSA9IGkgLSAxYCBhbmQgYGIgPSBpYFxuICAgIC8vIC0gU2V0IGd1dHRlciBzaXplcyBiYXNlZCBvbiB0aGUgX3BhaXJfIGJlaW5nIGZpcnN0L2xhc3QuIFRoZSBmaXJzdCBhbmQgbGFzdFxuICAgIC8vICAgcGFpciBoYXZlIGd1dHRlclNpemUgLyAyLCBzaW5jZSB0aGV5IG9ubHkgaGF2ZSBvbmUgaGFsZiBndXR0ZXIsIGFuZCBub3QgdHdvLlxuICAgIC8vIC0gQ3JlYXRlIGd1dHRlciBlbGVtZW50cyBhbmQgYWRkIGV2ZW50IGxpc3RlbmVycy5cbiAgICAvLyAtIFNldCB0aGUgc2l6ZSBvZiB0aGUgZWxlbWVudHMsIG1pbnVzIHRoZSBndXR0ZXIgc2l6ZXMuXG4gICAgLy9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHwgICAgIGk9MCAgICAgfCAgICAgICAgIGk9MSAgICAgICAgIHwgICAgICAgIGk9MiAgICAgICB8ICAgICAgaT0zICAgICB8XG4gICAgLy8gfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAgICAvLyB8ICAgICAgICAgICBwYWlyIDAgICAgICAgICAgICAgICAgcGFpciAxICAgICAgICAgICAgIHBhaXIgMiAgICAgICAgICAgfFxuICAgIC8vIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICBlbGVtZW50cyA9IGlkcy5tYXAoZnVuY3Rpb24gKGlkLCBpKSB7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgZWxlbWVudCBvYmplY3QuXG4gICAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudE9yU2VsZWN0b3IoaWQpLFxuICAgICAgICAgICAgc2l6ZTogc2l6ZXNbaV0sXG4gICAgICAgICAgICBtaW5TaXplOiBtaW5TaXplc1tpXSxcbiAgICAgICAgICAgIG1heFNpemU6IG1heFNpemVzW2ldLFxuICAgICAgICAgICAgc25hcE9mZnNldDogc25hcE9mZnNldHNbaV0sXG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwYWlyO1xuXG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBwYWlyIG9iamVjdCB3aXRoIGl0cyBtZXRhZGF0YS5cbiAgICAgICAgICAgIHBhaXIgPSB7XG4gICAgICAgICAgICAgICAgYTogaSAtIDEsXG4gICAgICAgICAgICAgICAgYjogaSxcbiAgICAgICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBwYWlyW2FHdXR0ZXJTaXplXSA9IGdldEd1dHRlclNpemUoXG4gICAgICAgICAgICAgICAgZ3V0dGVyU2l6ZSxcbiAgICAgICAgICAgICAgICBpIC0gMSA9PT0gMCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBndXR0ZXJBbGlnblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHBhaXJbYkd1dHRlclNpemVdID0gZ2V0R3V0dGVyU2l6ZShcbiAgICAgICAgICAgICAgICBndXR0ZXJTaXplLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGkgPT09IGlkcy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgIGd1dHRlckFsaWduXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgcGFyZW50IGhhcyBhIHJldmVyc2UgZmxleC1kaXJlY3Rpb24sIHN3aXRjaCB0aGUgcGFpciBlbGVtZW50cy5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBwYXJlbnRGbGV4RGlyZWN0aW9uID09PSAncm93LXJldmVyc2UnIHx8XG4gICAgICAgICAgICAgICAgcGFyZW50RmxleERpcmVjdGlvbiA9PT0gJ2NvbHVtbi1yZXZlcnNlJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBwYWlyLmE7XG4gICAgICAgICAgICAgICAgcGFpci5hID0gcGFpci5iO1xuICAgICAgICAgICAgICAgIHBhaXIuYiA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHNpemUgb2YgdGhlIGN1cnJlbnQgZWxlbWVudC4gSUU4IGlzIHN1cHBvcnRlZCBieVxuICAgICAgICAvLyBzdGF0aWNseSBhc3NpZ25pbmcgc2l6ZXMgd2l0aG91dCBkcmFnZ2FibGUgZ3V0dGVycy4gQXNzaWducyBhIHN0cmluZ1xuICAgICAgICAvLyB0byBgc2l6ZWAuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIENyZWF0ZSBndXR0ZXIgZWxlbWVudHMgZm9yIGVhY2ggcGFpci5cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICB2YXIgZ3V0dGVyRWxlbWVudCA9IGd1dHRlcihpLCBkaXJlY3Rpb24sIGVsZW1lbnQuZWxlbWVudCk7XG4gICAgICAgICAgICBzZXRHdXR0ZXJTaXplKGd1dHRlckVsZW1lbnQsIGd1dHRlclNpemUsIGkpO1xuXG4gICAgICAgICAgICAvLyBTYXZlIGJvdW5kIGV2ZW50IGxpc3RlbmVyIGZvciByZW1vdmFsIGxhdGVyXG4gICAgICAgICAgICBwYWlyW2d1dHRlclN0YXJ0RHJhZ2dpbmddID0gc3RhcnREcmFnZ2luZy5iaW5kKHBhaXIpO1xuXG4gICAgICAgICAgICAvLyBBdHRhY2ggYm91bmQgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgICAgIGd1dHRlckVsZW1lbnRbYWRkRXZlbnRMaXN0ZW5lcl0oXG4gICAgICAgICAgICAgICAgJ21vdXNlZG93bicsXG4gICAgICAgICAgICAgICAgcGFpcltndXR0ZXJTdGFydERyYWdnaW5nXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGd1dHRlckVsZW1lbnRbYWRkRXZlbnRMaXN0ZW5lcl0oXG4gICAgICAgICAgICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgICAgICAgICAgIHBhaXJbZ3V0dGVyU3RhcnREcmFnZ2luZ11cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZ3V0dGVyRWxlbWVudCwgZWxlbWVudC5lbGVtZW50KTtcblxuICAgICAgICAgICAgcGFpci5ndXR0ZXIgPSBndXR0ZXJFbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0RWxlbWVudFNpemUoXG4gICAgICAgICAgICBlbGVtZW50LmVsZW1lbnQsXG4gICAgICAgICAgICBlbGVtZW50LnNpemUsXG4gICAgICAgICAgICBnZXRHdXR0ZXJTaXplKFxuICAgICAgICAgICAgICAgIGd1dHRlclNpemUsXG4gICAgICAgICAgICAgICAgaSA9PT0gMCxcbiAgICAgICAgICAgICAgICBpID09PSBpZHMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICBndXR0ZXJBbGlnblxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBBZnRlciB0aGUgZmlyc3QgaXRlcmF0aW9uLCBhbmQgd2UgaGF2ZSBhIHBhaXIgb2JqZWN0LCBhcHBlbmQgaXQgdG8gdGhlXG4gICAgICAgIC8vIGxpc3Qgb2YgcGFpcnMuXG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgcGFpcnMucHVzaChwYWlyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtZW50XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGp1c3RUb01pbihlbGVtZW50KSB7XG4gICAgICAgIHZhciBpc0xhc3QgPSBlbGVtZW50LmkgPT09IHBhaXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIHBhaXIgPSBpc0xhc3QgPyBwYWlyc1tlbGVtZW50LmkgLSAxXSA6IHBhaXJzW2VsZW1lbnQuaV07XG5cbiAgICAgICAgY2FsY3VsYXRlU2l6ZXMuY2FsbChwYWlyKTtcblxuICAgICAgICB2YXIgc2l6ZSA9IGlzTGFzdFxuICAgICAgICAgICAgPyBwYWlyLnNpemUgLSBlbGVtZW50Lm1pblNpemUgLSBwYWlyW2JHdXR0ZXJTaXplXVxuICAgICAgICAgICAgOiBlbGVtZW50Lm1pblNpemUgKyBwYWlyW2FHdXR0ZXJTaXplXTtcblxuICAgICAgICBhZGp1c3QuY2FsbChwYWlyLCBzaXplKTtcbiAgICB9XG5cbiAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBjb21wdXRlZFNpemUgPSBlbGVtZW50LmVsZW1lbnRbZ2V0Qm91bmRpbmdDbGllbnRSZWN0XSgpW2RpbWVuc2lvbl07XG5cbiAgICAgICAgaWYgKGNvbXB1dGVkU2l6ZSA8IGVsZW1lbnQubWluU2l6ZSkge1xuICAgICAgICAgICAgaWYgKGV4cGFuZFRvTWluKSB7XG4gICAgICAgICAgICAgICAgYWRqdXN0VG9NaW4oZWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGVsZW1lbnQubWluU2l6ZSA9IGNvbXB1dGVkU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gc2V0U2l6ZXMobmV3U2l6ZXMpIHtcbiAgICAgICAgdmFyIHRyaW1tZWQgPSB0cmltVG9NaW4obmV3U2l6ZXMpO1xuICAgICAgICB0cmltbWVkLmZvckVhY2goZnVuY3Rpb24gKG5ld1NpemUsIGkpIHtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaSAtIDFdO1xuXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBlbGVtZW50c1twYWlyLmFdO1xuICAgICAgICAgICAgICAgIHZhciBiID0gZWxlbWVudHNbcGFpci5iXTtcblxuICAgICAgICAgICAgICAgIGEuc2l6ZSA9IHRyaW1tZWRbaSAtIDFdO1xuICAgICAgICAgICAgICAgIGIuc2l6ZSA9IG5ld1NpemU7XG5cbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2l6ZShhLmVsZW1lbnQsIGEuc2l6ZSwgcGFpclthR3V0dGVyU2l6ZV0sIGEuaSk7XG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFNpemUoYi5lbGVtZW50LCBiLnNpemUsIHBhaXJbYkd1dHRlclNpemVdLCBiLmkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXN0cm95KHByZXNlcnZlU3R5bGVzLCBwcmVzZXJ2ZUd1dHRlcikge1xuICAgICAgICBwYWlycy5mb3JFYWNoKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgICAgICBpZiAocHJlc2VydmVHdXR0ZXIgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBwYWlyLnBhcmVudC5yZW1vdmVDaGlsZChwYWlyLmd1dHRlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhaXIuZ3V0dGVyW3JlbW92ZUV2ZW50TGlzdGVuZXJdKFxuICAgICAgICAgICAgICAgICAgICAnbW91c2Vkb3duJyxcbiAgICAgICAgICAgICAgICAgICAgcGFpcltndXR0ZXJTdGFydERyYWdnaW5nXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcGFpci5ndXR0ZXJbcmVtb3ZlRXZlbnRMaXN0ZW5lcl0oXG4gICAgICAgICAgICAgICAgICAgICd0b3VjaHN0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgcGFpcltndXR0ZXJTdGFydERyYWdnaW5nXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmVzZXJ2ZVN0eWxlcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGVsZW1lbnRTdHlsZShcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uLFxuICAgICAgICAgICAgICAgICAgICBwYWlyLmEuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgcGFpclthR3V0dGVyU2l6ZV1cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc3R5bGUpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbcGFpci5hXS5lbGVtZW50LnN0eWxlW3Byb3BdID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzW3BhaXIuYl0uZWxlbWVudC5zdHlsZVtwcm9wXSA9ICcnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzZXRTaXplczogc2V0U2l6ZXMsXG4gICAgICAgIGdldFNpemVzOiBnZXRTaXplcyxcbiAgICAgICAgY29sbGFwc2U6IGZ1bmN0aW9uIGNvbGxhcHNlKGkpIHtcbiAgICAgICAgICAgIGFkanVzdFRvTWluKGVsZW1lbnRzW2ldKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveTogZGVzdHJveSxcbiAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgIHBhaXJzOiBwYWlycyxcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTcGxpdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/split.js/dist/split.es.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/vendor/Onix/js/codeEditor/grapeCodeEditor.js");
/******/ 	
/******/ })()
;