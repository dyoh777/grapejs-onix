/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/vendor/Onix/js/codeEditor/code-editor/index.js":
/*!******************************************************************!*\
  !*** ./resources/vendor/Onix/js/codeEditor/code-editor/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CodeEditor\": () => (/* binding */ CodeEditor)\n/* harmony export */ });\n/* harmony import */ var split_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! split.js */ \"./node_modules/split.js/dist/split.es.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n//Original work Copyright (c) 2018, Duarte Henriques, https://github.com/portablemind/grapesjs-code-editor\n//Modified work Copyright (c) 2020, Brendon Ngirazi,\n//All rights reserved.\n\nvar CodeEditor = /*#__PURE__*/function () {\n  function CodeEditor(editor, opts) {\n    _classCallCheck(this, CodeEditor);\n\n    this.editor = editor;\n    this.$ = editor.$;\n    this.pfx = editor.getConfig(\"stylePrefix\");\n    this.opts = opts;\n    this.canvas = this.findWithinEditor(\".\".concat(this.pfx, \"cv-canvas\"));\n    this.panelViews = opts.appendTo ? this.$(opts.appendTo) : this.findWithinEditor(\".\".concat(this.pfx, \"pn-\").concat(opts.panelId));\n    this.isShowing = true;\n  }\n\n  _createClass(CodeEditor, [{\n    key: \"findPanel\",\n    value: function findPanel() {\n      var pn = this.editor.Panels;\n      var id = this.opts.panelId;\n      var panel = pn.getPanel(id) || pn.addPanel({\n        id: id\n      });\n      return panel;\n    }\n  }, {\n    key: \"findWithinEditor\",\n    value: function findWithinEditor(selector) {\n      return this.$(selector, this.editor.getEl());\n    }\n  }, {\n    key: \"buildCodeEditor\",\n    value: function buildCodeEditor(type) {\n      var editor = this.editor,\n          opts = this.opts;\n      return editor.CodeManager.createViewer(_objectSpread({\n        codeName: type === \"html\" ? \"htmlmixed\" : \"css\",\n        theme: \"hopscotch\",\n        readOnly: 0,\n        autoBeautify: 1,\n        autoCloseTags: 1,\n        autoCloseBrackets: 1,\n        styleActiveLine: 1,\n        smartIndent: 1\n      }, opts.codeViewOptions));\n    }\n  }, {\n    key: \"buildSection\",\n    value: function buildSection(type, codeViewer) {\n      var $ = this.$,\n          pfx = this.pfx,\n          opts = this.opts;\n      var section = $(\"<section></section>\");\n      var btnText = type === \"html\" ? opts.htmlBtnText : opts.cssBtnText;\n      var cleanCssBtn = opts.cleanCssBtn && type === \"css\" ? \"<button class=\\\"cp-delete-\".concat(type, \" \").concat(pfx, \"btn-prim\\\">\").concat(opts.cleanCssBtnText, \"</button>\") : \"\";\n      section.append($(\"\\n            <div class=\\\"codepanel-separator\\\">\\n                <div class=\\\"codepanel-label\\\">\".concat(type, \"</div>\\n                <div class=\\\"cp-btn-container\\\">\\n                    \").concat(cleanCssBtn, \"\\n                    <button class=\\\"cp-apply-\").concat(type, \" \").concat(pfx, \"btn-prim\\\">\").concat(btnText, \"</button>\\n                </div>\\n            </div>\")));\n      var codeViewerEl = codeViewer.getElement();\n      codeViewerEl.style.height = \"calc(100% - 30px)\";\n      section.append(codeViewerEl);\n      this.codePanel.append(section);\n      return section.get(0);\n    }\n  }, {\n    key: \"buildCodePanel\",\n    value: function buildCodePanel() {\n      var _this = this;\n\n      var $ = this.$,\n          editor = this.editor;\n      var panel = this.opts.panelId ? this.findPanel() : 0;\n      this.codePanel = $(\"<div></div>\");\n      this.codePanel.addClass(\"code-panel\");\n      this.htmlCodeEditor = this.buildCodeEditor(\"html\");\n      this.cssCodeEditor = this.buildCodeEditor(\"css\");\n      var sections = [this.buildSection(\"html\", this.htmlCodeEditor), this.buildSection(\"css\", this.cssCodeEditor)];\n      panel && !this.opts.appendTo && panel.set(\"appendContent\", this.codePanel).trigger(\"change:appendContent\");\n      this.opts.appendTo && $(this.opts.appendTo).append(this.codePanel);\n      this.updateEditorContents();\n      this.codePanel.find(\".cp-apply-html\").on(\"click\", this.updateHtml.bind(this));\n      this.codePanel.find(\".cp-apply-css\").on(\"click\", this.updateCss.bind(this));\n      this.opts.cleanCssBtn && this.codePanel.find(\".cp-delete-css\").on(\"click\", this.deleteSelectedCss.bind(this));\n      (0,split_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(sections, {\n        direction: \"vertical\",\n        sizes: [50, 50],\n        minSize: 100,\n        gutterSize: 1,\n        onDragEnd: this.refreshEditors.bind(this)\n      });\n      editor.on(\"component:update\", function (model) {\n        return _this.updateEditorContents();\n      });\n    }\n  }, {\n    key: \"showCodePanel\",\n    value: function showCodePanel() {\n      this.isShowing = true;\n      this.updateEditorContents();\n      this.codePanel.css(\"display\", \"block\"); // make sure editor is aware of width change after the 300ms effect ends\n\n      setTimeout(this.refreshEditors.bind(this), 320);\n      if (this.opts.preserveWidth) return;\n      this.panelViews.css(\"width\", this.opts.openState.pn);\n      this.canvas.css(\"width\", this.opts.openState.cv);\n    }\n  }, {\n    key: \"hideCodePanel\",\n    value: function hideCodePanel() {\n      if (this.codePanel) this.codePanel.css(\"display\", \"none\");\n      this.isShowing = false;\n      if (this.opts.preserveWidth) return;\n      this.panelViews.css(\"width\", this.opts.closedState.pn);\n      this.canvas.css(\"width\", this.opts.closedState.cv);\n    }\n  }, {\n    key: \"refreshEditors\",\n    value: function refreshEditors() {\n      this.htmlCodeEditor.refresh();\n      this.cssCodeEditor.refresh();\n    }\n  }, {\n    key: \"updateHtml\",\n    value: function updateHtml(e) {\n      e === null || e === void 0 ? void 0 : e.preventDefault();\n      var editor = this.editor,\n          component = this.component;\n      var htmlCode = this.htmlCodeEditor.getContent().trim();\n      if (!htmlCode || htmlCode === this.previousHtmlCode) return;\n      this.previousHtmlCode = htmlCode;\n      var idStyles = \"\";\n      this.cssCodeEditor.getContent().split(/(?<=}\\n)/g).forEach(function (rule) {\n        if (/^#/.test(rule)) idStyles += rule;\n      });\n      htmlCode += \"<style>\".concat(idStyles, \"</style>\");\n      editor.select(component.replaceWith(htmlCode));\n    }\n  }, {\n    key: \"updateCss\",\n    value: function updateCss(e) {\n      e === null || e === void 0 ? void 0 : e.preventDefault();\n      var cssCode = this.cssCodeEditor.getContent().trim();\n      if (!cssCode || cssCode === this.previousCssCode) return;\n      this.parseRemove(cssCode);\n      this.previousCssCode = cssCode;\n      this.editor.Components.addComponent(\"<style>\".concat(cssCode, \"</style>\"));\n    }\n  }, {\n    key: \"deleteSelectedCss\",\n    value: function deleteSelectedCss(e) {\n      var _this2 = this;\n\n      e === null || e === void 0 ? void 0 : e.preventDefault();\n      var selections = this.cssCodeEditor.editor.getSelections();\n      selections.forEach(function (selection) {\n        return _this2.parseRemove(selection);\n      });\n      this.cssCodeEditor.editor.deleteH();\n    }\n  }, {\n    key: \"parseRemove\",\n    value: function parseRemove(removeCss) {\n      var _this3 = this;\n\n      var editor = this.editor;\n      var cssc = editor.CssComposer;\n      var allRules = cssc.getAll();\n      editor.Parser.parseCss(removeCss).forEach(function (p) {\n        var config = {\n          singleAtRule: p.singleAtRule,\n          atRuleType: p.atRuleType,\n          mediaText: p.mediaText,\n          state: p.state\n        };\n        p.selectors.length && p.selectors.forEach(function (selector) {\n          _this3.removeSelector(selector, allRules, cssc, config);\n        });\n        p.selectorsAdd && p.selectorsAdd.split(\", \").forEach(function (selector) {\n          _this3.removeSelector(selector, allRules, cssc, config);\n        });\n      });\n    }\n  }, {\n    key: \"removeSelector\",\n    value: function removeSelector(rule, allRules, cssc) {\n      var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var singleAtRule = opts.singleAtRule,\n          atRuleType = opts.atRuleType,\n          mediaText = opts.mediaText,\n          state = opts.state;\n      var toRemove = allRules.filter(function (r) {\n        if (atRuleType && mediaText) return function (r) {\n          return r.get(\"atRuleType\") == atRuleType && r.get(\"mediaText\") == mediaText;\n        };else if (atRuleType && singleAtRule) return function (r) {\n          return r.get(\"atRuleType\") == atRuleType && r.get(\"singleAtRule\") == singleAtRule;\n        };else if (state) return r == cssc.getRule(\"\".concat(rule, \":\").concat(state));\n        return r == cssc.getRule(rule);\n      });\n      allRules.remove(toRemove);\n    }\n  }, {\n    key: \"updateEditorContents\",\n    value: function updateEditorContents() {\n      if (!this.isShowing) return;\n      this.component = this.editor.getSelected();\n\n      if (this.component) {\n        this.htmlCodeEditor.setContent(this.getComponentHtml(this.component));\n        this.cssCodeEditor.setContent(this.editor.CodeManager.getCode(this.component, \"css\", {\n          cssc: this.editor.CssComposer\n        }));\n      }\n    }\n  }, {\n    key: \"getComponentHtml\",\n    value: function getComponentHtml(component) {\n      var pfx = this.pfx,\n          opts = this.opts;\n      var result = \"\";\n      var componentEl = component.getEl();\n      !opts.clearData && componentEl.classList.remove(\"\".concat(pfx, \"selected\"));\n      var html = opts.clearData ? component.toHTML() : componentEl.id === \"wrapper\" ? componentEl.innerHTML : componentEl.outerHTML;\n      !opts.clearData && componentEl.classList.add(\"\".concat(pfx, \"selected\"));\n      result += html;\n      var js = opts.editJs ? component.getScriptString() : \"\";\n      result += js ? \"<script>\".concat(js, \"</script>\") : \"\";\n      return result;\n    }\n  }]);\n\n  return CodeEditor;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvdmVuZG9yL09uaXgvanMvY29kZUVkaXRvci9jb2RlLWVkaXRvci9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRU8sSUFBTUMsVUFBYjtBQUNJLHNCQUFZQyxNQUFaLEVBQW9CQyxJQUFwQixFQUEwQjtBQUFBOztBQUN0QixTQUFLRCxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxTQUFLRSxDQUFMLEdBQVNGLE1BQU0sQ0FBQ0UsQ0FBaEI7QUFDQSxTQUFLQyxHQUFMLEdBQVdILE1BQU0sQ0FBQ0ksU0FBUCxDQUFpQixhQUFqQixDQUFYO0FBQ0EsU0FBS0gsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBS0ksTUFBTCxHQUFjLEtBQUtDLGdCQUFMLFlBQTBCLEtBQUtILEdBQS9CLGVBQWQ7QUFDQSxTQUFLSSxVQUFMLEdBQWtCTixJQUFJLENBQUNPLFFBQUwsR0FDWixLQUFLTixDQUFMLENBQU9ELElBQUksQ0FBQ08sUUFBWixDQURZLEdBRVosS0FBS0YsZ0JBQUwsWUFBMEIsS0FBS0gsR0FBL0IsZ0JBQXdDRixJQUFJLENBQUNRLE9BQTdDLEVBRk47QUFHQSxTQUFLQyxTQUFMLEdBQWlCLElBQWpCO0FBQ0g7O0FBWEw7QUFBQTtBQUFBLFdBYUkscUJBQVk7QUFDUixVQUFNQyxFQUFFLEdBQUcsS0FBS1gsTUFBTCxDQUFZWSxNQUF2QjtBQUNBLFVBQU1DLEVBQUUsR0FBRyxLQUFLWixJQUFMLENBQVVRLE9BQXJCO0FBQ0EsVUFBTUssS0FBSyxHQUFHSCxFQUFFLENBQUNJLFFBQUgsQ0FBWUYsRUFBWixLQUFtQkYsRUFBRSxDQUFDSyxRQUFILENBQVk7QUFBRUgsUUFBQUEsRUFBRSxFQUFGQTtBQUFGLE9BQVosQ0FBakM7QUFDQSxhQUFPQyxLQUFQO0FBQ0g7QUFsQkw7QUFBQTtBQUFBLFdBb0JJLDBCQUFpQkcsUUFBakIsRUFBMkI7QUFDdkIsYUFBTyxLQUFLZixDQUFMLENBQU9lLFFB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QUFDQSxVQUFNQyxXQUFXLEdBQUdoRCxTQUFTLENBQUMzRCxLQUFWLEVBQXBCO0FBRUEsT0FBQ2pCLElBQUksQ0FBQzZILFNBQU4sSUFBbUJELFdBQVcsQ0FBQ0UsU0FBWixDQUFzQlIsTUFBdEIsV0FBZ0NwSCxHQUFoQyxjQUFuQjtBQUNBLFVBQU02SCxJQUFJLEdBQUcvSCxJQUFJLENBQUM2SCxTQUFMLEdBQ1BqRCxTQUFTLENBQUNvRCxNQUFWLEVBRE8sR0FFUEosV0FBVyxDQUFDaEgsRUFBWixLQUFtQixTQUFuQixHQUNBZ0gsV0FBVyxDQUFDSyxTQURaLEdBRUFMLFdBQVcsQ0FBQ00sU0FKbEI7QUFLQSxPQUFDbEksSUFBSSxDQUFDNkgsU0FBTixJQUFtQkQsV0FBVyxDQUFDRSxTQUFaLENBQXNCSyxHQUF0QixXQUE2QmpJLEdBQTdCLGNBQW5CO0FBQ0F5SCxNQUFBQSxNQUFNLElBQUlJLElBQVY7QUFFQSxVQUFNSyxFQUFFLEdBQUdwSSxJQUFJLENBQUNxSSxNQUFMLEdBQWN6RCxTQUFTLENBQUMwRCxlQUFWLEVBQWQsR0FBNEMsRUFBdkQ7QUFDQVgsTUFBQUEsTUFBTSxJQUFJUyxFQUFFLHFCQUFjQSxFQUFkLGlCQUE4QixFQUExQztBQUVBLGFBQU9ULE1BQVA7QUFDSDtBQXhQTDs7QUFBQTtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3ZlbmRvci9Pbml4L2pzL2NvZGVFZGl0b3IvY29kZS1lZGl0b3IvaW5kZXguanM/YTJjMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL09yaWdpbmFsIHdvcmsgQ29weXJpZ2h0IChjKSAyMDE4LCBEdWFydGUgSGVucmlxdWVzLCBodHRwczovL2dpdGh1Yi5jb20vcG9ydGFibGVtaW5kL2dyYXBlc2pzLWNvZGUtZWRpdG9yXHJcbi8vTW9kaWZpZWQgd29yayBDb3B5cmlnaHQgKGMpIDIwMjAsIEJyZW5kb24gTmdpcmF6aSxcclxuLy9BbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5cclxuaW1wb3J0IFNwbGl0IGZyb20gXCJzcGxpdC5qc1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIENvZGVFZGl0b3Ige1xyXG4gICAgY29uc3RydWN0b3IoZWRpdG9yLCBvcHRzKSB7XHJcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XHJcbiAgICAgICAgdGhpcy4kID0gZWRpdG9yLiQ7XHJcbiAgICAgICAgdGhpcy5wZnggPSBlZGl0b3IuZ2V0Q29uZmlnKFwic3R5bGVQcmVmaXhcIik7XHJcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcclxuICAgICAgICB0aGlzLmNhbnZhcyA9IHRoaXMuZmluZFdpdGhpbkVkaXRvcihgLiR7dGhpcy5wZnh9Y3YtY2FudmFzYCk7XHJcbiAgICAgICAgdGhpcy5wYW5lbFZpZXdzID0gb3B0cy5hcHBlbmRUb1xyXG4gICAgICAgICAgICA/IHRoaXMuJChvcHRzLmFwcGVuZFRvKVxyXG4gICAgICAgICAgICA6IHRoaXMuZmluZFdpdGhpbkVkaXRvcihgLiR7dGhpcy5wZnh9cG4tJHtvcHRzLnBhbmVsSWR9YCk7XHJcbiAgICAgICAgdGhpcy5pc1Nob3dpbmcgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZpbmRQYW5lbCgpIHtcclxuICAgICAgICBjb25zdCBwbiA9IHRoaXMuZWRpdG9yLlBhbmVscztcclxuICAgICAgICBjb25zdCBpZCA9IHRoaXMub3B0cy5wYW5lbElkO1xyXG4gICAgICAgIGNvbnN0IHBhbmVsID0gcG4uZ2V0UGFuZWwoaWQpIHx8IHBuLmFkZFBhbmVsKHsgaWQgfSk7XHJcbiAgICAgICAgcmV0dXJuIHBhbmVsO1xyXG4gICAgfVxyXG5cclxuICAgIGZpbmRXaXRoaW5FZGl0b3Ioc2VsZWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4kKHNlbGVjdG9yLCB0aGlzLmVkaXRvci5nZXRFbCgpKTtcclxuICAgIH1cclxuXHJcbiAgICBidWlsZENvZGVFZGl0b3IodHlwZSkge1xyXG4gICAgICAgIGNvbnN0IHsgZWRpdG9yLCBvcHRzIH0gPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gZWRpdG9yLkNvZGVNYW5hZ2VyLmNyZWF0ZVZpZXdlcih7XHJcbiAgICAgICAgICAgIGNvZGVOYW1lOiB0eXBlID09PSBcImh0bWxcIiA/IFwiaHRtbG1peGVkXCIgOiBcImNzc1wiLFxyXG4gICAgICAgICAgICB0aGVtZTogXCJob3BzY290Y2hcIixcclxuICAgICAgICAgICAgcmVhZE9ubHk6IDAsXHJcbiAgICAgICAgICAgIGF1dG9CZWF1dGlmeTogMSxcclxuICAgICAgICAgICAgYXV0b0Nsb3NlVGFnczogMSxcclxuICAgICAgICAgICAgYXV0b0Nsb3NlQnJhY2tldHM6IDEsXHJcbiAgICAgICAgICAgIHN0eWxlQWN0aXZlTGluZTogMSxcclxuICAgICAgICAgICAgc21hcnRJbmRlbnQ6IDEsXHJcbiAgICAgICAgICAgIC4uLm9wdHMuY29kZVZpZXdPcHRpb25zLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGJ1aWxkU2VjdGlvbih0eXBlLCBjb2RlVmlld2VyKSB7XHJcbiAgICAgICAgY29uc3QgeyAkLCBwZngsIG9wdHMgfSA9IHRoaXM7XHJcbiAgICAgICAgY29uc3Qgc2VjdGlvbiA9ICQoXCI8c2VjdGlvbj48L3NlY3Rpb24+XCIpO1xyXG4gICAgICAgIGNvbnN0IGJ0blRleHQgPSB0eXBlID09PSBcImh0bWxcIiA/IG9wdHMuaHRtbEJ0blRleHQgOiBvcHRzLmNzc0J0blRleHQ7XHJcbiAgICAgICAgY29uc3QgY2xlYW5Dc3NCdG4gPVxyXG4gICAgICAgICAgICBvcHRzLmNsZWFuQ3NzQnRuICYmIHR5cGUgPT09IFwiY3NzXCJcclxuICAgICAgICAgICAgICAgID8gYDxidXR0b24gY2xhc3M9XCJjcC1kZWxldGUtJHt0eXBlfSAke3BmeH1idG4tcHJpbVwiPiR7b3B0cy5jbGVhbkNzc0J0blRleHR9PC9idXR0b24+YFxyXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xyXG4gICAgICAgIHNlY3Rpb24uYXBwZW5kKFxyXG4gICAgICAgICAgICAkKGBcclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvZGVwYW5lbC1zZXBhcmF0b3JcIj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2RlcGFuZWwtbGFiZWxcIj4ke3R5cGV9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY3AtYnRuLWNvbnRhaW5lclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICR7Y2xlYW5Dc3NCdG59XHJcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImNwLWFwcGx5LSR7dHlwZX0gJHtwZnh9YnRuLXByaW1cIj4ke2J0blRleHR9PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+YClcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnN0IGNvZGVWaWV3ZXJFbCA9IGNvZGVWaWV3ZXIuZ2V0RWxlbWVudCgpO1xyXG4gICAgICAgIGNvZGVWaWV3ZXJFbC5zdHlsZS5oZWlnaHQgPSBcImNhbGMoMTAwJSAtIDMwcHgpXCI7XHJcbiAgICAgICAgc2VjdGlvbi5hcHBlbmQoY29kZVZpZXdlckVsKTtcclxuICAgICAgICB0aGlzLmNvZGVQYW5lbC5hcHBlbmQoc2VjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIHNlY3Rpb24uZ2V0KDApO1xyXG4gICAgfVxyXG5cclxuICAgIGJ1aWxkQ29kZVBhbmVsKCkge1xyXG4gICAgICAgIGNvbnN0IHsgJCwgZWRpdG9yIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHBhbmVsID0gdGhpcy5vcHRzLnBhbmVsSWQgPyB0aGlzLmZpbmRQYW5lbCgpIDogMDtcclxuICAgICAgICB0aGlzLmNvZGVQYW5lbCA9ICQoXCI8ZGl2PjwvZGl2PlwiKTtcclxuICAgICAgICB0aGlzLmNvZGVQYW5lbC5hZGRDbGFzcyhcImNvZGUtcGFuZWxcIik7XHJcblxyXG4gICAgICAgIHRoaXMuaHRtbENvZGVFZGl0b3IgPSB0aGlzLmJ1aWxkQ29kZUVkaXRvcihcImh0bWxcIik7XHJcbiAgICAgICAgdGhpcy5jc3NDb2RlRWRpdG9yID0gdGhpcy5idWlsZENvZGVFZGl0b3IoXCJjc3NcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IHNlY3Rpb25zID0gW1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkU2VjdGlvbihcImh0bWxcIiwgdGhpcy5odG1sQ29kZUVkaXRvciksXHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRTZWN0aW9uKFwiY3NzXCIsIHRoaXMuY3NzQ29kZUVkaXRvciksXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgcGFuZWwgJiZcclxuICAgICAgICAgICAgIXRoaXMub3B0cy5hcHBlbmRUbyAmJlxyXG4gICAgICAgICAgICBwYW5lbFxyXG4gICAgICAgICAgICAgICAgLnNldChcImFwcGVuZENvbnRlbnRcIiwgdGhpcy5jb2RlUGFuZWwpXHJcbiAgICAgICAgICAgICAgICAudHJpZ2dlcihcImNoYW5nZTphcHBlbmRDb250ZW50XCIpO1xyXG4gICAgICAgIHRoaXMub3B0cy5hcHBlbmRUbyAmJiAkKHRoaXMub3B0cy5hcHBlbmRUbykuYXBwZW5kKHRoaXMuY29kZVBhbmVsKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUVkaXRvckNvbnRlbnRzKCk7XHJcblxyXG4gICAgICAgIHRoaXMuY29kZVBhbmVsXHJcbiAgICAgICAgICAgIC5maW5kKFwiLmNwLWFwcGx5LWh0bWxcIilcclxuICAgICAgICAgICAgLm9uKFwiY2xpY2tcIiwgdGhpcy51cGRhdGVIdG1sLmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICB0aGlzLmNvZGVQYW5lbFxyXG4gICAgICAgICAgICAuZmluZChcIi5jcC1hcHBseS1jc3NcIilcclxuICAgICAgICAgICAgLm9uKFwiY2xpY2tcIiwgdGhpcy51cGRhdGVDc3MuYmluZCh0aGlzKSk7XHJcblxyXG4gICAgICAgIHRoaXMub3B0cy5jbGVhbkNzc0J0biAmJlxyXG4gICAgICAgICAgICB0aGlzLmNvZGVQYW5lbFxyXG4gICAgICAgICAgICAgICAgLmZpbmQoXCIuY3AtZGVsZXRlLWNzc1wiKVxyXG4gICAgICAgICAgICAgICAgLm9uKFwiY2xpY2tcIiwgdGhpcy5kZWxldGVTZWxlY3RlZENzcy5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgU3BsaXQoc2VjdGlvbnMsIHtcclxuICAgICAgICAgICAgZGlyZWN0aW9uOiBcInZlcnRpY2FsXCIsXHJcbiAgICAgICAgICAgIHNpemVzOiBbNTAsIDUwXSxcclxuICAgICAgICAgICAgbWluU2l6ZTogMTAwLFxyXG4gICAgICAgICAgICBndXR0ZXJTaXplOiAxLFxyXG4gICAgICAgICAgICBvbkRyYWdFbmQ6IHRoaXMucmVmcmVzaEVkaXRvcnMuYmluZCh0aGlzKSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZWRpdG9yLm9uKFwiY29tcG9uZW50OnVwZGF0ZVwiLCAobW9kZWwpID0+IHRoaXMudXBkYXRlRWRpdG9yQ29udGVudHMoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2hvd0NvZGVQYW5lbCgpIHtcclxuICAgICAgICB0aGlzLmlzU2hvd2luZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy51cGRhdGVFZGl0b3JDb250ZW50cygpO1xyXG4gICAgICAgIHRoaXMuY29kZVBhbmVsLmNzcyhcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcclxuICAgICAgICAvLyBtYWtlIHN1cmUgZWRpdG9yIGlzIGF3YXJlIG9mIHdpZHRoIGNoYW5nZSBhZnRlciB0aGUgMzAwbXMgZWZmZWN0IGVuZHNcclxuICAgICAgICBzZXRUaW1lb3V0KHRoaXMucmVmcmVzaEVkaXRvcnMuYmluZCh0aGlzKSwgMzIwKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMub3B0cy5wcmVzZXJ2ZVdpZHRoKSByZXR1cm47XHJcblxyXG4gICAgICAgIHRoaXMucGFuZWxWaWV3cy5jc3MoXCJ3aWR0aFwiLCB0aGlzLm9wdHMub3BlblN0YXRlLnBuKTtcclxuICAgICAgICB0aGlzLmNhbnZhcy5jc3MoXCJ3aWR0aFwiLCB0aGlzLm9wdHMub3BlblN0YXRlLmN2KTtcclxuICAgIH1cclxuXHJcbiAgICBoaWRlQ29kZVBhbmVsKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvZGVQYW5lbCkgdGhpcy5jb2RlUGFuZWwuY3NzKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XHJcbiAgICAgICAgdGhpcy5pc1Nob3dpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMub3B0cy5wcmVzZXJ2ZVdpZHRoKSByZXR1cm47XHJcblxyXG4gICAgICAgIHRoaXMucGFuZWxWaWV3cy5jc3MoXCJ3aWR0aFwiLCB0aGlzLm9wdHMuY2xvc2VkU3RhdGUucG4pO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLmNzcyhcIndpZHRoXCIsIHRoaXMub3B0cy5jbG9zZWRTdGF0ZS5jdik7XHJcbiAgICB9XHJcblxyXG4gICAgcmVmcmVzaEVkaXRvcnMoKSB7XHJcbiAgICAgICAgdGhpcy5odG1sQ29kZUVkaXRvci5yZWZyZXNoKCk7XHJcbiAgICAgICAgdGhpcy5jc3NDb2RlRWRpdG9yLnJlZnJlc2goKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVIdG1sKGUpIHtcclxuICAgICAgICBlPy5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGNvbnN0IHsgZWRpdG9yLCBjb21wb25lbnQgfSA9IHRoaXM7XHJcbiAgICAgICAgbGV0IGh0bWxDb2RlID0gdGhpcy5odG1sQ29kZUVkaXRvci5nZXRDb250ZW50KCkudHJpbSgpO1xyXG4gICAgICAgIGlmICghaHRtbENvZGUgfHwgaHRtbENvZGUgPT09IHRoaXMucHJldmlvdXNIdG1sQ29kZSkgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNIdG1sQ29kZSA9IGh0bWxDb2RlO1xyXG5cclxuICAgICAgICBsZXQgaWRTdHlsZXMgPSBcIlwiO1xyXG4gICAgICAgIHRoaXMuY3NzQ29kZUVkaXRvclxyXG4gICAgICAgICAgICAuZ2V0Q29udGVudCgpXHJcbiAgICAgICAgICAgIC5zcGxpdCgvKD88PX1cXG4pL2cpXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKChydWxlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoL14jLy50ZXN0KHJ1bGUpKSBpZFN0eWxlcyArPSBydWxlO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaHRtbENvZGUgKz0gYDxzdHlsZT4ke2lkU3R5bGVzfTwvc3R5bGU+YDtcclxuXHJcbiAgICAgICAgZWRpdG9yLnNlbGVjdChjb21wb25lbnQucmVwbGFjZVdpdGgoaHRtbENvZGUpKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVDc3MoZSkge1xyXG4gICAgICAgIGU/LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgY29uc3QgY3NzQ29kZSA9IHRoaXMuY3NzQ29kZUVkaXRvci5nZXRDb250ZW50KCkudHJpbSgpO1xyXG4gICAgICAgIGlmICghY3NzQ29kZSB8fCBjc3NDb2RlID09PSB0aGlzLnByZXZpb3VzQ3NzQ29kZSkgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMucGFyc2VSZW1vdmUoY3NzQ29kZSk7XHJcbiAgICAgICAgdGhpcy5wcmV2aW91c0Nzc0NvZGUgPSBjc3NDb2RlO1xyXG4gICAgICAgIHRoaXMuZWRpdG9yLkNvbXBvbmVudHMuYWRkQ29tcG9uZW50KGA8c3R5bGU+JHtjc3NDb2RlfTwvc3R5bGU+YCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVsZXRlU2VsZWN0ZWRDc3MoZSkge1xyXG4gICAgICAgIGU/LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9ucyA9IHRoaXMuY3NzQ29kZUVkaXRvci5lZGl0b3IuZ2V0U2VsZWN0aW9ucygpO1xyXG4gICAgICAgIHNlbGVjdGlvbnMuZm9yRWFjaCgoc2VsZWN0aW9uKSA9PiB0aGlzLnBhcnNlUmVtb3ZlKHNlbGVjdGlvbikpO1xyXG4gICAgICAgIHRoaXMuY3NzQ29kZUVkaXRvci5lZGl0b3IuZGVsZXRlSCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHBhcnNlUmVtb3ZlKHJlbW92ZUNzcykge1xyXG4gICAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGNzc2MgPSBlZGl0b3IuQ3NzQ29tcG9zZXI7XHJcbiAgICAgICAgY29uc3QgYWxsUnVsZXMgPSBjc3NjLmdldEFsbCgpO1xyXG4gICAgICAgIGVkaXRvci5QYXJzZXIucGFyc2VDc3MocmVtb3ZlQ3NzKS5mb3JFYWNoKChwKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcclxuICAgICAgICAgICAgICAgIHNpbmdsZUF0UnVsZTogcC5zaW5nbGVBdFJ1bGUsXHJcbiAgICAgICAgICAgICAgICBhdFJ1bGVUeXBlOiBwLmF0UnVsZVR5cGUsXHJcbiAgICAgICAgICAgICAgICBtZWRpYVRleHQ6IHAubWVkaWFUZXh0LFxyXG4gICAgICAgICAgICAgICAgc3RhdGU6IHAuc3RhdGUsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHAuc2VsZWN0b3JzLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAgICAgcC5zZWxlY3RvcnMuZm9yRWFjaCgoc2VsZWN0b3IpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVNlbGVjdG9yKHNlbGVjdG9yLCBhbGxSdWxlcywgY3NzYywgY29uZmlnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBwLnNlbGVjdG9yc0FkZCAmJlxyXG4gICAgICAgICAgICAgICAgcC5zZWxlY3RvcnNBZGQuc3BsaXQoXCIsIFwiKS5mb3JFYWNoKChzZWxlY3RvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU2VsZWN0b3Ioc2VsZWN0b3IsIGFsbFJ1bGVzLCBjc3NjLCBjb25maWcpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlU2VsZWN0b3IocnVsZSwgYWxsUnVsZXMsIGNzc2MsIG9wdHMgPSB7fSkge1xyXG4gICAgICAgIGNvbnN0IHsgc2luZ2xlQXRSdWxlLCBhdFJ1bGVUeXBlLCBtZWRpYVRleHQsIHN0YXRlIH0gPSBvcHRzO1xyXG4gICAgICAgIGNvbnN0IHRvUmVtb3ZlID0gYWxsUnVsZXMuZmlsdGVyKChyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChhdFJ1bGVUeXBlICYmIG1lZGlhVGV4dClcclxuICAgICAgICAgICAgICAgIHJldHVybiAocikgPT5cclxuICAgICAgICAgICAgICAgICAgICByLmdldChcImF0UnVsZVR5cGVcIikgPT0gYXRSdWxlVHlwZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHIuZ2V0KFwibWVkaWFUZXh0XCIpID09IG1lZGlhVGV4dDtcclxuICAgICAgICAgICAgZWxzZSBpZiAoYXRSdWxlVHlwZSAmJiBzaW5nbGVBdFJ1bGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHIpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgci5nZXQoXCJhdFJ1bGVUeXBlXCIpID09IGF0UnVsZVR5cGUgJiZcclxuICAgICAgICAgICAgICAgICAgICByLmdldChcInNpbmdsZUF0UnVsZVwiKSA9PSBzaW5nbGVBdFJ1bGU7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlKSByZXR1cm4gciA9PSBjc3NjLmdldFJ1bGUoYCR7cnVsZX06JHtzdGF0ZX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIHIgPT0gY3NzYy5nZXRSdWxlKHJ1bGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFsbFJ1bGVzLnJlbW92ZSh0b1JlbW92ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlRWRpdG9yQ29udGVudHMoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzU2hvd2luZykgcmV0dXJuO1xyXG5cclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IHRoaXMuZWRpdG9yLmdldFNlbGVjdGVkKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaHRtbENvZGVFZGl0b3Iuc2V0Q29udGVudChcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50SHRtbCh0aGlzLmNvbXBvbmVudClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhpcy5jc3NDb2RlRWRpdG9yLnNldENvbnRlbnQoXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5Db2RlTWFuYWdlci5nZXRDb2RlKHRoaXMuY29tcG9uZW50LCBcImNzc1wiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3NzYzogdGhpcy5lZGl0b3IuQ3NzQ29tcG9zZXIsXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXRDb21wb25lbnRIdG1sKGNvbXBvbmVudCkge1xyXG4gICAgICAgIGNvbnN0IHsgcGZ4LCBvcHRzIH0gPSB0aGlzO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xyXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudEVsID0gY29tcG9uZW50LmdldEVsKCk7XHJcblxyXG4gICAgICAgICFvcHRzLmNsZWFyRGF0YSAmJiBjb21wb25lbnRFbC5jbGFzc0xpc3QucmVtb3ZlKGAke3BmeH1zZWxlY3RlZGApO1xyXG4gICAgICAgIGNvbnN0IGh0bWwgPSBvcHRzLmNsZWFyRGF0YVxyXG4gICAgICAgICAgICA/IGNvbXBvbmVudC50b0hUTUwoKVxyXG4gICAgICAgICAgICA6IGNvbXBvbmVudEVsLmlkID09PSBcIndyYXBwZXJcIlxyXG4gICAgICAgICAgICA/IGNvbXBvbmVudEVsLmlubmVySFRNTFxyXG4gICAgICAgICAgICA6IGNvbXBvbmVudEVsLm91dGVySFRNTDtcclxuICAgICAgICAhb3B0cy5jbGVhckRhdGEgJiYgY29tcG9uZW50RWwuY2xhc3NMaXN0LmFkZChgJHtwZnh9c2VsZWN0ZWRgKTtcclxuICAgICAgICByZXN1bHQgKz0gaHRtbDtcclxuXHJcbiAgICAgICAgY29uc3QganMgPSBvcHRzLmVkaXRKcyA/IGNvbXBvbmVudC5nZXRTY3JpcHRTdHJpbmcoKSA6IFwiXCI7XHJcbiAgICAgICAgcmVzdWx0ICs9IGpzID8gYDxzY3JpcHQ+JHtqc308L3NjcmlwdD5gIDogXCJcIjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufVxyXG4iXSwibmFtZXMiOlsiU3BsaXQiLCJDb2RlRWRpdG9yIiwiZWRpdG9yIiwib3B0cyIsIiQiLCJwZngiLCJnZXRDb25maWciLCJjYW52YXMiLCJmaW5kV2l0aGluRWRpdG9yIiwicGFuZWxWaWV3cyIsImFwcGVuZFRvIiwicGFuZWxJZCIsImlzU2hvd2luZyIsInBuIiwiUGFuZWxzIiwiaWQiLCJwYW5lbCIsImdldFBhbmVsIiwiYWRkUGFuZWwiLCJzZWxlY3RvciIsImdldEVsIiwidHlwZSIsIkNvZGVNYW5hZ2VyIiwiY3JlYXRlVmlld2VyIiwiY29kZU5hbWUiLCJ0aGVtZSIsInJlYWRPbmx5IiwiYXV0b0JlYXV0aWZ5IiwiYXV0b0Nsb3NlVGFncyIsImF1dG9DbG9zZUJyYWNrZXRzIiwic3R5bGVBY3RpdmVMaW5lIiwic21hcnRJbmRlbnQiLCJjb2RlVmlld09wdGlvbnMiLCJjb2RlVmlld2VyIiwic2VjdGlvbiIsImJ0blRleHQiLCJodG1sQnRuVGV4dCIsImNzc0J0blRleHQiLCJjbGVhbkNzc0J0biIsImNsZWFuQ3NzQnRuVGV4dCIsImFwcGVuZCIsImNvZGVWaWV3ZXJFbCIsImdldEVsZW1lbnQiLCJzdHlsZSIsImhlaWdodCIsImNvZGVQYW5lbCIsImdldCIsImZpbmRQYW5lbCIsImFkZENsYXNzIiwiaHRtbENvZGVFZGl0b3IiLCJidWlsZENvZGVFZGl0b3IiLCJjc3NDb2RlRWRpdG9yIiwic2VjdGlvbnMiLCJidWlsZFNlY3Rpb24iLCJzZXQiLCJ0cmlnZ2VyIiwidXBkYXRlRWRpdG9yQ29udGVudHMiLCJmaW5kIiwib24iLCJ1cGRhdGVIdG1sIiwiYmluZCIsInVwZGF0ZUNzcyIsImRlbGV0ZVNlbGVjdGVkQ3NzIiwiZGlyZWN0aW9uIiwic2l6ZXMiLCJtaW5TaXplIiwiZ3V0dGVyU2l6ZSIsIm9uRHJhZ0VuZCIsInJlZnJlc2hFZGl0b3JzIiwibW9kZWwiLCJjc3MiLCJzZXRUaW1lb3V0IiwicHJlc2VydmVXaWR0aCIsIm9wZW5TdGF0ZSIsImN2IiwiY2xvc2VkU3RhdGUiLCJyZWZyZXNoIiwiZSIsInByZXZlbnREZWZhdWx0IiwiY29tcG9uZW50IiwiaHRtbENvZGUiLCJnZXRDb250ZW50IiwidHJpbSIsInByZXZpb3VzSHRtbENvZGUiLCJpZFN0eWxlcyIsInNwbGl0IiwiZm9yRWFjaCIsInJ1bGUiLCJ0ZXN0Iiwic2VsZWN0IiwicmVwbGFjZVdpdGgiLCJjc3NDb2RlIiwicHJldmlvdXNDc3NDb2RlIiwicGFyc2VSZW1vdmUiLCJDb21wb25lbnRzIiwiYWRkQ29tcG9uZW50Iiwic2VsZWN0aW9ucyIsImdldFNlbGVjdGlvbnMiLCJzZWxlY3Rpb24iLCJkZWxldGVIIiwicmVtb3ZlQ3NzIiwiY3NzYyIsIkNzc0NvbXBvc2VyIiwiYWxsUnVsZXMiLCJnZXRBbGwiLCJQYXJzZXIiLCJwYXJzZUNzcyIsInAiLCJjb25maWciLCJzaW5nbGVBdFJ1bGUiLCJhdFJ1bGVUeXBlIiwibWVkaWFUZXh0Iiwic3RhdGUiLCJzZWxlY3RvcnMiLCJsZW5ndGgiLCJyZW1vdmVTZWxlY3RvciIsInNlbGVjdG9yc0FkZCIsInRvUmVtb3ZlIiwiZmlsdGVyIiwiciIsImdldFJ1bGUiLCJyZW1vdmUiLCJnZXRTZWxlY3RlZCIsInNldENvbnRlbnQiLCJnZXRDb21wb25lbnRIdG1sIiwiZ2V0Q29kZSIsInJlc3VsdCIsImNvbXBvbmVudEVsIiwiY2xlYXJEYXRhIiwiY2xhc3NMaXN0IiwiaHRtbCIsInRvSFRNTCIsImlubmVySFRNTCIsIm91dGVySFRNTCIsImFkZCIsImpzIiwiZWRpdEpzIiwiZ2V0U2NyaXB0U3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/vendor/Onix/js/codeEditor/code-editor/index.js\n");

/***/ }),

/***/ "./resources/vendor/Onix/js/codeEditor/commands.js":
/*!*********************************************************!*\
  !*** ./resources/vendor/Onix/js/codeEditor/commands.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _code_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./code-editor */ \"./resources/vendor/Onix/js/codeEditor/code-editor/index.js\");\n/* harmony import */ var _consts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./consts */ \"./resources/vendor/Onix/js/codeEditor/consts.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function (editor, opts) {\n  var cm = editor.Commands;\n  var codeEditor = null;\n  cm.add(_consts__WEBPACK_IMPORTED_MODULE_1__.openCodeStr, {\n    run: function run(editor) {\n      !codeEditor && (codeEditor = new _code_editor__WEBPACK_IMPORTED_MODULE_0__.CodeEditor(editor, opts)) && codeEditor.buildCodePanel();\n      codeEditor.showCodePanel();\n    },\n    stop: function stop(editor) {\n      codeEditor && codeEditor.hideCodePanel();\n    }\n  });\n  cm.add(_consts__WEBPACK_IMPORTED_MODULE_1__.getObject, function (editor, sender) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return new _code_editor__WEBPACK_IMPORTED_MODULE_0__.CodeEditor(editor, _objectSpread(_objectSpread({}, options), opts));\n  });\n  cm.add(_consts__WEBPACK_IMPORTED_MODULE_1__.getConstuctor, function () {\n    return _code_editor__WEBPACK_IMPORTED_MODULE_0__.CodeEditor;\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvdmVuZG9yL09uaXgvanMvY29kZUVkaXRvci9jb21tYW5kcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBRUEsaUVBQWUsVUFBQ0ksTUFBRCxFQUFTQyxJQUFULEVBQWtCO0FBQzdCLE1BQU1DLEVBQUUsR0FBR0YsTUFBTSxDQUFDRyxRQUFsQjtBQUNBLE1BQUlDLFVBQVUsR0FBRyxJQUFqQjtBQUVBRixFQUFBQSxFQUFFLENBQUNHLEdBQUgsQ0FBT1IsZ0RBQVAsRUFBb0I7QUFDaEJTLElBQUFBLEdBQUcsRUFBRSxhQUFBTixNQUFNLEVBQUk7QUFDWCxPQUFDSSxVQUFELEtBQWdCQSxVQUFVLEdBQUcsSUFBSVIsb0RBQUosQ0FBZUksTUFBZixFQUF1QkMsSUFBdkIsQ0FBN0IsS0FBOERHLFVBQVUsQ0FBQ0csY0FBWCxFQUE5RDtBQUNBSCxNQUFBQSxVQUFVLENBQUNJLGFBQVg7QUFDSCxLQUplO0FBS2hCQyxJQUFBQSxJQUFJLEVBQUUsY0FBQVQsTUFBTSxFQUFJO0FBQ1pJLE1BQUFBLFVBQVUsSUFBSUEsVUFBVSxDQUFDTSxhQUFYLEVBQWQ7QUFDSDtBQVBlLEdBQXBCO0FBVUFSLEVBQUFBLEVBQUUsQ0FBQ0csR0FBSCxDQUFPUCw4Q0FBUCxFQUFrQixVQUFDRSxNQUFELEVBQVNXLE1BQVQsRUFBa0M7QUFBQSxRQUFqQkMsT0FBaUIsdUVBQVAsRUFBTztBQUNoRCxXQUFPLElBQUloQixvREFBSixDQUFlSSxNQUFmLGtDQUE0QlksT0FBNUIsR0FBd0NYLElBQXhDLEVBQVA7QUFDSCxHQUZEO0FBSUFDLEVBQUFBLEVBQUUsQ0FBQ0csR0FBSCxDQUFPTixrREFBUCxFQUFzQixZQUFNO0FBQ3hCLFdBQU9ILG9EQUFQO0FBQ0gsR0FGRDtBQUdILENBckJEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3ZlbmRvci9Pbml4L2pzL2NvZGVFZGl0b3IvY29tbWFuZHMuanM/ZTI4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2RlRWRpdG9yIH0gZnJvbSAnLi9jb2RlLWVkaXRvcic7XHJcbmltcG9ydCB7IG9wZW5Db2RlU3RyLCBnZXRPYmplY3QsIGdldENvbnN0dWN0b3IgfSBmcm9tICcuL2NvbnN0cyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCAoZWRpdG9yLCBvcHRzKSA9PiB7XHJcbiAgICBjb25zdCBjbSA9IGVkaXRvci5Db21tYW5kcztcclxuICAgIGxldCBjb2RlRWRpdG9yID0gbnVsbDtcclxuXHJcbiAgICBjbS5hZGQob3BlbkNvZGVTdHIsIHtcclxuICAgICAgICBydW46IGVkaXRvciA9PiB7XHJcbiAgICAgICAgICAgICFjb2RlRWRpdG9yICYmIChjb2RlRWRpdG9yID0gbmV3IENvZGVFZGl0b3IoZWRpdG9yLCBvcHRzKSkgJiYgY29kZUVkaXRvci5idWlsZENvZGVQYW5lbCgpO1xyXG4gICAgICAgICAgICBjb2RlRWRpdG9yLnNob3dDb2RlUGFuZWwoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0b3A6IGVkaXRvciA9PiB7XHJcbiAgICAgICAgICAgIGNvZGVFZGl0b3IgJiYgY29kZUVkaXRvci5oaWRlQ29kZVBhbmVsKCk7XHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIGNtLmFkZChnZXRPYmplY3QsIChlZGl0b3IsIHNlbmRlciwgb3B0aW9ucyA9IHt9KSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2RlRWRpdG9yKGVkaXRvciwgeyAuLi5vcHRpb25zLCAuLi5vcHRzIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY20uYWRkKGdldENvbnN0dWN0b3IsICgpID0+IHtcclxuICAgICAgICByZXR1cm4gQ29kZUVkaXRvcjtcclxuICAgIH0pO1xyXG59Il0sIm5hbWVzIjpbIkNvZGVFZGl0b3IiLCJvcGVuQ29kZVN0ciIsImdldE9iamVjdCIsImdldENvbnN0dWN0b3IiLCJlZGl0b3IiLCJvcHRzIiwiY20iLCJDb21tYW5kcyIsImNvZGVFZGl0b3IiLCJhZGQiLCJydW4iLCJidWlsZENvZGVQYW5lbCIsInNob3dDb2RlUGFuZWwiLCJzdG9wIiwiaGlkZUNvZGVQYW5lbCIsInNlbmRlciIsIm9wdGlvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/vendor/Onix/js/codeEditor/commands.js\n");

/***/ }),

/***/ "./resources/vendor/Onix/js/codeEditor/consts.js":
/*!*******************************************************!*\
  !*** ./resources/vendor/Onix/js/codeEditor/consts.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"openCodeStr\": () => (/* binding */ openCodeStr),\n/* harmony export */   \"getObject\": () => (/* binding */ getObject),\n/* harmony export */   \"getConstuctor\": () => (/* binding */ getConstuctor)\n/* harmony export */ });\nvar openCodeStr = 'open-code',\n    getObject = 'code-editor-object',\n    getConstuctor = 'code-editor-constructor';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvdmVuZG9yL09uaXgvanMvY29kZUVkaXRvci9jb25zdHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQU8sSUFDSEEsV0FBVyxHQUFHLFdBRFg7QUFBQSxJQUVIQyxTQUFTLEdBQUcsb0JBRlQ7QUFBQSxJQUdIQyxhQUFhLEdBQUcseUJBSGIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdmVuZG9yL09uaXgvanMvY29kZUVkaXRvci9jb25zdHMuanM/MWI5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3RcclxuICAgIG9wZW5Db2RlU3RyID0gJ29wZW4tY29kZScsXHJcbiAgICBnZXRPYmplY3QgPSAnY29kZS1lZGl0b3Itb2JqZWN0JyxcclxuICAgIGdldENvbnN0dWN0b3IgPSAnY29kZS1lZGl0b3ItY29uc3RydWN0b3InOyJdLCJuYW1lcyI6WyJvcGVuQ29kZVN0ciIsImdldE9iamVjdCIsImdldENvbnN0dWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/vendor/Onix/js/codeEditor/consts.js\n");

/***/ }),

/***/ "./resources/vendor/Onix/js/codeEditor/grapeCodeEditor.js":
/*!****************************************************************!*\
  !*** ./resources/vendor/Onix/js/codeEditor/grapeCodeEditor.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _commands__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commands */ \"./resources/vendor/Onix/js/codeEditor/commands.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\nwindow.grapesjs.plugins.add('code-editor', function (editor) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var options = _objectSpread(_objectSpread({}, {\n    //Panel to append the code editor\n    panelId: 'views-container',\n    //Append to element instead of views-container\n    appendTo: '',\n    //State when open\n    openState: {\n      cv: '65%',\n      pn: '35%'\n    },\n    //State when closed\n    closedState: {\n      cv: '85%',\n      pn: '15%'\n    },\n    //Allow editing of javascript, set allowScripts to true for this to work\n    editJs: false,\n    //Remove component data eg data-gjs-type=\"...\"\n    clearData: false,\n    //Code viewer options\n    codeViewOptions: {},\n    //Used to remove css from the Selector Manager\n    cleanCssBtn: true,\n    //Save HTML button text\n    htmlBtnText: 'Apply',\n    //Save CSS button text\n    cssBtnText: 'Apply',\n    //Clean CSS button text\n    cleanCssBtnText: 'Delete'\n  }), opts); // Load commands\n\n\n  (0,_commands__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(editor, options);\n}); // export default (editor, opts = {}) => {\n//     const options = {\n//         ...{\n//             //Panel to append the code editor\n//             panelId: 'views-container',\n//             //Append to element instead of views-container\n//             appendTo: '',\n//             //State when open\n//             openState: {\n//                 cv: '65%',\n//                 pn: '35%'\n//             },\n//             //State when closed\n//             closedState: {\n//                 cv: '85%',\n//                 pn: '15%'\n//             },\n//             //Allow editing of javascript, set allowScripts to true for this to work\n//             editJs: false,\n//             //Remove component data eg data-gjs-type=\"...\"\n//             clearData: false,\n//             //Code viewer options\n//             codeViewOptions: {},\n//             //Used to remove css from the Selector Manager\n//             cleanCssBtn: true,\n//             //Save HTML button text\n//             htmlBtnText: 'Apply',\n//             //Save CSS button text\n//             cssBtnText: 'Apply',\n//             //Clean CSS button text\n//             cleanCssBtnText: 'Delete'\n//         },\n//         ...opts\n//     };\n//     // Load commands\n//     commands(editor, options);\n// };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvdmVuZG9yL09uaXgvanMvY29kZUVkaXRvci9ncmFwZUNvZGVFZGl0b3IuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUVBQyxNQUFNLENBQUNDLFFBQVAsQ0FBZ0JDLE9BQWhCLENBQXdCQyxHQUF4QixDQUE0QixhQUE1QixFQUEyQyxVQUFDQyxNQUFELEVBQXVCO0FBQUEsTUFBZEMsSUFBYyx1RUFBUCxFQUFPOztBQUM5RCxNQUFNQyxPQUFPLG1DQUNOO0FBQ0M7QUFDQUMsSUFBQUEsT0FBTyxFQUFFLGlCQUZWO0FBR0M7QUFDQUMsSUFBQUEsUUFBUSxFQUFFLEVBSlg7QUFLQztBQUNBQyxJQUFBQSxTQUFTLEVBQUU7QUFDUEMsTUFBQUEsRUFBRSxFQUFFLEtBREc7QUFFUEMsTUFBQUEsRUFBRSxFQUFFO0FBRkcsS0FOWjtBQVVDO0FBQ0FDLElBQUFBLFdBQVcsRUFBRTtBQUNURixNQUFBQSxFQUFFLEVBQUUsS0FESztBQUVUQyxNQUFBQSxFQUFFLEVBQUU7QUFGSyxLQVhkO0FBZUM7QUFDQUUsSUFBQUEsTUFBTSxFQUFFLEtBaEJUO0FBaUJDO0FBQ0FDLElBQUFBLFNBQVMsRUFBRSxLQWxCWjtBQW1CQztBQUNBQyxJQUFBQSxlQUFlLEVBQUUsRUFwQmxCO0FBcUJDO0FBQ0FDLElBQUFBLFdBQVcsRUFBRSxJQXRCZDtBQXVCQztBQUNBQyxJQUFBQSxXQUFXLEVBQUUsT0F4QmQ7QUF5QkM7QUFDQUMsSUFBQUEsVUFBVSxFQUFFLE9BMUJiO0FBMkJDO0FBQ0FDLElBQUFBLGVBQWUsRUFBRTtBQTVCbEIsR0FETSxHQStCTmQsSUEvQk0sQ0FBYixDQUQ4RCxDQW1DOUQ7OztBQUNBTixFQUFBQSxxREFBUSxDQUFDSyxNQUFELEVBQVNFLE9BQVQsQ0FBUjtBQUNILENBckNELEdBdUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3ZlbmRvci9Pbml4L2pzL2NvZGVFZGl0b3IvZ3JhcGVDb2RlRWRpdG9yLmpzP2VhMmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNvbW1hbmRzIGZyb20gJy4vY29tbWFuZHMnO1xyXG5cclxud2luZG93LmdyYXBlc2pzLnBsdWdpbnMuYWRkKCdjb2RlLWVkaXRvcicsIChlZGl0b3IsIG9wdHMgPSB7fSkgPT4ge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAuLi57XHJcbiAgICAgICAgICAgIC8vUGFuZWwgdG8gYXBwZW5kIHRoZSBjb2RlIGVkaXRvclxyXG4gICAgICAgICAgICBwYW5lbElkOiAndmlld3MtY29udGFpbmVyJyxcclxuICAgICAgICAgICAgLy9BcHBlbmQgdG8gZWxlbWVudCBpbnN0ZWFkIG9mIHZpZXdzLWNvbnRhaW5lclxyXG4gICAgICAgICAgICBhcHBlbmRUbzogJycsXHJcbiAgICAgICAgICAgIC8vU3RhdGUgd2hlbiBvcGVuXHJcbiAgICAgICAgICAgIG9wZW5TdGF0ZToge1xyXG4gICAgICAgICAgICAgICAgY3Y6ICc2NSUnLFxyXG4gICAgICAgICAgICAgICAgcG46ICczNSUnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vU3RhdGUgd2hlbiBjbG9zZWRcclxuICAgICAgICAgICAgY2xvc2VkU3RhdGU6IHtcclxuICAgICAgICAgICAgICAgIGN2OiAnODUlJyxcclxuICAgICAgICAgICAgICAgIHBuOiAnMTUlJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvL0FsbG93IGVkaXRpbmcgb2YgamF2YXNjcmlwdCwgc2V0IGFsbG93U2NyaXB0cyB0byB0cnVlIGZvciB0aGlzIHRvIHdvcmtcclxuICAgICAgICAgICAgZWRpdEpzOiBmYWxzZSxcclxuICAgICAgICAgICAgLy9SZW1vdmUgY29tcG9uZW50IGRhdGEgZWcgZGF0YS1nanMtdHlwZT1cIi4uLlwiXHJcbiAgICAgICAgICAgIGNsZWFyRGF0YTogZmFsc2UsXHJcbiAgICAgICAgICAgIC8vQ29kZSB2aWV3ZXIgb3B0aW9uc1xyXG4gICAgICAgICAgICBjb2RlVmlld09wdGlvbnM6IHt9LFxyXG4gICAgICAgICAgICAvL1VzZWQgdG8gcmVtb3ZlIGNzcyBmcm9tIHRoZSBTZWxlY3RvciBNYW5hZ2VyXHJcbiAgICAgICAgICAgIGNsZWFuQ3NzQnRuOiB0cnVlLFxyXG4gICAgICAgICAgICAvL1NhdmUgSFRNTCBidXR0b24gdGV4dFxyXG4gICAgICAgICAgICBodG1sQnRuVGV4dDogJ0FwcGx5JyxcclxuICAgICAgICAgICAgLy9TYXZlIENTUyBidXR0b24gdGV4dFxyXG4gICAgICAgICAgICBjc3NCdG5UZXh0OiAnQXBwbHknLFxyXG4gICAgICAgICAgICAvL0NsZWFuIENTUyBidXR0b24gdGV4dFxyXG4gICAgICAgICAgICBjbGVhbkNzc0J0blRleHQ6ICdEZWxldGUnXHJcbiAgICAgICAgfSxcclxuICAgICAgICAuLi5vcHRzXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIExvYWQgY29tbWFuZHNcclxuICAgIGNvbW1hbmRzKGVkaXRvciwgb3B0aW9ucyk7XHJcbn0pO1xyXG5cclxuLy8gZXhwb3J0IGRlZmF1bHQgKGVkaXRvciwgb3B0cyA9IHt9KSA9PiB7XHJcbi8vICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4vLyAgICAgICAgIC4uLntcclxuLy8gICAgICAgICAgICAgLy9QYW5lbCB0byBhcHBlbmQgdGhlIGNvZGUgZWRpdG9yXHJcbi8vICAgICAgICAgICAgIHBhbmVsSWQ6ICd2aWV3cy1jb250YWluZXInLFxyXG4vLyAgICAgICAgICAgICAvL0FwcGVuZCB0byBlbGVtZW50IGluc3RlYWQgb2Ygdmlld3MtY29udGFpbmVyXHJcbi8vICAgICAgICAgICAgIGFwcGVuZFRvOiAnJyxcclxuLy8gICAgICAgICAgICAgLy9TdGF0ZSB3aGVuIG9wZW5cclxuLy8gICAgICAgICAgICAgb3BlblN0YXRlOiB7XHJcbi8vICAgICAgICAgICAgICAgICBjdjogJzY1JScsXHJcbi8vICAgICAgICAgICAgICAgICBwbjogJzM1JSdcclxuLy8gICAgICAgICAgICAgfSxcclxuLy8gICAgICAgICAgICAgLy9TdGF0ZSB3aGVuIGNsb3NlZFxyXG4vLyAgICAgICAgICAgICBjbG9zZWRTdGF0ZToge1xyXG4vLyAgICAgICAgICAgICAgICAgY3Y6ICc4NSUnLFxyXG4vLyAgICAgICAgICAgICAgICAgcG46ICcxNSUnXHJcbi8vICAgICAgICAgICAgIH0sXHJcbi8vICAgICAgICAgICAgIC8vQWxsb3cgZWRpdGluZyBvZiBqYXZhc2NyaXB0LCBzZXQgYWxsb3dTY3JpcHRzIHRvIHRydWUgZm9yIHRoaXMgdG8gd29ya1xyXG4vLyAgICAgICAgICAgICBlZGl0SnM6IGZhbHNlLFxyXG4vLyAgICAgICAgICAgICAvL1JlbW92ZSBjb21wb25lbnQgZGF0YSBlZyBkYXRhLWdqcy10eXBlPVwiLi4uXCJcclxuLy8gICAgICAgICAgICAgY2xlYXJEYXRhOiBmYWxzZSxcclxuLy8gICAgICAgICAgICAgLy9Db2RlIHZpZXdlciBvcHRpb25zXHJcbi8vICAgICAgICAgICAgIGNvZGVWaWV3T3B0aW9uczoge30sXHJcbi8vICAgICAgICAgICAgIC8vVXNlZCB0byByZW1vdmUgY3NzIGZyb20gdGhlIFNlbGVjdG9yIE1hbmFnZXJcclxuLy8gICAgICAgICAgICAgY2xlYW5Dc3NCdG46IHRydWUsXHJcbi8vICAgICAgICAgICAgIC8vU2F2ZSBIVE1MIGJ1dHRvbiB0ZXh0XHJcbi8vICAgICAgICAgICAgIGh0bWxCdG5UZXh0OiAnQXBwbHknLFxyXG4vLyAgICAgICAgICAgICAvL1NhdmUgQ1NTIGJ1dHRvbiB0ZXh0XHJcbi8vICAgICAgICAgICAgIGNzc0J0blRleHQ6ICdBcHBseScsXHJcbi8vICAgICAgICAgICAgIC8vQ2xlYW4gQ1NTIGJ1dHRvbiB0ZXh0XHJcbi8vICAgICAgICAgICAgIGNsZWFuQ3NzQnRuVGV4dDogJ0RlbGV0ZSdcclxuLy8gICAgICAgICB9LFxyXG4vLyAgICAgICAgIC4uLm9wdHNcclxuLy8gICAgIH07XHJcblxyXG4vLyAgICAgLy8gTG9hZCBjb21tYW5kc1xyXG4vLyAgICAgY29tbWFuZHMoZWRpdG9yLCBvcHRpb25zKTtcclxuLy8gfTtcclxuIl0sIm5hbWVzIjpbImNvbW1hbmRzIiwid2luZG93IiwiZ3JhcGVzanMiLCJwbHVnaW5zIiwiYWRkIiwiZWRpdG9yIiwib3B0cyIsIm9wdGlvbnMiLCJwYW5lbElkIiwiYXBwZW5kVG8iLCJvcGVuU3RhdGUiLCJjdiIsInBuIiwiY2xvc2VkU3RhdGUiLCJlZGl0SnMiLCJjbGVhckRhdGEiLCJjb2RlVmlld09wdGlvbnMiLCJjbGVhbkNzc0J0biIsImh0bWxCdG5UZXh0IiwiY3NzQnRuVGV4dCIsImNsZWFuQ3NzQnRuVGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/vendor/Onix/js/codeEditor/grapeCodeEditor.js\n");

/***/ }),

/***/ "./node_modules/split.js/dist/split.es.js":
/*!************************************************!*\
  !*** ./node_modules/split.js/dist/split.es.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// The programming goals of Split.js are to deliver readable, understandable and\n// maintainable code, while at the same time manually optimizing for tiny minified file size,\n// browser compatibility without additional requirements\n// and very few assumptions about the user's page layout.\nvar global = typeof window !== 'undefined' ? window : null;\nvar ssr = global === null;\nvar document = !ssr ? global.document : undefined;\n\n// Save a couple long function names that are used frequently.\n// This optimization saves around 400 bytes.\nvar addEventListener = 'addEventListener';\nvar removeEventListener = 'removeEventListener';\nvar getBoundingClientRect = 'getBoundingClientRect';\nvar gutterStartDragging = '_a';\nvar aGutterSize = '_b';\nvar bGutterSize = '_c';\nvar HORIZONTAL = 'horizontal';\nvar NOOP = function () { return false; };\n\n// Helper function determines which prefixes of CSS calc we need.\n// We only need to do this once on startup, when this anonymous function is called.\n//\n// Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\n// http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\nvar calc = ssr\n    ? 'calc'\n    : ((['', '-webkit-', '-moz-', '-o-']\n          .filter(function (prefix) {\n              var el = document.createElement('div');\n              el.style.cssText = \"width:\" + prefix + \"calc(9px)\";\n\n              return !!el.style.length\n          })\n          .shift()) + \"calc\");\n\n// Helper function checks if its argument is a string-like type\nvar isString = function (v) { return typeof v === 'string' || v instanceof String; };\n\n// Helper function allows elements and string selectors to be used\n// interchangeably. In either case an element is returned. This allows us to\n// do `Split([elem1, elem2])` as well as `Split(['#id1', '#id2'])`.\nvar elementOrSelector = function (el) {\n    if (isString(el)) {\n        var ele = document.querySelector(el);\n        if (!ele) {\n            throw new Error((\"Selector \" + el + \" did not match a DOM element\"))\n        }\n        return ele\n    }\n\n    return el\n};\n\n// Helper function gets a property from the properties object, with a default fallback\nvar getOption = function (options, propName, def) {\n    var value = options[propName];\n    if (value !== undefined) {\n        return value\n    }\n    return def\n};\n\nvar getGutterSize = function (gutterSize, isFirst, isLast, gutterAlign) {\n    if (isFirst) {\n        if (gutterAlign === 'end') {\n            return 0\n        }\n        if (gutterAlign === 'center') {\n            return gutterSize / 2\n        }\n    } else if (isLast) {\n        if (gutterAlign === 'start') {\n            return 0\n        }\n        if (gutterAlign === 'center') {\n            return gutterSize / 2\n        }\n    }\n\n    return gutterSize\n};\n\n// Default options\nvar defaultGutterFn = function (i, gutterDirection) {\n    var gut = document.createElement('div');\n    gut.className = \"gutter gutter-\" + gutterDirection;\n    return gut\n};\n\nvar defaultElementStyleFn = function (dim, size, gutSize) {\n    var style = {};\n\n    if (!isString(size)) {\n        style[dim] = calc + \"(\" + size + \"% - \" + gutSize + \"px)\";\n    } else {\n        style[dim] = size;\n    }\n\n    return style\n};\n\nvar defaultGutterStyleFn = function (dim, gutSize) {\n    var obj;\n\n    return (( obj = {}, obj[dim] = (gutSize + \"px\"), obj ));\n};\n\n// The main function to initialize a split. Split.js thinks about each pair\n// of elements as an independant pair. Dragging the gutter between two elements\n// only changes the dimensions of elements in that pair. This is key to understanding\n// how the following functions operate, since each function is bound to a pair.\n//\n// A pair object is shaped like this:\n//\n// {\n//     a: DOM element,\n//     b: DOM element,\n//     aMin: Number,\n//     bMin: Number,\n//     dragging: Boolean,\n//     parent: DOM element,\n//     direction: 'horizontal' | 'vertical'\n// }\n//\n// The basic sequence:\n//\n// 1. Set defaults to something sane. `options` doesn't have to be passed at all.\n// 2. Initialize a bunch of strings based on the direction we're splitting.\n//    A lot of the behavior in the rest of the library is paramatized down to\n//    rely on CSS strings and classes.\n// 3. Define the dragging helper functions, and a few helpers to go with them.\n// 4. Loop through the elements while pairing them off. Every pair gets an\n//    `pair` object and a gutter.\n// 5. Actually size the pair elements, insert gutters and attach event listeners.\nvar Split = function (idsOption, options) {\n    if ( options === void 0 ) options = {};\n\n    if (ssr) { return {} }\n\n    var ids = idsOption;\n    var dimension;\n    var clientAxis;\n    var position;\n    var positionEnd;\n    var clientSize;\n    var elements;\n\n    // Allow HTMLCollection to be used as an argument when supported\n    if (Array.from) {\n        ids = Array.from(ids);\n    }\n\n    // All DOM elements in the split should have a common parent. We can grab\n    // the first elements parent and hope users read the docs because the\n    // behavior will be whacky otherwise.\n    var firstElement = elementOrSelector(ids[0]);\n    var parent = firstElement.parentNode;\n    var parentStyle = getComputedStyle ? getComputedStyle(parent) : null;\n    var parentFlexDirection = parentStyle ? parentStyle.flexDirection : null;\n\n    // Set default options.sizes to equal percentages of the parent element.\n    var sizes = getOption(options, 'sizes') || ids.map(function () { return 100 / ids.length; });\n\n    // Standardize minSize and maxSize to an array if it isn't already.\n    // This allows minSize and maxSize to be passed as a number.\n    var minSize = getOption(options, 'minSize', 100);\n    var minSizes = Array.isArray(minSize) ? minSize : ids.map(function () { return minSize; });\n    var maxSize = getOption(options, 'maxSize', Infinity);\n    var maxSizes = Array.isArray(maxSize) ? maxSize : ids.map(function () { return maxSize; });\n\n    // Get other options\n    var expandToMin = getOption(options, 'expandToMin', false);\n    var gutterSize = getOption(options, 'gutterSize', 10);\n    var gutterAlign = getOption(options, 'gutterAlign', 'center');\n    var snapOffset = getOption(options, 'snapOffset', 30);\n    var dragInterval = getOption(options, 'dragInterval', 1);\n    var direction = getOption(options, 'direction', HORIZONTAL);\n    var cursor = getOption(\n        options,\n        'cursor',\n        direction === HORIZONTAL ? 'col-resize' : 'row-resize'\n    );\n    var gutter = getOption(options, 'gutter', defaultGutterFn);\n    var elementStyle = getOption(\n        options,\n        'elementStyle',\n        defaultElementStyleFn\n    );\n    var gutterStyle = getOption(options, 'gutterStyle', defaultGutterStyleFn);\n\n    // 2. Initialize a bunch of strings based on the direction we're splitting.\n    // A lot of the behavior in the rest of the library is paramatized down to\n    // rely on CSS strings and classes.\n    if (direction === HORIZONTAL) {\n        dimension = 'width';\n        clientAxis = 'clientX';\n        position = 'left';\n        positionEnd = 'right';\n        clientSize = 'clientWidth';\n    } else if (direction === 'vertical') {\n        dimension = 'height';\n        clientAxis = 'clientY';\n        position = 'top';\n        positionEnd = 'bottom';\n        clientSize = 'clientHeight';\n    }\n\n    // 3. Define the dragging helper functions, and a few helpers to go with them.\n    // Each helper is bound to a pair object that contains its metadata. This\n    // also makes it easy to store references to listeners that that will be\n    // added and removed.\n    //\n    // Even though there are no other functions contained in them, aliasing\n    // this to self saves 50 bytes or so since it's used so frequently.\n    //\n    // The pair object saves metadata like dragging state, position and\n    // event listener references.\n\n    function setElementSize(el, size, gutSize, i) {\n        // Split.js allows setting sizes via numbers (ideally), or if you must,\n        // by string, like '300px'. This is less than ideal, because it breaks\n        // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\n        // make sure you calculate the gutter size by hand.\n        var style = elementStyle(dimension, size, gutSize, i);\n\n        Object.keys(style).forEach(function (prop) {\n            // eslint-disable-next-line no-param-reassign\n            el.style[prop] = style[prop];\n        });\n    }\n\n    function setGutterSize(gutterElement, gutSize, i) {\n        var style = gutterStyle(dimension, gutSize, i);\n\n        Object.keys(style).forEach(function (prop) {\n            // eslint-disable-next-line no-param-reassign\n            gutterElement.style[prop] = style[prop];\n        });\n    }\n\n    function getSizes() {\n        return elements.map(function (element) { return element.size; })\n    }\n\n    // Supports touch events, but not multitouch, so only the first\n    // finger `touches[0]` is counted.\n    function getMousePosition(e) {\n        if ('touches' in e) { return e.touches[0][clientAxis] }\n        return e[clientAxis]\n    }\n\n    // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\n    // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\n    // which allows the viewport to be resized without additional logic.\n    // Element a's size is the same as offset. b's size is total size - a size.\n    // Both sizes are calculated from the initial parent percentage,\n    // then the gutter size is subtracted.\n    function adjust(offset) {\n        var a = elements[this.a];\n        var b = elements[this.b];\n        var percentage = a.size + b.size;\n\n        a.size = (offset / this.size) * percentage;\n        b.size = percentage - (offset / this.size) * percentage;\n\n        setElementSize(a.element, a.size, this[aGutterSize], a.i);\n        setElementSize(b.element, b.size, this[bGutterSize], b.i);\n    }\n\n    // drag, where all the magic happens. The logic is really quite simple:\n    //\n    // 1. Ignore if the pair is not dragging.\n    // 2. Get the offset of the event.\n    // 3. Snap offset to min if within snappable range (within min + snapOffset).\n    // 4. Actually adjust each element in the pair to offset.\n    //\n    // ---------------------------------------------------------------------\n    // |    | <- a.minSize               ||              b.minSize -> |    |\n    // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\n    // |    |  |                         ||                        |  |    |\n    // |    |  |                         ||                        |  |    |\n    // ---------------------------------------------------------------------\n    // | <- this.start                                        this.size -> |\n    function drag(e) {\n        var offset;\n        var a = elements[this.a];\n        var b = elements[this.b];\n\n        if (!this.dragging) { return }\n\n        // Get the offset of the event from the first side of the\n        // pair `this.start`. Then offset by the initial position of the\n        // mouse compared to the gutter size.\n        offset =\n            getMousePosition(e) -\n            this.start +\n            (this[aGutterSize] - this.dragOffset);\n\n        if (dragInterval > 1) {\n            offset = Math.round(offset / dragInterval) * dragInterval;\n        }\n\n        // If within snapOffset of min or max, set offset to min or max.\n        // snapOffset buffers a.minSize and b.minSize, so logic is opposite for both.\n        // Include the appropriate gutter sizes to prevent overflows.\n        if (offset <= a.minSize + snapOffset + this[aGutterSize]) {\n            offset = a.minSize + this[aGutterSize];\n        } else if (\n            offset >=\n            this.size - (b.minSize + snapOffset + this[bGutterSize])\n        ) {\n            offset = this.size - (b.minSize + this[bGutterSize]);\n        }\n\n        if (offset >= a.maxSize - snapOffset + this[aGutterSize]) {\n            offset = a.maxSize + this[aGutterSize];\n        } else if (\n            offset <=\n            this.size - (b.maxSize - snapOffset + this[bGutterSize])\n        ) {\n            offset = this.size - (b.maxSize + this[bGutterSize]);\n        }\n\n        // Actually adjust the size.\n        adjust.call(this, offset);\n\n        // Call the drag callback continously. Don't do anything too intensive\n        // in this callback.\n        getOption(options, 'onDrag', NOOP)(getSizes());\n    }\n\n    // Cache some important sizes when drag starts, so we don't have to do that\n    // continously:\n    //\n    // `size`: The total size of the pair. First + second + first gutter + second gutter.\n    // `start`: The leading side of the first element.\n    //\n    // ------------------------------------------------\n    // |      aGutterSize -> |||                      |\n    // |                     |||                      |\n    // |                     |||                      |\n    // |                     ||| <- bGutterSize       |\n    // ------------------------------------------------\n    // | <- start                             size -> |\n    function calculateSizes() {\n        // Figure out the parent size minus padding.\n        var a = elements[this.a].element;\n        var b = elements[this.b].element;\n\n        var aBounds = a[getBoundingClientRect]();\n        var bBounds = b[getBoundingClientRect]();\n\n        this.size =\n            aBounds[dimension] +\n            bBounds[dimension] +\n            this[aGutterSize] +\n            this[bGutterSize];\n        this.start = aBounds[position];\n        this.end = aBounds[positionEnd];\n    }\n\n    function innerSize(element) {\n        // Return nothing if getComputedStyle is not supported (< IE9)\n        // Or if parent element has no layout yet\n        if (!getComputedStyle) { return null }\n\n        var computedStyle = getComputedStyle(element);\n\n        if (!computedStyle) { return null }\n\n        var size = element[clientSize];\n\n        if (size === 0) { return null }\n\n        if (direction === HORIZONTAL) {\n            size -=\n                parseFloat(computedStyle.paddingLeft) +\n                parseFloat(computedStyle.paddingRight);\n        } else {\n            size -=\n                parseFloat(computedStyle.paddingTop) +\n                parseFloat(computedStyle.paddingBottom);\n        }\n\n        return size\n    }\n\n    // When specifying percentage sizes that are less than the computed\n    // size of the element minus the gutter, the lesser percentages must be increased\n    // (and decreased from the other elements) to make space for the pixels\n    // subtracted by the gutters.\n    function trimToMin(sizesToTrim) {\n        // Try to get inner size of parent element.\n        // If it's no supported, return original sizes.\n        var parentSize = innerSize(parent);\n        if (parentSize === null) {\n            return sizesToTrim\n        }\n\n        if (minSizes.reduce(function (a, b) { return a + b; }, 0) > parentSize) {\n            return sizesToTrim\n        }\n\n        // Keep track of the excess pixels, the amount of pixels over the desired percentage\n        // Also keep track of the elements with pixels to spare, to decrease after if needed\n        var excessPixels = 0;\n        var toSpare = [];\n\n        var pixelSizes = sizesToTrim.map(function (size, i) {\n            // Convert requested percentages to pixel sizes\n            var pixelSize = (parentSize * size) / 100;\n            var elementGutterSize = getGutterSize(\n                gutterSize,\n                i === 0,\n                i === sizesToTrim.length - 1,\n                gutterAlign\n            );\n            var elementMinSize = minSizes[i] + elementGutterSize;\n\n            // If element is too smal, increase excess pixels by the difference\n            // and mark that it has no pixels to spare\n            if (pixelSize < elementMinSize) {\n                excessPixels += elementMinSize - pixelSize;\n                toSpare.push(0);\n                return elementMinSize\n            }\n\n            // Otherwise, mark the pixels it has to spare and return it's original size\n            toSpare.push(pixelSize - elementMinSize);\n            return pixelSize\n        });\n\n        // If nothing was adjusted, return the original sizes\n        if (excessPixels === 0) {\n            return sizesToTrim\n        }\n\n        return pixelSizes.map(function (pixelSize, i) {\n            var newPixelSize = pixelSize;\n\n            // While there's still pixels to take, and there's enough pixels to spare,\n            // take as many as possible up to the total excess pixels\n            if (excessPixels > 0 && toSpare[i] - excessPixels > 0) {\n                var takenPixels = Math.min(\n                    excessPixels,\n                    toSpare[i] - excessPixels\n                );\n\n                // Subtract the amount taken for the next iteration\n                excessPixels -= takenPixels;\n                newPixelSize = pixelSize - takenPixels;\n            }\n\n            // Return the pixel size adjusted as a percentage\n            return (newPixelSize / parentSize) * 100\n        })\n    }\n\n    // stopDragging is very similar to startDragging in reverse.\n    function stopDragging() {\n        var self = this;\n        var a = elements[self.a].element;\n        var b = elements[self.b].element;\n\n        if (self.dragging) {\n            getOption(options, 'onDragEnd', NOOP)(getSizes());\n        }\n\n        self.dragging = false;\n\n        // Remove the stored event listeners. This is why we store them.\n        global[removeEventListener]('mouseup', self.stop);\n        global[removeEventListener]('touchend', self.stop);\n        global[removeEventListener]('touchcancel', self.stop);\n        global[removeEventListener]('mousemove', self.move);\n        global[removeEventListener]('touchmove', self.move);\n\n        // Clear bound function references\n        self.stop = null;\n        self.move = null;\n\n        a[removeEventListener]('selectstart', NOOP);\n        a[removeEventListener]('dragstart', NOOP);\n        b[removeEventListener]('selectstart', NOOP);\n        b[removeEventListener]('dragstart', NOOP);\n\n        a.style.userSelect = '';\n        a.style.webkitUserSelect = '';\n        a.style.MozUserSelect = '';\n        a.style.pointerEvents = '';\n\n        b.style.userSelect = '';\n        b.style.webkitUserSelect = '';\n        b.style.MozUserSelect = '';\n        b.style.pointerEvents = '';\n\n        self.gutter.style.cursor = '';\n        self.parent.style.cursor = '';\n        document.body.style.cursor = '';\n    }\n\n    // startDragging calls `calculateSizes` to store the inital size in the pair object.\n    // It also adds event listeners for mouse/touch events,\n    // and prevents selection while dragging so avoid the selecting text.\n    function startDragging(e) {\n        // Right-clicking can't start dragging.\n        if ('button' in e && e.button !== 0) {\n            return\n        }\n\n        // Alias frequently used variables to save space. 200 bytes.\n        var self = this;\n        var a = elements[self.a].element;\n        var b = elements[self.b].element;\n\n        // Call the onDragStart callback.\n        if (!self.dragging) {\n            getOption(options, 'onDragStart', NOOP)(getSizes());\n        }\n\n        // Don't actually drag the element. We emulate that in the drag function.\n        e.preventDefault();\n\n        // Set the dragging property of the pair object.\n        self.dragging = true;\n\n        // Create two event listeners bound to the same pair object and store\n        // them in the pair object.\n        self.move = drag.bind(self);\n        self.stop = stopDragging.bind(self);\n\n        // All the binding. `window` gets the stop events in case we drag out of the elements.\n        global[addEventListener]('mouseup', self.stop);\n        global[addEventListener]('touchend', self.stop);\n        global[addEventListener]('touchcancel', self.stop);\n        global[addEventListener]('mousemove', self.move);\n        global[addEventListener]('touchmove', self.move);\n\n        // Disable selection. Disable!\n        a[addEventListener]('selectstart', NOOP);\n        a[addEventListener]('dragstart', NOOP);\n        b[addEventListener]('selectstart', NOOP);\n        b[addEventListener]('dragstart', NOOP);\n\n        a.style.userSelect = 'none';\n        a.style.webkitUserSelect = 'none';\n        a.style.MozUserSelect = 'none';\n        a.style.pointerEvents = 'none';\n\n        b.style.userSelect = 'none';\n        b.style.webkitUserSelect = 'none';\n        b.style.MozUserSelect = 'none';\n        b.style.pointerEvents = 'none';\n\n        // Set the cursor at multiple levels\n        self.gutter.style.cursor = cursor;\n        self.parent.style.cursor = cursor;\n        document.body.style.cursor = cursor;\n\n        // Cache the initial sizes of the pair.\n        calculateSizes.call(self);\n\n        // Determine the position of the mouse compared to the gutter\n        self.dragOffset = getMousePosition(e) - self.end;\n    }\n\n    // adjust sizes to ensure percentage is within min size and gutter.\n    sizes = trimToMin(sizes);\n\n    // 5. Create pair and element objects. Each pair has an index reference to\n    // elements `a` and `b` of the pair (first and second elements).\n    // Loop through the elements while pairing them off. Every pair gets a\n    // `pair` object and a gutter.\n    //\n    // Basic logic:\n    //\n    // - Starting with the second element `i > 0`, create `pair` objects with\n    //   `a = i - 1` and `b = i`\n    // - Set gutter sizes based on the _pair_ being first/last. The first and last\n    //   pair have gutterSize / 2, since they only have one half gutter, and not two.\n    // - Create gutter elements and add event listeners.\n    // - Set the size of the elements, minus the gutter sizes.\n    //\n    // -----------------------------------------------------------------------\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\n    // |             |                     |                  |              |\n    // |           pair 0                pair 1             pair 2           |\n    // |             |                     |                  |              |\n    // -----------------------------------------------------------------------\n    var pairs = [];\n    elements = ids.map(function (id, i) {\n        // Create the element object.\n        var element = {\n            element: elementOrSelector(id),\n            size: sizes[i],\n            minSize: minSizes[i],\n            maxSize: maxSizes[i],\n            i: i,\n        };\n\n        var pair;\n\n        if (i > 0) {\n            // Create the pair object with its metadata.\n            pair = {\n                a: i - 1,\n                b: i,\n                dragging: false,\n                direction: direction,\n                parent: parent,\n            };\n\n            pair[aGutterSize] = getGutterSize(\n                gutterSize,\n                i - 1 === 0,\n                false,\n                gutterAlign\n            );\n            pair[bGutterSize] = getGutterSize(\n                gutterSize,\n                false,\n                i === ids.length - 1,\n                gutterAlign\n            );\n\n            // if the parent has a reverse flex-direction, switch the pair elements.\n            if (\n                parentFlexDirection === 'row-reverse' ||\n                parentFlexDirection === 'column-reverse'\n            ) {\n                var temp = pair.a;\n                pair.a = pair.b;\n                pair.b = temp;\n            }\n        }\n\n        // Determine the size of the current element. IE8 is supported by\n        // staticly assigning sizes without draggable gutters. Assigns a string\n        // to `size`.\n        //\n        // Create gutter elements for each pair.\n        if (i > 0) {\n            var gutterElement = gutter(i, direction, element.element);\n            setGutterSize(gutterElement, gutterSize, i);\n\n            // Save bound event listener for removal later\n            pair[gutterStartDragging] = startDragging.bind(pair);\n\n            // Attach bound event listener\n            gutterElement[addEventListener](\n                'mousedown',\n                pair[gutterStartDragging]\n            );\n            gutterElement[addEventListener](\n                'touchstart',\n                pair[gutterStartDragging]\n            );\n\n            parent.insertBefore(gutterElement, element.element);\n\n            pair.gutter = gutterElement;\n        }\n\n        setElementSize(\n            element.element,\n            element.size,\n            getGutterSize(\n                gutterSize,\n                i === 0,\n                i === ids.length - 1,\n                gutterAlign\n            ),\n            i\n        );\n\n        // After the first iteration, and we have a pair object, append it to the\n        // list of pairs.\n        if (i > 0) {\n            pairs.push(pair);\n        }\n\n        return element\n    });\n\n    function adjustToMin(element) {\n        var isLast = element.i === pairs.length;\n        var pair = isLast ? pairs[element.i - 1] : pairs[element.i];\n\n        calculateSizes.call(pair);\n\n        var size = isLast\n            ? pair.size - element.minSize - pair[bGutterSize]\n            : element.minSize + pair[aGutterSize];\n\n        adjust.call(pair, size);\n    }\n\n    elements.forEach(function (element) {\n        var computedSize = element.element[getBoundingClientRect]()[dimension];\n\n        if (computedSize < element.minSize) {\n            if (expandToMin) {\n                adjustToMin(element);\n            } else {\n                // eslint-disable-next-line no-param-reassign\n                element.minSize = computedSize;\n            }\n        }\n    });\n\n    function setSizes(newSizes) {\n        var trimmed = trimToMin(newSizes);\n        trimmed.forEach(function (newSize, i) {\n            if (i > 0) {\n                var pair = pairs[i - 1];\n\n                var a = elements[pair.a];\n                var b = elements[pair.b];\n\n                a.size = trimmed[i - 1];\n                b.size = newSize;\n\n                setElementSize(a.element, a.size, pair[aGutterSize], a.i);\n                setElementSize(b.element, b.size, pair[bGutterSize], b.i);\n            }\n        });\n    }\n\n    function destroy(preserveStyles, preserveGutter) {\n        pairs.forEach(function (pair) {\n            if (preserveGutter !== true) {\n                pair.parent.removeChild(pair.gutter);\n            } else {\n                pair.gutter[removeEventListener](\n                    'mousedown',\n                    pair[gutterStartDragging]\n                );\n                pair.gutter[removeEventListener](\n                    'touchstart',\n                    pair[gutterStartDragging]\n                );\n            }\n\n            if (preserveStyles !== true) {\n                var style = elementStyle(\n                    dimension,\n                    pair.a.size,\n                    pair[aGutterSize]\n                );\n\n                Object.keys(style).forEach(function (prop) {\n                    elements[pair.a].element.style[prop] = '';\n                    elements[pair.b].element.style[prop] = '';\n                });\n            }\n        });\n    }\n\n    return {\n        setSizes: setSizes,\n        getSizes: getSizes,\n        collapse: function collapse(i) {\n            adjustToMin(elements[i]);\n        },\n        destroy: destroy,\n        parent: parent,\n        pairs: pairs,\n    }\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Split);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3BsaXQuanMvZGlzdC9zcGxpdC5lcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUVBQXFFLDBCQUEwQjs7QUFFL0Y7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGlCQUFpQjtBQUM3RjtBQUNBLDRFQUE0RSxpQkFBaUI7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLGlEQUFpRCxzQkFBc0I7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDOztBQUVBLDhCQUE4Qjs7QUFFOUI7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLGVBQWU7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLEtBQUssRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zcGxpdC5qcy9kaXN0L3NwbGl0LmVzLmpzPzE5NzAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhlIHByb2dyYW1taW5nIGdvYWxzIG9mIFNwbGl0LmpzIGFyZSB0byBkZWxpdmVyIHJlYWRhYmxlLCB1bmRlcnN0YW5kYWJsZSBhbmRcbi8vIG1haW50YWluYWJsZSBjb2RlLCB3aGlsZSBhdCB0aGUgc2FtZSB0aW1lIG1hbnVhbGx5IG9wdGltaXppbmcgZm9yIHRpbnkgbWluaWZpZWQgZmlsZSBzaXplLFxuLy8gYnJvd3NlciBjb21wYXRpYmlsaXR5IHdpdGhvdXQgYWRkaXRpb25hbCByZXF1aXJlbWVudHNcbi8vIGFuZCB2ZXJ5IGZldyBhc3N1bXB0aW9ucyBhYm91dCB0aGUgdXNlcidzIHBhZ2UgbGF5b3V0LlxudmFyIGdsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogbnVsbDtcbnZhciBzc3IgPSBnbG9iYWwgPT09IG51bGw7XG52YXIgZG9jdW1lbnQgPSAhc3NyID8gZ2xvYmFsLmRvY3VtZW50IDogdW5kZWZpbmVkO1xuXG4vLyBTYXZlIGEgY291cGxlIGxvbmcgZnVuY3Rpb24gbmFtZXMgdGhhdCBhcmUgdXNlZCBmcmVxdWVudGx5LlxuLy8gVGhpcyBvcHRpbWl6YXRpb24gc2F2ZXMgYXJvdW5kIDQwMCBieXRlcy5cbnZhciBhZGRFdmVudExpc3RlbmVyID0gJ2FkZEV2ZW50TGlzdGVuZXInO1xudmFyIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG52YXIgZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID0gJ2dldEJvdW5kaW5nQ2xpZW50UmVjdCc7XG52YXIgZ3V0dGVyU3RhcnREcmFnZ2luZyA9ICdfYSc7XG52YXIgYUd1dHRlclNpemUgPSAnX2InO1xudmFyIGJHdXR0ZXJTaXplID0gJ19jJztcbnZhciBIT1JJWk9OVEFMID0gJ2hvcml6b250YWwnO1xudmFyIE5PT1AgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIGRldGVybWluZXMgd2hpY2ggcHJlZml4ZXMgb2YgQ1NTIGNhbGMgd2UgbmVlZC5cbi8vIFdlIG9ubHkgbmVlZCB0byBkbyB0aGlzIG9uY2Ugb24gc3RhcnR1cCwgd2hlbiB0aGlzIGFub255bW91cyBmdW5jdGlvbiBpcyBjYWxsZWQuXG4vL1xuLy8gVGVzdHMgLXdlYmtpdCwgLW1veiBhbmQgLW8gcHJlZml4ZXMuIE1vZGlmaWVkIGZyb20gU3RhY2tPdmVyZmxvdzpcbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTY2MjUxNDAvanMtZmVhdHVyZS1kZXRlY3Rpb24tdG8tZGV0ZWN0LXRoZS11c2FnZS1vZi13ZWJraXQtY2FsYy1vdmVyLWNhbGMvMTY2MjUxNjcjMTY2MjUxNjdcbnZhciBjYWxjID0gc3NyXG4gICAgPyAnY2FsYydcbiAgICA6ICgoWycnLCAnLXdlYmtpdC0nLCAnLW1vei0nLCAnLW8tJ11cbiAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgIGVsLnN0eWxlLmNzc1RleHQgPSBcIndpZHRoOlwiICsgcHJlZml4ICsgXCJjYWxjKDlweClcIjtcblxuICAgICAgICAgICAgICByZXR1cm4gISFlbC5zdHlsZS5sZW5ndGhcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5zaGlmdCgpKSArIFwiY2FsY1wiKTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIGNoZWNrcyBpZiBpdHMgYXJndW1lbnQgaXMgYSBzdHJpbmctbGlrZSB0eXBlXG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8IHYgaW5zdGFuY2VvZiBTdHJpbmc7IH07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiBhbGxvd3MgZWxlbWVudHMgYW5kIHN0cmluZyBzZWxlY3RvcnMgdG8gYmUgdXNlZFxuLy8gaW50ZXJjaGFuZ2VhYmx5LiBJbiBlaXRoZXIgY2FzZSBhbiBlbGVtZW50IGlzIHJldHVybmVkLiBUaGlzIGFsbG93cyB1cyB0b1xuLy8gZG8gYFNwbGl0KFtlbGVtMSwgZWxlbTJdKWAgYXMgd2VsbCBhcyBgU3BsaXQoWycjaWQxJywgJyNpZDInXSlgLlxudmFyIGVsZW1lbnRPclNlbGVjdG9yID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGlzU3RyaW5nKGVsKSkge1xuICAgICAgICB2YXIgZWxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgICAgIGlmICghZWxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiU2VsZWN0b3IgXCIgKyBlbCArIFwiIGRpZCBub3QgbWF0Y2ggYSBET00gZWxlbWVudFwiKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlXG4gICAgfVxuXG4gICAgcmV0dXJuIGVsXG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gZ2V0cyBhIHByb3BlcnR5IGZyb20gdGhlIHByb3BlcnRpZXMgb2JqZWN0LCB3aXRoIGEgZGVmYXVsdCBmYWxsYmFja1xudmFyIGdldE9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zLCBwcm9wTmFtZSwgZGVmKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9uc1twcm9wTmFtZV07XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIHJldHVybiBkZWZcbn07XG5cbnZhciBnZXRHdXR0ZXJTaXplID0gZnVuY3Rpb24gKGd1dHRlclNpemUsIGlzRmlyc3QsIGlzTGFzdCwgZ3V0dGVyQWxpZ24pIHtcbiAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICBpZiAoZ3V0dGVyQWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9XG4gICAgICAgIGlmIChndXR0ZXJBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBndXR0ZXJTaXplIC8gMlxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0xhc3QpIHtcbiAgICAgICAgaWYgKGd1dHRlckFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9XG4gICAgICAgIGlmIChndXR0ZXJBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBndXR0ZXJTaXplIC8gMlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGd1dHRlclNpemVcbn07XG5cbi8vIERlZmF1bHQgb3B0aW9uc1xudmFyIGRlZmF1bHRHdXR0ZXJGbiA9IGZ1bmN0aW9uIChpLCBndXR0ZXJEaXJlY3Rpb24pIHtcbiAgICB2YXIgZ3V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZ3V0LmNsYXNzTmFtZSA9IFwiZ3V0dGVyIGd1dHRlci1cIiArIGd1dHRlckRpcmVjdGlvbjtcbiAgICByZXR1cm4gZ3V0XG59O1xuXG52YXIgZGVmYXVsdEVsZW1lbnRTdHlsZUZuID0gZnVuY3Rpb24gKGRpbSwgc2l6ZSwgZ3V0U2l6ZSkge1xuICAgIHZhciBzdHlsZSA9IHt9O1xuXG4gICAgaWYgKCFpc1N0cmluZyhzaXplKSkge1xuICAgICAgICBzdHlsZVtkaW1dID0gY2FsYyArIFwiKFwiICsgc2l6ZSArIFwiJSAtIFwiICsgZ3V0U2l6ZSArIFwicHgpXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVbZGltXSA9IHNpemU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlXG59O1xuXG52YXIgZGVmYXVsdEd1dHRlclN0eWxlRm4gPSBmdW5jdGlvbiAoZGltLCBndXRTaXplKSB7XG4gICAgdmFyIG9iajtcblxuICAgIHJldHVybiAoKCBvYmogPSB7fSwgb2JqW2RpbV0gPSAoZ3V0U2l6ZSArIFwicHhcIiksIG9iaiApKTtcbn07XG5cbi8vIFRoZSBtYWluIGZ1bmN0aW9uIHRvIGluaXRpYWxpemUgYSBzcGxpdC4gU3BsaXQuanMgdGhpbmtzIGFib3V0IGVhY2ggcGFpclxuLy8gb2YgZWxlbWVudHMgYXMgYW4gaW5kZXBlbmRhbnQgcGFpci4gRHJhZ2dpbmcgdGhlIGd1dHRlciBiZXR3ZWVuIHR3byBlbGVtZW50c1xuLy8gb25seSBjaGFuZ2VzIHRoZSBkaW1lbnNpb25zIG9mIGVsZW1lbnRzIGluIHRoYXQgcGFpci4gVGhpcyBpcyBrZXkgdG8gdW5kZXJzdGFuZGluZ1xuLy8gaG93IHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG9wZXJhdGUsIHNpbmNlIGVhY2ggZnVuY3Rpb24gaXMgYm91bmQgdG8gYSBwYWlyLlxuLy9cbi8vIEEgcGFpciBvYmplY3QgaXMgc2hhcGVkIGxpa2UgdGhpczpcbi8vXG4vLyB7XG4vLyAgICAgYTogRE9NIGVsZW1lbnQsXG4vLyAgICAgYjogRE9NIGVsZW1lbnQsXG4vLyAgICAgYU1pbjogTnVtYmVyLFxuLy8gICAgIGJNaW46IE51bWJlcixcbi8vICAgICBkcmFnZ2luZzogQm9vbGVhbixcbi8vICAgICBwYXJlbnQ6IERPTSBlbGVtZW50LFxuLy8gICAgIGRpcmVjdGlvbjogJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJ1xuLy8gfVxuLy9cbi8vIFRoZSBiYXNpYyBzZXF1ZW5jZTpcbi8vXG4vLyAxLiBTZXQgZGVmYXVsdHMgdG8gc29tZXRoaW5nIHNhbmUuIGBvcHRpb25zYCBkb2Vzbid0IGhhdmUgdG8gYmUgcGFzc2VkIGF0IGFsbC5cbi8vIDIuIEluaXRpYWxpemUgYSBidW5jaCBvZiBzdHJpbmdzIGJhc2VkIG9uIHRoZSBkaXJlY3Rpb24gd2UncmUgc3BsaXR0aW5nLlxuLy8gICAgQSBsb3Qgb2YgdGhlIGJlaGF2aW9yIGluIHRoZSByZXN0IG9mIHRoZSBsaWJyYXJ5IGlzIHBhcmFtYXRpemVkIGRvd24gdG9cbi8vICAgIHJlbHkgb24gQ1NTIHN0cmluZ3MgYW5kIGNsYXNzZXMuXG4vLyAzLiBEZWZpbmUgdGhlIGRyYWdnaW5nIGhlbHBlciBmdW5jdGlvbnMsIGFuZCBhIGZldyBoZWxwZXJzIHRvIGdvIHdpdGggdGhlbS5cbi8vIDQuIExvb3AgdGhyb3VnaCB0aGUgZWxlbWVudHMgd2hpbGUgcGFpcmluZyB0aGVtIG9mZi4gRXZlcnkgcGFpciBnZXRzIGFuXG4vLyAgICBgcGFpcmAgb2JqZWN0IGFuZCBhIGd1dHRlci5cbi8vIDUuIEFjdHVhbGx5IHNpemUgdGhlIHBhaXIgZWxlbWVudHMsIGluc2VydCBndXR0ZXJzIGFuZCBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzLlxudmFyIFNwbGl0ID0gZnVuY3Rpb24gKGlkc09wdGlvbiwgb3B0aW9ucykge1xuICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKHNzcikgeyByZXR1cm4ge30gfVxuXG4gICAgdmFyIGlkcyA9IGlkc09wdGlvbjtcbiAgICB2YXIgZGltZW5zaW9uO1xuICAgIHZhciBjbGllbnRBeGlzO1xuICAgIHZhciBwb3NpdGlvbjtcbiAgICB2YXIgcG9zaXRpb25FbmQ7XG4gICAgdmFyIGNsaWVudFNpemU7XG4gICAgdmFyIGVsZW1lbnRzO1xuXG4gICAgLy8gQWxsb3cgSFRNTENvbGxlY3Rpb24gdG8gYmUgdXNlZCBhcyBhbiBhcmd1bWVudCB3aGVuIHN1cHBvcnRlZFxuICAgIGlmIChBcnJheS5mcm9tKSB7XG4gICAgICAgIGlkcyA9IEFycmF5LmZyb20oaWRzKTtcbiAgICB9XG5cbiAgICAvLyBBbGwgRE9NIGVsZW1lbnRzIGluIHRoZSBzcGxpdCBzaG91bGQgaGF2ZSBhIGNvbW1vbiBwYXJlbnQuIFdlIGNhbiBncmFiXG4gICAgLy8gdGhlIGZpcnN0IGVsZW1lbnRzIHBhcmVudCBhbmQgaG9wZSB1c2VycyByZWFkIHRoZSBkb2NzIGJlY2F1c2UgdGhlXG4gICAgLy8gYmVoYXZpb3Igd2lsbCBiZSB3aGFja3kgb3RoZXJ3aXNlLlxuICAgIHZhciBmaXJzdEVsZW1lbnQgPSBlbGVtZW50T3JTZWxlY3RvcihpZHNbMF0pO1xuICAgIHZhciBwYXJlbnQgPSBmaXJzdEVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICB2YXIgcGFyZW50U3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlID8gZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpIDogbnVsbDtcbiAgICB2YXIgcGFyZW50RmxleERpcmVjdGlvbiA9IHBhcmVudFN0eWxlID8gcGFyZW50U3R5bGUuZmxleERpcmVjdGlvbiA6IG51bGw7XG5cbiAgICAvLyBTZXQgZGVmYXVsdCBvcHRpb25zLnNpemVzIHRvIGVxdWFsIHBlcmNlbnRhZ2VzIG9mIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICB2YXIgc2l6ZXMgPSBnZXRPcHRpb24ob3B0aW9ucywgJ3NpemVzJykgfHwgaWRzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiAxMDAgLyBpZHMubGVuZ3RoOyB9KTtcblxuICAgIC8vIFN0YW5kYXJkaXplIG1pblNpemUgYW5kIG1heFNpemUgdG8gYW4gYXJyYXkgaWYgaXQgaXNuJ3QgYWxyZWFkeS5cbiAgICAvLyBUaGlzIGFsbG93cyBtaW5TaXplIGFuZCBtYXhTaXplIHRvIGJlIHBhc3NlZCBhcyBhIG51bWJlci5cbiAgICB2YXIgbWluU2l6ZSA9IGdldE9wdGlvbihvcHRpb25zLCAnbWluU2l6ZScsIDEwMCk7XG4gICAgdmFyIG1pblNpemVzID0gQXJyYXkuaXNBcnJheShtaW5TaXplKSA/IG1pblNpemUgOiBpZHMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1pblNpemU7IH0pO1xuICAgIHZhciBtYXhTaXplID0gZ2V0T3B0aW9uKG9wdGlvbnMsICdtYXhTaXplJywgSW5maW5pdHkpO1xuICAgIHZhciBtYXhTaXplcyA9IEFycmF5LmlzQXJyYXkobWF4U2l6ZSkgPyBtYXhTaXplIDogaWRzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBtYXhTaXplOyB9KTtcblxuICAgIC8vIEdldCBvdGhlciBvcHRpb25zXG4gICAgdmFyIGV4cGFuZFRvTWluID0gZ2V0T3B0aW9uKG9wdGlvbnMsICdleHBhbmRUb01pbicsIGZhbHNlKTtcbiAgICB2YXIgZ3V0dGVyU2l6ZSA9IGdldE9wdGlvbihvcHRpb25zLCAnZ3V0dGVyU2l6ZScsIDEwKTtcbiAgICB2YXIgZ3V0dGVyQWxpZ24gPSBnZXRPcHRpb24ob3B0aW9ucywgJ2d1dHRlckFsaWduJywgJ2NlbnRlcicpO1xuICAgIHZhciBzbmFwT2Zmc2V0ID0gZ2V0T3B0aW9uKG9wdGlvbnMsICdzbmFwT2Zmc2V0JywgMzApO1xuICAgIHZhciBkcmFnSW50ZXJ2YWwgPSBnZXRPcHRpb24ob3B0aW9ucywgJ2RyYWdJbnRlcnZhbCcsIDEpO1xuICAgIHZhciBkaXJlY3Rpb24gPSBnZXRPcHRpb24ob3B0aW9ucywgJ2RpcmVjdGlvbicsIEhPUklaT05UQUwpO1xuICAgIHZhciBjdXJzb3IgPSBnZXRPcHRpb24oXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgICdjdXJzb3InLFxuICAgICAgICBkaXJlY3Rpb24gPT09IEhPUklaT05UQUwgPyAnY29sLXJlc2l6ZScgOiAncm93LXJlc2l6ZSdcbiAgICApO1xuICAgIHZhciBndXR0ZXIgPSBnZXRPcHRpb24ob3B0aW9ucywgJ2d1dHRlcicsIGRlZmF1bHRHdXR0ZXJGbik7XG4gICAgdmFyIGVsZW1lbnRTdHlsZSA9IGdldE9wdGlvbihcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgJ2VsZW1lbnRTdHlsZScsXG4gICAgICAgIGRlZmF1bHRFbGVtZW50U3R5bGVGblxuICAgICk7XG4gICAgdmFyIGd1dHRlclN0eWxlID0gZ2V0T3B0aW9uKG9wdGlvbnMsICdndXR0ZXJTdHlsZScsIGRlZmF1bHRHdXR0ZXJTdHlsZUZuKTtcblxuICAgIC8vIDIuIEluaXRpYWxpemUgYSBidW5jaCBvZiBzdHJpbmdzIGJhc2VkIG9uIHRoZSBkaXJlY3Rpb24gd2UncmUgc3BsaXR0aW5nLlxuICAgIC8vIEEgbG90IG9mIHRoZSBiZWhhdmlvciBpbiB0aGUgcmVzdCBvZiB0aGUgbGlicmFyeSBpcyBwYXJhbWF0aXplZCBkb3duIHRvXG4gICAgLy8gcmVseSBvbiBDU1Mgc3RyaW5ncyBhbmQgY2xhc3Nlcy5cbiAgICBpZiAoZGlyZWN0aW9uID09PSBIT1JJWk9OVEFMKSB7XG4gICAgICAgIGRpbWVuc2lvbiA9ICd3aWR0aCc7XG4gICAgICAgIGNsaWVudEF4aXMgPSAnY2xpZW50WCc7XG4gICAgICAgIHBvc2l0aW9uID0gJ2xlZnQnO1xuICAgICAgICBwb3NpdGlvbkVuZCA9ICdyaWdodCc7XG4gICAgICAgIGNsaWVudFNpemUgPSAnY2xpZW50V2lkdGgnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgIGRpbWVuc2lvbiA9ICdoZWlnaHQnO1xuICAgICAgICBjbGllbnRBeGlzID0gJ2NsaWVudFknO1xuICAgICAgICBwb3NpdGlvbiA9ICd0b3AnO1xuICAgICAgICBwb3NpdGlvbkVuZCA9ICdib3R0b20nO1xuICAgICAgICBjbGllbnRTaXplID0gJ2NsaWVudEhlaWdodCc7XG4gICAgfVxuXG4gICAgLy8gMy4gRGVmaW5lIHRoZSBkcmFnZ2luZyBoZWxwZXIgZnVuY3Rpb25zLCBhbmQgYSBmZXcgaGVscGVycyB0byBnbyB3aXRoIHRoZW0uXG4gICAgLy8gRWFjaCBoZWxwZXIgaXMgYm91bmQgdG8gYSBwYWlyIG9iamVjdCB0aGF0IGNvbnRhaW5zIGl0cyBtZXRhZGF0YS4gVGhpc1xuICAgIC8vIGFsc28gbWFrZXMgaXQgZWFzeSB0byBzdG9yZSByZWZlcmVuY2VzIHRvIGxpc3RlbmVycyB0aGF0IHRoYXQgd2lsbCBiZVxuICAgIC8vIGFkZGVkIGFuZCByZW1vdmVkLlxuICAgIC8vXG4gICAgLy8gRXZlbiB0aG91Z2ggdGhlcmUgYXJlIG5vIG90aGVyIGZ1bmN0aW9ucyBjb250YWluZWQgaW4gdGhlbSwgYWxpYXNpbmdcbiAgICAvLyB0aGlzIHRvIHNlbGYgc2F2ZXMgNTAgYnl0ZXMgb3Igc28gc2luY2UgaXQncyB1c2VkIHNvIGZyZXF1ZW50bHkuXG4gICAgLy9cbiAgICAvLyBUaGUgcGFpciBvYmplY3Qgc2F2ZXMgbWV0YWRhdGEgbGlrZSBkcmFnZ2luZyBzdGF0ZSwgcG9zaXRpb24gYW5kXG4gICAgLy8gZXZlbnQgbGlzdGVuZXIgcmVmZXJlbmNlcy5cblxuICAgIGZ1bmN0aW9uIHNldEVsZW1lbnRTaXplKGVsLCBzaXplLCBndXRTaXplLCBpKSB7XG4gICAgICAgIC8vIFNwbGl0LmpzIGFsbG93cyBzZXR0aW5nIHNpemVzIHZpYSBudW1iZXJzIChpZGVhbGx5KSwgb3IgaWYgeW91IG11c3QsXG4gICAgICAgIC8vIGJ5IHN0cmluZywgbGlrZSAnMzAwcHgnLiBUaGlzIGlzIGxlc3MgdGhhbiBpZGVhbCwgYmVjYXVzZSBpdCBicmVha3NcbiAgICAgICAgLy8gdGhlIGZsdWlkIGxheW91dCB0aGF0IGBjYWxjKCUgLSBweClgIHByb3ZpZGVzLiBZb3UncmUgb24geW91ciBvd24gaWYgeW91IGRvIHRoYXQsXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB5b3UgY2FsY3VsYXRlIHRoZSBndXR0ZXIgc2l6ZSBieSBoYW5kLlxuICAgICAgICB2YXIgc3R5bGUgPSBlbGVtZW50U3R5bGUoZGltZW5zaW9uLCBzaXplLCBndXRTaXplLCBpKTtcblxuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBlbC5zdHlsZVtwcm9wXSA9IHN0eWxlW3Byb3BdO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRHdXR0ZXJTaXplKGd1dHRlckVsZW1lbnQsIGd1dFNpemUsIGkpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gZ3V0dGVyU3R5bGUoZGltZW5zaW9uLCBndXRTaXplLCBpKTtcblxuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBndXR0ZXJFbGVtZW50LnN0eWxlW3Byb3BdID0gc3R5bGVbcHJvcF07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNpemVzKCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudHMubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50LnNpemU7IH0pXG4gICAgfVxuXG4gICAgLy8gU3VwcG9ydHMgdG91Y2ggZXZlbnRzLCBidXQgbm90IG11bHRpdG91Y2gsIHNvIG9ubHkgdGhlIGZpcnN0XG4gICAgLy8gZmluZ2VyIGB0b3VjaGVzWzBdYCBpcyBjb3VudGVkLlxuICAgIGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZSkge1xuICAgICAgICBpZiAoJ3RvdWNoZXMnIGluIGUpIHsgcmV0dXJuIGUudG91Y2hlc1swXVtjbGllbnRBeGlzXSB9XG4gICAgICAgIHJldHVybiBlW2NsaWVudEF4aXNdXG4gICAgfVxuXG4gICAgLy8gQWN0dWFsbHkgYWRqdXN0IHRoZSBzaXplIG9mIGVsZW1lbnRzIGBhYCBhbmQgYGJgIHRvIGBvZmZzZXRgIHdoaWxlIGRyYWdnaW5nLlxuICAgIC8vIGNhbGMgaXMgdXNlZCB0byBhbGxvdyBjYWxjKHBlcmNlbnRhZ2UgKyBndXR0ZXJweCkgb24gdGhlIHdob2xlIHNwbGl0IGluc3RhbmNlLFxuICAgIC8vIHdoaWNoIGFsbG93cyB0aGUgdmlld3BvcnQgdG8gYmUgcmVzaXplZCB3aXRob3V0IGFkZGl0aW9uYWwgbG9naWMuXG4gICAgLy8gRWxlbWVudCBhJ3Mgc2l6ZSBpcyB0aGUgc2FtZSBhcyBvZmZzZXQuIGIncyBzaXplIGlzIHRvdGFsIHNpemUgLSBhIHNpemUuXG4gICAgLy8gQm90aCBzaXplcyBhcmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBpbml0aWFsIHBhcmVudCBwZXJjZW50YWdlLFxuICAgIC8vIHRoZW4gdGhlIGd1dHRlciBzaXplIGlzIHN1YnRyYWN0ZWQuXG4gICAgZnVuY3Rpb24gYWRqdXN0KG9mZnNldCkge1xuICAgICAgICB2YXIgYSA9IGVsZW1lbnRzW3RoaXMuYV07XG4gICAgICAgIHZhciBiID0gZWxlbWVudHNbdGhpcy5iXTtcbiAgICAgICAgdmFyIHBlcmNlbnRhZ2UgPSBhLnNpemUgKyBiLnNpemU7XG5cbiAgICAgICAgYS5zaXplID0gKG9mZnNldCAvIHRoaXMuc2l6ZSkgKiBwZXJjZW50YWdlO1xuICAgICAgICBiLnNpemUgPSBwZXJjZW50YWdlIC0gKG9mZnNldCAvIHRoaXMuc2l6ZSkgKiBwZXJjZW50YWdlO1xuXG4gICAgICAgIHNldEVsZW1lbnRTaXplKGEuZWxlbWVudCwgYS5zaXplLCB0aGlzW2FHdXR0ZXJTaXplXSwgYS5pKTtcbiAgICAgICAgc2V0RWxlbWVudFNpemUoYi5lbGVtZW50LCBiLnNpemUsIHRoaXNbYkd1dHRlclNpemVdLCBiLmkpO1xuICAgIH1cblxuICAgIC8vIGRyYWcsIHdoZXJlIGFsbCB0aGUgbWFnaWMgaGFwcGVucy4gVGhlIGxvZ2ljIGlzIHJlYWxseSBxdWl0ZSBzaW1wbGU6XG4gICAgLy9cbiAgICAvLyAxLiBJZ25vcmUgaWYgdGhlIHBhaXIgaXMgbm90IGRyYWdnaW5nLlxuICAgIC8vIDIuIEdldCB0aGUgb2Zmc2V0IG9mIHRoZSBldmVudC5cbiAgICAvLyAzLiBTbmFwIG9mZnNldCB0byBtaW4gaWYgd2l0aGluIHNuYXBwYWJsZSByYW5nZSAod2l0aGluIG1pbiArIHNuYXBPZmZzZXQpLlxuICAgIC8vIDQuIEFjdHVhbGx5IGFkanVzdCBlYWNoIGVsZW1lbnQgaW4gdGhlIHBhaXIgdG8gb2Zmc2V0LlxuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gfCAgICB8IDwtIGEubWluU2l6ZSAgICAgICAgICAgICAgIHx8ICAgICAgICAgICAgICBiLm1pblNpemUgLT4gfCAgICB8XG4gICAgLy8gfCAgICB8ICB8IDwtIHRoaXMuc25hcE9mZnNldCAgICAgIHx8ICAgICB0aGlzLnNuYXBPZmZzZXQgLT4gfCAgfCAgICB8XG4gICAgLy8gfCAgICB8ICB8ICAgICAgICAgICAgICAgICAgICAgICAgIHx8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgfCAgICB8XG4gICAgLy8gfCAgICB8ICB8ICAgICAgICAgICAgICAgICAgICAgICAgIHx8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgfCAgICB8XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gfCA8LSB0aGlzLnN0YXJ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSAtPiB8XG4gICAgZnVuY3Rpb24gZHJhZyhlKSB7XG4gICAgICAgIHZhciBvZmZzZXQ7XG4gICAgICAgIHZhciBhID0gZWxlbWVudHNbdGhpcy5hXTtcbiAgICAgICAgdmFyIGIgPSBlbGVtZW50c1t0aGlzLmJdO1xuXG4gICAgICAgIGlmICghdGhpcy5kcmFnZ2luZykgeyByZXR1cm4gfVxuXG4gICAgICAgIC8vIEdldCB0aGUgb2Zmc2V0IG9mIHRoZSBldmVudCBmcm9tIHRoZSBmaXJzdCBzaWRlIG9mIHRoZVxuICAgICAgICAvLyBwYWlyIGB0aGlzLnN0YXJ0YC4gVGhlbiBvZmZzZXQgYnkgdGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlXG4gICAgICAgIC8vIG1vdXNlIGNvbXBhcmVkIHRvIHRoZSBndXR0ZXIgc2l6ZS5cbiAgICAgICAgb2Zmc2V0ID1cbiAgICAgICAgICAgIGdldE1vdXNlUG9zaXRpb24oZSkgLVxuICAgICAgICAgICAgdGhpcy5zdGFydCArXG4gICAgICAgICAgICAodGhpc1thR3V0dGVyU2l6ZV0gLSB0aGlzLmRyYWdPZmZzZXQpO1xuXG4gICAgICAgIGlmIChkcmFnSW50ZXJ2YWwgPiAxKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBNYXRoLnJvdW5kKG9mZnNldCAvIGRyYWdJbnRlcnZhbCkgKiBkcmFnSW50ZXJ2YWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3aXRoaW4gc25hcE9mZnNldCBvZiBtaW4gb3IgbWF4LCBzZXQgb2Zmc2V0IHRvIG1pbiBvciBtYXguXG4gICAgICAgIC8vIHNuYXBPZmZzZXQgYnVmZmVycyBhLm1pblNpemUgYW5kIGIubWluU2l6ZSwgc28gbG9naWMgaXMgb3Bwb3NpdGUgZm9yIGJvdGguXG4gICAgICAgIC8vIEluY2x1ZGUgdGhlIGFwcHJvcHJpYXRlIGd1dHRlciBzaXplcyB0byBwcmV2ZW50IG92ZXJmbG93cy5cbiAgICAgICAgaWYgKG9mZnNldCA8PSBhLm1pblNpemUgKyBzbmFwT2Zmc2V0ICsgdGhpc1thR3V0dGVyU2l6ZV0pIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGEubWluU2l6ZSArIHRoaXNbYUd1dHRlclNpemVdO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgb2Zmc2V0ID49XG4gICAgICAgICAgICB0aGlzLnNpemUgLSAoYi5taW5TaXplICsgc25hcE9mZnNldCArIHRoaXNbYkd1dHRlclNpemVdKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuc2l6ZSAtIChiLm1pblNpemUgKyB0aGlzW2JHdXR0ZXJTaXplXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2Zmc2V0ID49IGEubWF4U2l6ZSAtIHNuYXBPZmZzZXQgKyB0aGlzW2FHdXR0ZXJTaXplXSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gYS5tYXhTaXplICsgdGhpc1thR3V0dGVyU2l6ZV07XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBvZmZzZXQgPD1cbiAgICAgICAgICAgIHRoaXMuc2l6ZSAtIChiLm1heFNpemUgLSBzbmFwT2Zmc2V0ICsgdGhpc1tiR3V0dGVyU2l6ZV0pXG4gICAgICAgICkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5zaXplIC0gKGIubWF4U2l6ZSArIHRoaXNbYkd1dHRlclNpemVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFjdHVhbGx5IGFkanVzdCB0aGUgc2l6ZS5cbiAgICAgICAgYWRqdXN0LmNhbGwodGhpcywgb2Zmc2V0KTtcblxuICAgICAgICAvLyBDYWxsIHRoZSBkcmFnIGNhbGxiYWNrIGNvbnRpbm91c2x5LiBEb24ndCBkbyBhbnl0aGluZyB0b28gaW50ZW5zaXZlXG4gICAgICAgIC8vIGluIHRoaXMgY2FsbGJhY2suXG4gICAgICAgIGdldE9wdGlvbihvcHRpb25zLCAnb25EcmFnJywgTk9PUCkoZ2V0U2l6ZXMoKSk7XG4gICAgfVxuXG4gICAgLy8gQ2FjaGUgc29tZSBpbXBvcnRhbnQgc2l6ZXMgd2hlbiBkcmFnIHN0YXJ0cywgc28gd2UgZG9uJ3QgaGF2ZSB0byBkbyB0aGF0XG4gICAgLy8gY29udGlub3VzbHk6XG4gICAgLy9cbiAgICAvLyBgc2l6ZWA6IFRoZSB0b3RhbCBzaXplIG9mIHRoZSBwYWlyLiBGaXJzdCArIHNlY29uZCArIGZpcnN0IGd1dHRlciArIHNlY29uZCBndXR0ZXIuXG4gICAgLy8gYHN0YXJ0YDogVGhlIGxlYWRpbmcgc2lkZSBvZiB0aGUgZmlyc3QgZWxlbWVudC5cbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHwgICAgICBhR3V0dGVyU2l6ZSAtPiB8fHwgICAgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vIHwgICAgICAgICAgICAgICAgICAgICB8fHwgICAgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vIHwgICAgICAgICAgICAgICAgICAgICB8fHwgICAgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vIHwgICAgICAgICAgICAgICAgICAgICB8fHwgPC0gYkd1dHRlclNpemUgICAgICAgfFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHwgPC0gc3RhcnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgLT4gfFxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZVNpemVzKCkge1xuICAgICAgICAvLyBGaWd1cmUgb3V0IHRoZSBwYXJlbnQgc2l6ZSBtaW51cyBwYWRkaW5nLlxuICAgICAgICB2YXIgYSA9IGVsZW1lbnRzW3RoaXMuYV0uZWxlbWVudDtcbiAgICAgICAgdmFyIGIgPSBlbGVtZW50c1t0aGlzLmJdLmVsZW1lbnQ7XG5cbiAgICAgICAgdmFyIGFCb3VuZHMgPSBhW2dldEJvdW5kaW5nQ2xpZW50UmVjdF0oKTtcbiAgICAgICAgdmFyIGJCb3VuZHMgPSBiW2dldEJvdW5kaW5nQ2xpZW50UmVjdF0oKTtcblxuICAgICAgICB0aGlzLnNpemUgPVxuICAgICAgICAgICAgYUJvdW5kc1tkaW1lbnNpb25dICtcbiAgICAgICAgICAgIGJCb3VuZHNbZGltZW5zaW9uXSArXG4gICAgICAgICAgICB0aGlzW2FHdXR0ZXJTaXplXSArXG4gICAgICAgICAgICB0aGlzW2JHdXR0ZXJTaXplXTtcbiAgICAgICAgdGhpcy5zdGFydCA9IGFCb3VuZHNbcG9zaXRpb25dO1xuICAgICAgICB0aGlzLmVuZCA9IGFCb3VuZHNbcG9zaXRpb25FbmRdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlubmVyU2l6ZShlbGVtZW50KSB7XG4gICAgICAgIC8vIFJldHVybiBub3RoaW5nIGlmIGdldENvbXB1dGVkU3R5bGUgaXMgbm90IHN1cHBvcnRlZCAoPCBJRTkpXG4gICAgICAgIC8vIE9yIGlmIHBhcmVudCBlbGVtZW50IGhhcyBubyBsYXlvdXQgeWV0XG4gICAgICAgIGlmICghZ2V0Q29tcHV0ZWRTdHlsZSkgeyByZXR1cm4gbnVsbCB9XG5cbiAgICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgICAgIGlmICghY29tcHV0ZWRTdHlsZSkgeyByZXR1cm4gbnVsbCB9XG5cbiAgICAgICAgdmFyIHNpemUgPSBlbGVtZW50W2NsaWVudFNpemVdO1xuXG4gICAgICAgIGlmIChzaXplID09PSAwKSB7IHJldHVybiBudWxsIH1cblxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBIT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICBzaXplIC09XG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdMZWZ0KSArXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdSaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaXplIC09XG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdUb3ApICtcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ0JvdHRvbSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2l6ZVxuICAgIH1cblxuICAgIC8vIFdoZW4gc3BlY2lmeWluZyBwZXJjZW50YWdlIHNpemVzIHRoYXQgYXJlIGxlc3MgdGhhbiB0aGUgY29tcHV0ZWRcbiAgICAvLyBzaXplIG9mIHRoZSBlbGVtZW50IG1pbnVzIHRoZSBndXR0ZXIsIHRoZSBsZXNzZXIgcGVyY2VudGFnZXMgbXVzdCBiZSBpbmNyZWFzZWRcbiAgICAvLyAoYW5kIGRlY3JlYXNlZCBmcm9tIHRoZSBvdGhlciBlbGVtZW50cykgdG8gbWFrZSBzcGFjZSBmb3IgdGhlIHBpeGVsc1xuICAgIC8vIHN1YnRyYWN0ZWQgYnkgdGhlIGd1dHRlcnMuXG4gICAgZnVuY3Rpb24gdHJpbVRvTWluKHNpemVzVG9UcmltKSB7XG4gICAgICAgIC8vIFRyeSB0byBnZXQgaW5uZXIgc2l6ZSBvZiBwYXJlbnQgZWxlbWVudC5cbiAgICAgICAgLy8gSWYgaXQncyBubyBzdXBwb3J0ZWQsIHJldHVybiBvcmlnaW5hbCBzaXplcy5cbiAgICAgICAgdmFyIHBhcmVudFNpemUgPSBpbm5lclNpemUocGFyZW50KTtcbiAgICAgICAgaWYgKHBhcmVudFNpemUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBzaXplc1RvVHJpbVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pblNpemVzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSArIGI7IH0sIDApID4gcGFyZW50U2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpemVzVG9UcmltXG4gICAgICAgIH1cblxuICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBleGNlc3MgcGl4ZWxzLCB0aGUgYW1vdW50IG9mIHBpeGVscyBvdmVyIHRoZSBkZXNpcmVkIHBlcmNlbnRhZ2VcbiAgICAgICAgLy8gQWxzbyBrZWVwIHRyYWNrIG9mIHRoZSBlbGVtZW50cyB3aXRoIHBpeGVscyB0byBzcGFyZSwgdG8gZGVjcmVhc2UgYWZ0ZXIgaWYgbmVlZGVkXG4gICAgICAgIHZhciBleGNlc3NQaXhlbHMgPSAwO1xuICAgICAgICB2YXIgdG9TcGFyZSA9IFtdO1xuXG4gICAgICAgIHZhciBwaXhlbFNpemVzID0gc2l6ZXNUb1RyaW0ubWFwKGZ1bmN0aW9uIChzaXplLCBpKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHJlcXVlc3RlZCBwZXJjZW50YWdlcyB0byBwaXhlbCBzaXplc1xuICAgICAgICAgICAgdmFyIHBpeGVsU2l6ZSA9IChwYXJlbnRTaXplICogc2l6ZSkgLyAxMDA7XG4gICAgICAgICAgICB2YXIgZWxlbWVudEd1dHRlclNpemUgPSBnZXRHdXR0ZXJTaXplKFxuICAgICAgICAgICAgICAgIGd1dHRlclNpemUsXG4gICAgICAgICAgICAgICAgaSA9PT0gMCxcbiAgICAgICAgICAgICAgICBpID09PSBzaXplc1RvVHJpbS5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgIGd1dHRlckFsaWduXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRNaW5TaXplID0gbWluU2l6ZXNbaV0gKyBlbGVtZW50R3V0dGVyU2l6ZTtcblxuICAgICAgICAgICAgLy8gSWYgZWxlbWVudCBpcyB0b28gc21hbCwgaW5jcmVhc2UgZXhjZXNzIHBpeGVscyBieSB0aGUgZGlmZmVyZW5jZVxuICAgICAgICAgICAgLy8gYW5kIG1hcmsgdGhhdCBpdCBoYXMgbm8gcGl4ZWxzIHRvIHNwYXJlXG4gICAgICAgICAgICBpZiAocGl4ZWxTaXplIDwgZWxlbWVudE1pblNpemUpIHtcbiAgICAgICAgICAgICAgICBleGNlc3NQaXhlbHMgKz0gZWxlbWVudE1pblNpemUgLSBwaXhlbFNpemU7XG4gICAgICAgICAgICAgICAgdG9TcGFyZS5wdXNoKDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50TWluU2l6ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIG1hcmsgdGhlIHBpeGVscyBpdCBoYXMgdG8gc3BhcmUgYW5kIHJldHVybiBpdCdzIG9yaWdpbmFsIHNpemVcbiAgICAgICAgICAgIHRvU3BhcmUucHVzaChwaXhlbFNpemUgLSBlbGVtZW50TWluU2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4gcGl4ZWxTaXplXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIElmIG5vdGhpbmcgd2FzIGFkanVzdGVkLCByZXR1cm4gdGhlIG9yaWdpbmFsIHNpemVzXG4gICAgICAgIGlmIChleGNlc3NQaXhlbHMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzaXplc1RvVHJpbVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBpeGVsU2l6ZXMubWFwKGZ1bmN0aW9uIChwaXhlbFNpemUsIGkpIHtcbiAgICAgICAgICAgIHZhciBuZXdQaXhlbFNpemUgPSBwaXhlbFNpemU7XG5cbiAgICAgICAgICAgIC8vIFdoaWxlIHRoZXJlJ3Mgc3RpbGwgcGl4ZWxzIHRvIHRha2UsIGFuZCB0aGVyZSdzIGVub3VnaCBwaXhlbHMgdG8gc3BhcmUsXG4gICAgICAgICAgICAvLyB0YWtlIGFzIG1hbnkgYXMgcG9zc2libGUgdXAgdG8gdGhlIHRvdGFsIGV4Y2VzcyBwaXhlbHNcbiAgICAgICAgICAgIGlmIChleGNlc3NQaXhlbHMgPiAwICYmIHRvU3BhcmVbaV0gLSBleGNlc3NQaXhlbHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRha2VuUGl4ZWxzID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICAgIGV4Y2Vzc1BpeGVscyxcbiAgICAgICAgICAgICAgICAgICAgdG9TcGFyZVtpXSAtIGV4Y2Vzc1BpeGVsc1xuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgYW1vdW50IHRha2VuIGZvciB0aGUgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICBleGNlc3NQaXhlbHMgLT0gdGFrZW5QaXhlbHM7XG4gICAgICAgICAgICAgICAgbmV3UGl4ZWxTaXplID0gcGl4ZWxTaXplIC0gdGFrZW5QaXhlbHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgcGl4ZWwgc2l6ZSBhZGp1c3RlZCBhcyBhIHBlcmNlbnRhZ2VcbiAgICAgICAgICAgIHJldHVybiAobmV3UGl4ZWxTaXplIC8gcGFyZW50U2l6ZSkgKiAxMDBcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBzdG9wRHJhZ2dpbmcgaXMgdmVyeSBzaW1pbGFyIHRvIHN0YXJ0RHJhZ2dpbmcgaW4gcmV2ZXJzZS5cbiAgICBmdW5jdGlvbiBzdG9wRHJhZ2dpbmcoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGEgPSBlbGVtZW50c1tzZWxmLmFdLmVsZW1lbnQ7XG4gICAgICAgIHZhciBiID0gZWxlbWVudHNbc2VsZi5iXS5lbGVtZW50O1xuXG4gICAgICAgIGlmIChzZWxmLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICBnZXRPcHRpb24ob3B0aW9ucywgJ29uRHJhZ0VuZCcsIE5PT1ApKGdldFNpemVzKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5kcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgc3RvcmVkIGV2ZW50IGxpc3RlbmVycy4gVGhpcyBpcyB3aHkgd2Ugc3RvcmUgdGhlbS5cbiAgICAgICAgZ2xvYmFsW3JlbW92ZUV2ZW50TGlzdGVuZXJdKCdtb3VzZXVwJywgc2VsZi5zdG9wKTtcbiAgICAgICAgZ2xvYmFsW3JlbW92ZUV2ZW50TGlzdGVuZXJdKCd0b3VjaGVuZCcsIHNlbGYuc3RvcCk7XG4gICAgICAgIGdsb2JhbFtyZW1vdmVFdmVudExpc3RlbmVyXSgndG91Y2hjYW5jZWwnLCBzZWxmLnN0b3ApO1xuICAgICAgICBnbG9iYWxbcmVtb3ZlRXZlbnRMaXN0ZW5lcl0oJ21vdXNlbW92ZScsIHNlbGYubW92ZSk7XG4gICAgICAgIGdsb2JhbFtyZW1vdmVFdmVudExpc3RlbmVyXSgndG91Y2htb3ZlJywgc2VsZi5tb3ZlKTtcblxuICAgICAgICAvLyBDbGVhciBib3VuZCBmdW5jdGlvbiByZWZlcmVuY2VzXG4gICAgICAgIHNlbGYuc3RvcCA9IG51bGw7XG4gICAgICAgIHNlbGYubW92ZSA9IG51bGw7XG5cbiAgICAgICAgYVtyZW1vdmVFdmVudExpc3RlbmVyXSgnc2VsZWN0c3RhcnQnLCBOT09QKTtcbiAgICAgICAgYVtyZW1vdmVFdmVudExpc3RlbmVyXSgnZHJhZ3N0YXJ0JywgTk9PUCk7XG4gICAgICAgIGJbcmVtb3ZlRXZlbnRMaXN0ZW5lcl0oJ3NlbGVjdHN0YXJ0JywgTk9PUCk7XG4gICAgICAgIGJbcmVtb3ZlRXZlbnRMaXN0ZW5lcl0oJ2RyYWdzdGFydCcsIE5PT1ApO1xuXG4gICAgICAgIGEuc3R5bGUudXNlclNlbGVjdCA9ICcnO1xuICAgICAgICBhLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnJztcbiAgICAgICAgYS5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gJyc7XG4gICAgICAgIGEuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuXG4gICAgICAgIGIuc3R5bGUudXNlclNlbGVjdCA9ICcnO1xuICAgICAgICBiLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnJztcbiAgICAgICAgYi5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gJyc7XG4gICAgICAgIGIuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuXG4gICAgICAgIHNlbGYuZ3V0dGVyLnN0eWxlLmN1cnNvciA9ICcnO1xuICAgICAgICBzZWxmLnBhcmVudC5zdHlsZS5jdXJzb3IgPSAnJztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnJztcbiAgICB9XG5cbiAgICAvLyBzdGFydERyYWdnaW5nIGNhbGxzIGBjYWxjdWxhdGVTaXplc2AgdG8gc3RvcmUgdGhlIGluaXRhbCBzaXplIGluIHRoZSBwYWlyIG9iamVjdC5cbiAgICAvLyBJdCBhbHNvIGFkZHMgZXZlbnQgbGlzdGVuZXJzIGZvciBtb3VzZS90b3VjaCBldmVudHMsXG4gICAgLy8gYW5kIHByZXZlbnRzIHNlbGVjdGlvbiB3aGlsZSBkcmFnZ2luZyBzbyBhdm9pZCB0aGUgc2VsZWN0aW5nIHRleHQuXG4gICAgZnVuY3Rpb24gc3RhcnREcmFnZ2luZyhlKSB7XG4gICAgICAgIC8vIFJpZ2h0LWNsaWNraW5nIGNhbid0IHN0YXJ0IGRyYWdnaW5nLlxuICAgICAgICBpZiAoJ2J1dHRvbicgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGlhcyBmcmVxdWVudGx5IHVzZWQgdmFyaWFibGVzIHRvIHNhdmUgc3BhY2UuIDIwMCBieXRlcy5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgYSA9IGVsZW1lbnRzW3NlbGYuYV0uZWxlbWVudDtcbiAgICAgICAgdmFyIGIgPSBlbGVtZW50c1tzZWxmLmJdLmVsZW1lbnQ7XG5cbiAgICAgICAgLy8gQ2FsbCB0aGUgb25EcmFnU3RhcnQgY2FsbGJhY2suXG4gICAgICAgIGlmICghc2VsZi5kcmFnZ2luZykge1xuICAgICAgICAgICAgZ2V0T3B0aW9uKG9wdGlvbnMsICdvbkRyYWdTdGFydCcsIE5PT1ApKGdldFNpemVzKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9uJ3QgYWN0dWFsbHkgZHJhZyB0aGUgZWxlbWVudC4gV2UgZW11bGF0ZSB0aGF0IGluIHRoZSBkcmFnIGZ1bmN0aW9uLlxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBkcmFnZ2luZyBwcm9wZXJ0eSBvZiB0aGUgcGFpciBvYmplY3QuXG4gICAgICAgIHNlbGYuZHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0d28gZXZlbnQgbGlzdGVuZXJzIGJvdW5kIHRvIHRoZSBzYW1lIHBhaXIgb2JqZWN0IGFuZCBzdG9yZVxuICAgICAgICAvLyB0aGVtIGluIHRoZSBwYWlyIG9iamVjdC5cbiAgICAgICAgc2VsZi5tb3ZlID0gZHJhZy5iaW5kKHNlbGYpO1xuICAgICAgICBzZWxmLnN0b3AgPSBzdG9wRHJhZ2dpbmcuYmluZChzZWxmKTtcblxuICAgICAgICAvLyBBbGwgdGhlIGJpbmRpbmcuIGB3aW5kb3dgIGdldHMgdGhlIHN0b3AgZXZlbnRzIGluIGNhc2Ugd2UgZHJhZyBvdXQgb2YgdGhlIGVsZW1lbnRzLlxuICAgICAgICBnbG9iYWxbYWRkRXZlbnRMaXN0ZW5lcl0oJ21vdXNldXAnLCBzZWxmLnN0b3ApO1xuICAgICAgICBnbG9iYWxbYWRkRXZlbnRMaXN0ZW5lcl0oJ3RvdWNoZW5kJywgc2VsZi5zdG9wKTtcbiAgICAgICAgZ2xvYmFsW2FkZEV2ZW50TGlzdGVuZXJdKCd0b3VjaGNhbmNlbCcsIHNlbGYuc3RvcCk7XG4gICAgICAgIGdsb2JhbFthZGRFdmVudExpc3RlbmVyXSgnbW91c2Vtb3ZlJywgc2VsZi5tb3ZlKTtcbiAgICAgICAgZ2xvYmFsW2FkZEV2ZW50TGlzdGVuZXJdKCd0b3VjaG1vdmUnLCBzZWxmLm1vdmUpO1xuXG4gICAgICAgIC8vIERpc2FibGUgc2VsZWN0aW9uLiBEaXNhYmxlIVxuICAgICAgICBhW2FkZEV2ZW50TGlzdGVuZXJdKCdzZWxlY3RzdGFydCcsIE5PT1ApO1xuICAgICAgICBhW2FkZEV2ZW50TGlzdGVuZXJdKCdkcmFnc3RhcnQnLCBOT09QKTtcbiAgICAgICAgYlthZGRFdmVudExpc3RlbmVyXSgnc2VsZWN0c3RhcnQnLCBOT09QKTtcbiAgICAgICAgYlthZGRFdmVudExpc3RlbmVyXSgnZHJhZ3N0YXJ0JywgTk9PUCk7XG5cbiAgICAgICAgYS5zdHlsZS51c2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgICAgICBhLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICAgIGEuc3R5bGUuTW96VXNlclNlbGVjdCA9ICdub25lJztcbiAgICAgICAgYS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuXG4gICAgICAgIGIuc3R5bGUudXNlclNlbGVjdCA9ICdub25lJztcbiAgICAgICAgYi5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgICAgICBiLnN0eWxlLk1velVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICAgIGIuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcblxuICAgICAgICAvLyBTZXQgdGhlIGN1cnNvciBhdCBtdWx0aXBsZSBsZXZlbHNcbiAgICAgICAgc2VsZi5ndXR0ZXIuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuICAgICAgICBzZWxmLnBhcmVudC5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuXG4gICAgICAgIC8vIENhY2hlIHRoZSBpbml0aWFsIHNpemVzIG9mIHRoZSBwYWlyLlxuICAgICAgICBjYWxjdWxhdGVTaXplcy5jYWxsKHNlbGYpO1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgdGhlIG1vdXNlIGNvbXBhcmVkIHRvIHRoZSBndXR0ZXJcbiAgICAgICAgc2VsZi5kcmFnT2Zmc2V0ID0gZ2V0TW91c2VQb3NpdGlvbihlKSAtIHNlbGYuZW5kO1xuICAgIH1cblxuICAgIC8vIGFkanVzdCBzaXplcyB0byBlbnN1cmUgcGVyY2VudGFnZSBpcyB3aXRoaW4gbWluIHNpemUgYW5kIGd1dHRlci5cbiAgICBzaXplcyA9IHRyaW1Ub01pbihzaXplcyk7XG5cbiAgICAvLyA1LiBDcmVhdGUgcGFpciBhbmQgZWxlbWVudCBvYmplY3RzLiBFYWNoIHBhaXIgaGFzIGFuIGluZGV4IHJlZmVyZW5jZSB0b1xuICAgIC8vIGVsZW1lbnRzIGBhYCBhbmQgYGJgIG9mIHRoZSBwYWlyIChmaXJzdCBhbmQgc2Vjb25kIGVsZW1lbnRzKS5cbiAgICAvLyBMb29wIHRocm91Z2ggdGhlIGVsZW1lbnRzIHdoaWxlIHBhaXJpbmcgdGhlbSBvZmYuIEV2ZXJ5IHBhaXIgZ2V0cyBhXG4gICAgLy8gYHBhaXJgIG9iamVjdCBhbmQgYSBndXR0ZXIuXG4gICAgLy9cbiAgICAvLyBCYXNpYyBsb2dpYzpcbiAgICAvL1xuICAgIC8vIC0gU3RhcnRpbmcgd2l0aCB0aGUgc2Vjb25kIGVsZW1lbnQgYGkgPiAwYCwgY3JlYXRlIGBwYWlyYCBvYmplY3RzIHdpdGhcbiAgICAvLyAgIGBhID0gaSAtIDFgIGFuZCBgYiA9IGlgXG4gICAgLy8gLSBTZXQgZ3V0dGVyIHNpemVzIGJhc2VkIG9uIHRoZSBfcGFpcl8gYmVpbmcgZmlyc3QvbGFzdC4gVGhlIGZpcnN0IGFuZCBsYXN0XG4gICAgLy8gICBwYWlyIGhhdmUgZ3V0dGVyU2l6ZSAvIDIsIHNpbmNlIHRoZXkgb25seSBoYXZlIG9uZSBoYWxmIGd1dHRlciwgYW5kIG5vdCB0d28uXG4gICAgLy8gLSBDcmVhdGUgZ3V0dGVyIGVsZW1lbnRzIGFuZCBhZGQgZXZlbnQgbGlzdGVuZXJzLlxuICAgIC8vIC0gU2V0IHRoZSBzaXplIG9mIHRoZSBlbGVtZW50cywgbWludXMgdGhlIGd1dHRlciBzaXplcy5cbiAgICAvL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gfCAgICAgaT0wICAgICB8ICAgICAgICAgaT0xICAgICAgICAgfCAgICAgICAgaT0yICAgICAgIHwgICAgICBpPTMgICAgIHxcbiAgICAvLyB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICAgIC8vIHwgICAgICAgICAgIHBhaXIgMCAgICAgICAgICAgICAgICBwYWlyIDEgICAgICAgICAgICAgcGFpciAyICAgICAgICAgICB8XG4gICAgLy8gfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBwYWlycyA9IFtdO1xuICAgIGVsZW1lbnRzID0gaWRzLm1hcChmdW5jdGlvbiAoaWQsIGkpIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBlbGVtZW50IG9iamVjdC5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50T3JTZWxlY3RvcihpZCksXG4gICAgICAgICAgICBzaXplOiBzaXplc1tpXSxcbiAgICAgICAgICAgIG1pblNpemU6IG1pblNpemVzW2ldLFxuICAgICAgICAgICAgbWF4U2l6ZTogbWF4U2l6ZXNbaV0sXG4gICAgICAgICAgICBpOiBpLFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwYWlyO1xuXG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBwYWlyIG9iamVjdCB3aXRoIGl0cyBtZXRhZGF0YS5cbiAgICAgICAgICAgIHBhaXIgPSB7XG4gICAgICAgICAgICAgICAgYTogaSAtIDEsXG4gICAgICAgICAgICAgICAgYjogaSxcbiAgICAgICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBwYWlyW2FHdXR0ZXJTaXplXSA9IGdldEd1dHRlclNpemUoXG4gICAgICAgICAgICAgICAgZ3V0dGVyU2l6ZSxcbiAgICAgICAgICAgICAgICBpIC0gMSA9PT0gMCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBndXR0ZXJBbGlnblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHBhaXJbYkd1dHRlclNpemVdID0gZ2V0R3V0dGVyU2l6ZShcbiAgICAgICAgICAgICAgICBndXR0ZXJTaXplLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIGkgPT09IGlkcy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgIGd1dHRlckFsaWduXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgcGFyZW50IGhhcyBhIHJldmVyc2UgZmxleC1kaXJlY3Rpb24sIHN3aXRjaCB0aGUgcGFpciBlbGVtZW50cy5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBwYXJlbnRGbGV4RGlyZWN0aW9uID09PSAncm93LXJldmVyc2UnIHx8XG4gICAgICAgICAgICAgICAgcGFyZW50RmxleERpcmVjdGlvbiA9PT0gJ2NvbHVtbi1yZXZlcnNlJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBwYWlyLmE7XG4gICAgICAgICAgICAgICAgcGFpci5hID0gcGFpci5iO1xuICAgICAgICAgICAgICAgIHBhaXIuYiA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHNpemUgb2YgdGhlIGN1cnJlbnQgZWxlbWVudC4gSUU4IGlzIHN1cHBvcnRlZCBieVxuICAgICAgICAvLyBzdGF0aWNseSBhc3NpZ25pbmcgc2l6ZXMgd2l0aG91dCBkcmFnZ2FibGUgZ3V0dGVycy4gQXNzaWducyBhIHN0cmluZ1xuICAgICAgICAvLyB0byBgc2l6ZWAuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIENyZWF0ZSBndXR0ZXIgZWxlbWVudHMgZm9yIGVhY2ggcGFpci5cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICB2YXIgZ3V0dGVyRWxlbWVudCA9IGd1dHRlcihpLCBkaXJlY3Rpb24sIGVsZW1lbnQuZWxlbWVudCk7XG4gICAgICAgICAgICBzZXRHdXR0ZXJTaXplKGd1dHRlckVsZW1lbnQsIGd1dHRlclNpemUsIGkpO1xuXG4gICAgICAgICAgICAvLyBTYXZlIGJvdW5kIGV2ZW50IGxpc3RlbmVyIGZvciByZW1vdmFsIGxhdGVyXG4gICAgICAgICAgICBwYWlyW2d1dHRlclN0YXJ0RHJhZ2dpbmddID0gc3RhcnREcmFnZ2luZy5iaW5kKHBhaXIpO1xuXG4gICAgICAgICAgICAvLyBBdHRhY2ggYm91bmQgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgICAgIGd1dHRlckVsZW1lbnRbYWRkRXZlbnRMaXN0ZW5lcl0oXG4gICAgICAgICAgICAgICAgJ21vdXNlZG93bicsXG4gICAgICAgICAgICAgICAgcGFpcltndXR0ZXJTdGFydERyYWdnaW5nXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGd1dHRlckVsZW1lbnRbYWRkRXZlbnRMaXN0ZW5lcl0oXG4gICAgICAgICAgICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgICAgICAgICAgIHBhaXJbZ3V0dGVyU3RhcnREcmFnZ2luZ11cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZ3V0dGVyRWxlbWVudCwgZWxlbWVudC5lbGVtZW50KTtcblxuICAgICAgICAgICAgcGFpci5ndXR0ZXIgPSBndXR0ZXJFbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0RWxlbWVudFNpemUoXG4gICAgICAgICAgICBlbGVtZW50LmVsZW1lbnQsXG4gICAgICAgICAgICBlbGVtZW50LnNpemUsXG4gICAgICAgICAgICBnZXRHdXR0ZXJTaXplKFxuICAgICAgICAgICAgICAgIGd1dHRlclNpemUsXG4gICAgICAgICAgICAgICAgaSA9PT0gMCxcbiAgICAgICAgICAgICAgICBpID09PSBpZHMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICBndXR0ZXJBbGlnblxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBBZnRlciB0aGUgZmlyc3QgaXRlcmF0aW9uLCBhbmQgd2UgaGF2ZSBhIHBhaXIgb2JqZWN0LCBhcHBlbmQgaXQgdG8gdGhlXG4gICAgICAgIC8vIGxpc3Qgb2YgcGFpcnMuXG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgcGFpcnMucHVzaChwYWlyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtZW50XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGp1c3RUb01pbihlbGVtZW50KSB7XG4gICAgICAgIHZhciBpc0xhc3QgPSBlbGVtZW50LmkgPT09IHBhaXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIHBhaXIgPSBpc0xhc3QgPyBwYWlyc1tlbGVtZW50LmkgLSAxXSA6IHBhaXJzW2VsZW1lbnQuaV07XG5cbiAgICAgICAgY2FsY3VsYXRlU2l6ZXMuY2FsbChwYWlyKTtcblxuICAgICAgICB2YXIgc2l6ZSA9IGlzTGFzdFxuICAgICAgICAgICAgPyBwYWlyLnNpemUgLSBlbGVtZW50Lm1pblNpemUgLSBwYWlyW2JHdXR0ZXJTaXplXVxuICAgICAgICAgICAgOiBlbGVtZW50Lm1pblNpemUgKyBwYWlyW2FHdXR0ZXJTaXplXTtcblxuICAgICAgICBhZGp1c3QuY2FsbChwYWlyLCBzaXplKTtcbiAgICB9XG5cbiAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBjb21wdXRlZFNpemUgPSBlbGVtZW50LmVsZW1lbnRbZ2V0Qm91bmRpbmdDbGllbnRSZWN0XSgpW2RpbWVuc2lvbl07XG5cbiAgICAgICAgaWYgKGNvbXB1dGVkU2l6ZSA8IGVsZW1lbnQubWluU2l6ZSkge1xuICAgICAgICAgICAgaWYgKGV4cGFuZFRvTWluKSB7XG4gICAgICAgICAgICAgICAgYWRqdXN0VG9NaW4oZWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGVsZW1lbnQubWluU2l6ZSA9IGNvbXB1dGVkU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gc2V0U2l6ZXMobmV3U2l6ZXMpIHtcbiAgICAgICAgdmFyIHRyaW1tZWQgPSB0cmltVG9NaW4obmV3U2l6ZXMpO1xuICAgICAgICB0cmltbWVkLmZvckVhY2goZnVuY3Rpb24gKG5ld1NpemUsIGkpIHtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaSAtIDFdO1xuXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBlbGVtZW50c1twYWlyLmFdO1xuICAgICAgICAgICAgICAgIHZhciBiID0gZWxlbWVudHNbcGFpci5iXTtcblxuICAgICAgICAgICAgICAgIGEuc2l6ZSA9IHRyaW1tZWRbaSAtIDFdO1xuICAgICAgICAgICAgICAgIGIuc2l6ZSA9IG5ld1NpemU7XG5cbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2l6ZShhLmVsZW1lbnQsIGEuc2l6ZSwgcGFpclthR3V0dGVyU2l6ZV0sIGEuaSk7XG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFNpemUoYi5lbGVtZW50LCBiLnNpemUsIHBhaXJbYkd1dHRlclNpemVdLCBiLmkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXN0cm95KHByZXNlcnZlU3R5bGVzLCBwcmVzZXJ2ZUd1dHRlcikge1xuICAgICAgICBwYWlycy5mb3JFYWNoKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgICAgICBpZiAocHJlc2VydmVHdXR0ZXIgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBwYWlyLnBhcmVudC5yZW1vdmVDaGlsZChwYWlyLmd1dHRlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhaXIuZ3V0dGVyW3JlbW92ZUV2ZW50TGlzdGVuZXJdKFxuICAgICAgICAgICAgICAgICAgICAnbW91c2Vkb3duJyxcbiAgICAgICAgICAgICAgICAgICAgcGFpcltndXR0ZXJTdGFydERyYWdnaW5nXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcGFpci5ndXR0ZXJbcmVtb3ZlRXZlbnRMaXN0ZW5lcl0oXG4gICAgICAgICAgICAgICAgICAgICd0b3VjaHN0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgcGFpcltndXR0ZXJTdGFydERyYWdnaW5nXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmVzZXJ2ZVN0eWxlcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGVsZW1lbnRTdHlsZShcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uLFxuICAgICAgICAgICAgICAgICAgICBwYWlyLmEuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgcGFpclthR3V0dGVyU2l6ZV1cbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc3R5bGUpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbcGFpci5hXS5lbGVtZW50LnN0eWxlW3Byb3BdID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzW3BhaXIuYl0uZWxlbWVudC5zdHlsZVtwcm9wXSA9ICcnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzZXRTaXplczogc2V0U2l6ZXMsXG4gICAgICAgIGdldFNpemVzOiBnZXRTaXplcyxcbiAgICAgICAgY29sbGFwc2U6IGZ1bmN0aW9uIGNvbGxhcHNlKGkpIHtcbiAgICAgICAgICAgIGFkanVzdFRvTWluKGVsZW1lbnRzW2ldKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveTogZGVzdHJveSxcbiAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgIHBhaXJzOiBwYWlycyxcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTcGxpdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/split.js/dist/split.es.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/vendor/Onix/js/codeEditor/grapeCodeEditor.js");
/******/ 	
/******/ })()
;